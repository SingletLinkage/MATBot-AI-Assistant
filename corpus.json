[
    {
        "title": "Enable Development Computer Communication (Windows)",
        "introduction": "To communicate from your MATLAB\u00c2\u00ae development computer (Windows\u00c2\u00ae) to your Speedgoat\u00c2\u00ae target computer by using an Ethernet connection, perform a one-time configuration of your MATLAB development computer (Windows) Ethernet port to use Internet Protocol Version 4 (TCP/IPv4) only. Specify a nonroutable static IP address of the form 192.168.x.x.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/development-computer-communication-setup-windows.html",
        "images": []
    },
    {
        "title": "Troubleshoot Working with Persistent Variables",
        "introduction": "When running the getPersistentVariables function or setPersistentVariables function, this error appears: getPersistentVariables | setPersistentVariables | Persistent Variable Read | Persistent Variable Write",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "This error message indicates that the file on the Speedgoat\u00c2\u00ae target computer that stores the persistent variable values is corrupted or unreadable."
            },
            {
                "heading": "Try This Workaround",
                "content": "To resolve this issue, clear the persistent variable values that are stored on the target computer.\n\nOn the development computer, create a Target object tg and connect to the target computer.tg = slrealtime; connect(tg);Use the setPersistentVariables function to clear the persistent variable values that are stored on the target computer.setPersistentVariables(tg,[]);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-working-with-persistent-variables.html",
        "images": []
    },
    {
        "title": "Determine Where to Store Variables and Objects for Simulink Models",
        "introduction": "Simulink\u00c2\u00ae data are objects and variables that you create in a workspace such as the base workspace or a data dictionary. Simulink data includes: You can store, partition, and share model data in a location that is appropriate for your design. The storage locations that you choose can depend on:",
        "chunks": [
            {
                "heading": "Types of Data",
                "content": "Simulation data is the set of input data for a simulation and the set of output data that a simulation generates. For example, you can use variables to store input data that a simulation acquires through Inport blocks, and you can use Outport blocks, To Workspace blocks, and logged signals to export output data. For more information about loading, generating, and storing simulation data, see Comparison of Signal Loading Techniques and Save Simulation Data.Design data is the set of variables and data objects that you use to specify block parameters and signal characteristics in a model and its generated code. For example, design data includes numeric MATLAB variables, value type objects, and parameter and signal data objects.You can store design data in the base workspace, model workspaces, MAT files, or the Design Data section of a data dictionary. To permanently store local design data with a model, use model workspaces. For sharing design data between models, use MAT files, data dictionaries, or the base workspace. MAT files and data dictionaries permanently store the data. You can store data in a MAT file and link it to the model. By using data dictionaries, you can partition the data to ease readability and maintenance, and track changes. If you use the base workspace, to permanently store the data, you must save it in a MAT file or create a MATLAB script that can regenerate the data. Architectural data is composed of model interfaces, such as port interfaces, data types, and system wide constants and their platform properties that are shared across Simulink and architecture models.You can store architectural data for your model in the Architectural Data section of a Simulink data dictionary. To add, edit, or remove this data you can use the Architectural Data Editor, see Store Shared Data in Architectural Data Section for more information. You can also use the object API Simulink.dictionary.ArchitecturalData, see Store Data in Architectural Data Section Programmatically for more information. To move design data to the Architectural Data section right-click the design data object in Model Explorer and select Treat As Architectural Data from the context menu.ConfigurationsConfiguration sets are sets of model configuration parameters. By default, configuration sets reside in the model file, so you do not need to store the sets separately from the model. However, you cannot share these configuration sets with other models.To share configuration sets between models, you must create Simulink.ConfigSet objects. Each object represents a standalone configuration set. You can store these objects in the base workspace or in the Configurations section of a data dictionary. If you use data dictionaries, you can define the scope of each configuration set, compare different configuration sets, and track changes. A data dictionary inherently partitions configuration sets from other kinds of data.Variant configuration objects store information about variant configurations, active and default variant settings, and definitions of the control variable associated with each configuration. You can use Variant Manager to create and edit variant configuration objects in data dictionaries or the base workspace. For more information, see Variant Manager for Simulink."
            },
            {
                "heading": "Types of Data Storage",
                "content": "Types of data storage include:\n\nThe MATLAB base workspace \u00e2\u0080\u0094 Use the base workspace to store variables while you experiment with temporary models.A model workspace \u00e2\u0080\u0094 Use a model workspace to permanently store data that is local to a model.A MATLAB file \u00e2\u0080\u0094 Use MAT file to permanently store global data and share data between models. (since R2024b)A data dictionary \u00e2\u0080\u0094 Use data dictionaries to permanently store global data, share data between models, and track changes made to data.\n\nThe table compares the characteristics of each storage location.\n\nData Storage TypeFile StorageModel-Data SeparationSync with Source File on DiskDifferent Data for Different ModelsVisibilityBase Workspace MATLAB code (.m)MATLAB file (.mat) YesNoNoGlobalModel WorkspaceModel file (.slx), .m, or .matOptionalYes (synchronization at model initialization)YesLocalMATLAB file (since R2024b)MAT file (.mat)YesYesYesSharedData DictionarySimulink Data Dictionary file (.sldd)YesYesYesShared\n\nYou can associate a MAT file or a data dictionary to models to share data between them, depending on your needs and preferences. While MAT files are easy to use, data dictionaries provide:\n\nChange trackingRequirements linking\n\nFor information about the way that models interact with workspaces and workspace variables, see Symbol Resolution."
            },
            {
                "heading": "Temporary Data: Base Workspace",
                "content": "Use the base workspace to temporarily store data:\n\nWhile you learn to use SimulinkWhen you need to quickly create variables while experimenting with modeling techniquesWhen you do not need to store the data permanently\n\nTo create variables in the base workspace, you can use the MATLAB command prompt or the Model Explorer. All open models can use the data that you create in the base workspace by default. To encapsulate your model, you can choose to disable access to the base workspace (see Continue to Use Shared Data in the Base Workspace).\n\nIf you use variables to specify numeric block parameters in the model, you can programmatically change the parameter values during simulation by using commands at the command prompt.\n\nTo permanently store base workspace data before you end a MATLAB session, save the data in a MAT file or a script file. During a later session, you can load the data from the file. However, if you make changes to the data in the base workspace, you must save the data to the file again. Consider linking MAT file to your model as external data source to permanently store data. Alternatively, you can also use model workspace or data dictionary as your project scales up."
            },
            {
                "heading": "Local Data: Model Workspace",
                "content": "Each model has its own workspace for storing variable values. Variables in a model workspace are visible only in the scope of the model. The model workspace is initialized from a data source that can be a model file, a MATLAB file, or MATLAB code stored in the model file.\n\nUse a model workspace to store data that you use only in the associated model. This data can include:\n\nModel parameters, such as numeric variables that you use to specify block parameter valuesData objects, such as Simulink.Parameter objects, that you use to control parameter characteristicsModel arguments\n\nYou can improve model portability and establish data ownership by storing the data in the model workspace. In this case, the model file permanently stores the data.\n\nIn a model reference hierarchy, each model workspace acts as a unique namespace. Therefore, you can use the same variable name in multiple model workspaces. You can then assign different values for each model.\n\nYou can use the Model Explorer to manipulate model workspace data. Alternatively, you can use the command prompt or scripts in conjunction with the model workspace programmatic interface.\n\nFor more information about using model workspaces to store local data, see Model Workspaces."
            },
            {
                "heading": "Global and Shared Data: MATLAB file",
                "content": "Since R2024b\n\nYou can store data in a MAT file and link it to your model. Linking a MAT file directly to the model permanently stores data with the model. You can associate the MAT file to multiple models to share data between them. You can also link multiple MAT files to a single model.\n\nUse a MAT file to store data that you want to share between a specific set of models. This data can include:\n\nNumeric variables that multiple models use to specify block parameter values.Simulink.AliasType and Simulink.NumericType objects that you use to specify data types in multiple models at the same time.Data objects, including signal objects (such as Simulink.Signal) that use a storage class other than Auto. If you have a Simulink Coder\u00e2\u0084\u00a2 license, these objects can represent signals and tunable parameters that appear as global variables in the generated code.Simulink.ValueType and Simulink.Bus objects that you use to define interfaces of model components, such as referenced models.\n\nUse the Model Explorer to view and edit MAT file data associated with the model. Alternatively, use the command prompt or scripts in conjunction with the external data source programmatic interface.\n\nFor more information on linking a MAT file to the model, see Link MAT File to Model as External Data Source."
            },
            {
                "heading": "Global and Shared Data: Data Dictionary",
                "content": "A data dictionary is a standalone file that permanently stores data. Similar to a header file, a data dictionary provides a location outside of the model that can store and share data definitions. Use data dictionaries instead of the base workspace to partition data, track changes, control access, and share data. If you link a model to a data dictionary, you can still use variables in the base workspace by configuring the base workspace access from either the model or the data dictionary. See Continue to Use Shared Data in the Base Workspace.\n\nUse a data dictionary to store data that multiple models or system components share. This data can include:\n\nNumeric variables that multiple models use to specify block parameter values.Simulink.AliasType and Simulink.NumericType objects that you use to specify data types in multiple models at the same time.Data objects, including signal objects (such as Simulink.Signal) that use a storage class other than Auto. If you have a Simulink Coder license, these objects can represent signals and tunable parameters that appear as global variables in the generated code.Simulink.ValueType and Simulink.Bus objects that you use to define interfaces of model components, such as referenced models.Simulink.ConfigSet objects that you use to maintain configuration parameter uniformity across multiple models.Enumerated type definitions, which you store using Simulink.data.dictionary.EnumTypeDefinition objects.\n\nTo use the data defined in a data dictionary, you must link the data dictionary to your model. You can use this association to share data between a specific set of models.\n\nWhen you use data dictionaries, you can partition the data by storing it in additional referenced dictionaries. Because data dictionaries in a hierarchy share the same namespace, each entry in a data dictionary hierarchy must use a unique name. Multiple definitions of the same symbol are allowed only if their class type and property values are the same. For more information, see Data Consistency in Model Hierarchy.\n\nYou can also use data dictionaries to associate data with a custom block library. When you define data objects, such as bus and enumeration types, in a data dictionary linked to a library, users of the library automatically gain access to the data types contained in the data dictionary when they drag a block from the library into their model. For more information, see Link Data Dictionary to Custom Libraries.\n\nUse the Model Explorer to edit dictionary data. Alternatively, use the command prompt or scripts in conjunction with the data dictionary programmatic interface.\n\nFor more information about data dictionaries, see What Is a Data Dictionary?"
            },
            {
                "heading": "Custom External File Sources",
                "content": "If you use a Simulink.SimulationInput object to simulate a model using different sets of variables, you can store these variable sets in custom external file sources. To load data from an external file:\n\nWrite, test, and register a file adapter for your custom file format (for example, .xlsx or XML). For more information, see Create External File Adapter for Loading Variables into Simulink.SimulationInput Object.Use your custom file adapter to load variables for simulation by using loadVariablesFromExternalSource."
            },
            {
                "heading": "Considerations for Code Generation",
                "content": "If you intend to generate C code from a model (Simulink Coder), take these considerations into account.\n\nIf you apply a storage class other than Auto to a signal object (such as Simulink.Signal) to control the appearance of a signal or block state in the generated code, you cannot store the object in a model workspace. Store the object in the base workspace, a MAT file, or a data dictionary. For more information about storage classes for signals and states, see C Data Code Interface Configuration for Model Interface Elements (Simulink Coder).If you apply a storage class other than Auto to a parameter object (such as Simulink.Parameter), you can store the object in the base workspace, a model workspace, a MAT file, or a data dictionary. However, if you store the object in a model workspace, the code generator assumes that the containing model owns the parameter. For more information, see Code Generation Impact of Storage Location for Parameter Objects (Simulink Coder).If you store an AUTOSAR.Parameter object in a model workspace, the code generator ignores the storage class that you specify for the object."
            },
            {
                "heading": "Managing Data Storage for Your Project",
                "content": "For small projects, the base workspace can be a convenient way to store design data. In particular, the base workspace works well for:\n\nInformal workflowsRapid prototypingQuick parameter tuningSingle-developer projects\n\nThe base workspace provides ease of access and global visibility. However, data storage in the base workspace is temporary and to preserve that data between sessions you must save it to a script or MAT file.\n\nOther options for small projects include:\n\nModel workspace \u00e2\u0080\u0094 Improves standalone model portability by providing permanent design data storage within the model.MATLAB file and data dictionary \u00e2\u0080\u0094 Provides permanent design data storage outside the model.\n\nYou can use the model workspace, link MAT file and data dictionary simultaneously to the model with the base workspace. Doing so provides a bridge for migrating your data from base workspace as your project grows in complexity.\n\nWhile the base workspace is convenient for small, single-user projects and rapid prototyping, this solution does not scale well for more complex projects that require encapsulation, distributed development, and scoped data. Complex projects involve a hierarchy of referenced models or subsystem references. Regardless of the type of models your hierarchy contains, you can distribute your design data based on the intended visibility of the data. In order to build scalable systems, distribute design data with the goal of keeping data visibility as local as possible.\n\nThe table shows the techniques you can use to store, partition, and manage design data and configuration sets.\n\nModeling ScenarioScenario DescriptionStorage Locations and TechniquesRapid prototyping and model experimentationYou want to create temporary data, such as variables to specify numeric block parameters, while you learn to use Simulink.You want to experiment with modeling techniques.You do not need to permanently store the data that you create.Store data in the base workspace so you can quickly create and change the data.Standalone modelYou have a single model that does not depend on other systems for data. The model stands alone because it is not a piece of a larger system.Store data in the model workspace to improve model portability. Use a data dictionary to store data that you cannot store in the model workspace.Alternatively, store data in a MAT file and link it as an external data source. Use a data dictionary to store data that you cannot store in the MAT file.A system decomposed into multiple modelsA large system is decomposed into multiple models in a hierarchy of referenced models, where data definitions are shared between parent and child models.Store local model data in each model workspace.Store system-wide definitions, such as common types, parameters, and constants, in a MAT file and link it as an external data source in all the models. Alternatively, use data dictionary that is referenced by all of the models (either directly or through another data dictionary).Store data that the models share, such as bus objects and configuration sets, in a data dictionary. Link all of the models in the hierarchy to the data dictionary.System of componentsReusable components, such as libraries or model references, which are designed for high reuse across teams or organizations.Store local model data in model workspaces.Parameterize the library block or model block by using mask parameters or model arguments.For each reusable component, store the data types required for the interfaces of that component in a separate data dictionary and associate the model or library to that data dictionary."
            },
            {
                "heading": "Data Consistency in Model Hierarchy",
                "content": "Data dictionaries in a model hierarchy can contain multiple definitions of the same symbol. For a model to update, duplicate symbol definitions visible to a single model (coming from the base workspace, connected Simulink data dictionaries, or visible library dictionaries) must be consistent. Symbol definitions are consistent when their symbol names, class types, and property values are the same.\n\nFor example, model M1 can see definitions of variable K in two storage locations. In this case, the definitions of K must be consistent.\n\nIf definitions for the same symbol are consistent, you can simulate the model in the normal, accelerator, and rapid accelerator modes, and generate code for the model. Duplicate symbols defined in the interface dictionary or in a data dictionary linked to an architecture model are not supported.\n\nNoteWhen a model can see multiple consistent definitions of a symbol, only one of the definitions is displayed by the Model Data Editor and returned by Simulink.findVars. It is this definition that is used by the model during simulation.\n\nAs long as duplicate symbols visible to a single model are consistent, the current model and the models below it in the model hierarchy can use symbols with the same name but different values by setting the model property EnforceDataConsistency to off. In the Model Properties dialog box, on the External Data tab, clear the Enforce consistent data definitions across referenced models check box. Alternatively, you can set the parameter to off programmatically by using the set_param function.\n\nset_param(bdroot,'EnforceDataConsistency','off');\n\nFor example, models M2 and M3 each have a single definition of variable K, but there are multiple definitions of K in the model hierarchy. By turning data consistency checking off in model M1, models M2 and M3 can maintain different values for variable K.\n\nYou might turn data consistency checking off to integrate components from different vendors that use similar names for variables. You might leave data consistency checking on to integrate components within an organization to ensure the components operate under the same conditions.\n\nBy default, the EnforceDataConsistency parameter is set to on. You cannot set EnforceDataConsistency to on for a model unless each of its referenced models and their variants also have EnforceDataConsistency set to on.\n\nSetting EnforceDataConsistency to off results in an error for:\n\nCode generationSoftware-in-the-loop (SIL) and processor-in-the-loop (PIL) simulationsSimulation of a protected model\n\nWhen creating a model reference simulation target (for accelerator and rapid acceleration modes during simulation), if there are multiple consistent definitions of a symbol, Simulink generates unique identifiers for the symbol by concatenating the data dictionary name with the symbol name. If this generated identifier exceeds the maximum allowed length of 64 characters, Simulink enforces data consistency regardless of the EnforceDataConsistency setting."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/determine-where-to-store-data-for-simulink-models.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/data_redefinition.png",
            "https://in.mathworks.com/help/simulink/ug/data_consistency.png"
        ]
    },
    {
        "title": "Create Partitions",
        "introduction": "Schedule Editor",
        "chunks": [
            {
                "heading": "Partitioning a Model",
                "content": "Partitions are components of a model that execute independently as atomic tasks. In multi-tasking models, partitions are created from model components. Periodic partitions are scheduled as a function of sample times in a model. In export-function models, the root function-call inputs are defined as partitions. These partitions have a schedule associated with them, which tells what order the partitions execute.\n\nWith partitions, you can separate parts of the model which you can explicitly control. You can think of periodic partitions as components that run at specific rates in a model. Aperiodic partitions are components that run at specified hit times or specified events. The schedule of these partitions have an impact on simulation and code generation.\n\nThe Schedule Editor enables you to partition the model and interact with those partitions. The Schedule Editor shows partitions, the connections between them, and the order of the partitions.\n\nThere are three types of partitions:\n\nTypes of PartitionsImageDescriptionImplicit Automatically created by Simulink\u00c2\u00ae. Blocks running at the base rate show up as an implicit partition.Periodic User-defined partitions from the atomic subsystems and/or Model blocks. Periodic partitions can also be defined by export-functions. These partitions execute based on their sample time and thus their execution is periodic.Aperiodic Aperiodic partitions are partitions which have no constraints and can be made to execute at any time. Specify the hit times in the Property Inspector of the Schedule Editor, at which you want to run the aperiodic partition. You can also use events in the Schedule Editor to schedule execution of the aperiodic partitions.\n\nThe blocks running at the base rate in the model is shown as an implicit partition in the Schedule Editor. The base rate is the fastest discrete rate in the model. D1 denotes the base rate. D1 annotation also appears in the Timing Legend. The D1 partition or implicit partition always remains the first discrete partition in the order.\n\nThe default partitions that are already present in the model are also implicit partitions.\n\nThe partition colors match their rate."
            },
            {
                "heading": "Create Partitions from a Rate-Based Model",
                "content": "Partitioning is enabled only on multitasking, fixed-step, and variable-step solver models. To choose multitasking execution mode, in Solver selection on the Solver pane, select the Type to be Fixed-step or Variable-step. Select the Treat each discrete rate as a separate task check box on the Solver pane of the Configuration Parameters dialog box. For more information on multitasking execution mode, see Time-Based Scheduling and Code Generation (Embedded Coder).\n\nAs a best practice, enable the Automatically handle rate transition for data transfer setting in the Solver pane. When you check Automatically handle rate transition for data transfer, Simulink inserts Rate Transition blocks between blocks when rate transitions are detected. Simulink handles rate transitions for asynchronous and periodic tasks. Simulink adds the hidden blocks configured to ensure data integrity and determinism for data transfers. When you check Treat each discrete rate as a separate task, Simulink selects multitasking execution for models operating at different rates. It also specifies that groups of blocks with the same execution priority are processed through each stage of simulation (for example, calculating output and updating states) based on task priority.\n\nTo see default partitions in the Schedule Editor, open the Schedule Editor. On the Modeling tab, click Schedule Editor. Update the diagram by clicking the icon on the toolstrip. The default partitions in the model are called implicit partitions. You can also create partitions in the model through an atomic subsystem or a model block."
            },
            {
                "heading": "Create Partitions Using Manage Partitions",
                "content": "In the Schedule Editor, use the Manage Partitions panel to create partitions. To open the Manage Partitions panel, click Manage Partitions, on the Schedule Editor toolstrip. The changes made in Manage Partitions are applied to the model to create partitions after updating the diagram. Manage Partitions shows the model hierarchy with the Subsystem blocks and Model blocks which can be explicitly partitioned.\n\nTo create partitions from Subsystem blocks, select the subsystems and click the . To create partitions from Model blocks, select the Model blocks and click . Enter partition names in the column Partition Name, and sample times in the column Sample Time. Repeat the steps for all the subsystems and Model blocks in the model that you want to partition. Update the diagram to see the created partitions in the Schedule Editor. The partitions appear in the graph with their deduced data dependencies and order.\n\nNoteCreating partitions using the Manage Partitions panel makes changes to the subsystem or model block parameters.\n\nThe following example shows how to configure a model for partitioning and create partitions by using Manage Partitions panel in the Schedule Editor.\n\nOpen the Model Fault-Tolerant Fuel Control System example model sldemo_fuelsys.openExample('simulink_automotive/ModelingAFaultTolerantFuelControlSystemExample') sldemo_fuelsys Open the Schedule Editor.Open the Schedule Editor On the Modeling tab, click Schedule Editor. To see the default partitions, click Update Diagram in the Schedule Editor. Two implicit partitions, created automatically by Simulink, are seen in the Schedule Editor.Create partitions.Open the Manage Partitions panel. In the panel, expand the fuel_rate_control subsystem. Select the airflow_calc subsystem and click . To change the default partition name and sample time, click the default name and sample time.To create a partition for the fuel_calc subsystem, select the fuel_calc subsystem and click .The Manage Partitions panel gives you the default partition names and sample times.Update the diagram to see the newly created partitions."
            },
            {
                "heading": "Create Partitions from Atomic Subsystem Blocks",
                "content": "You can partition an atomic subsystem. An atomic subsystem is treated by Simulink as a unit when determining the execution order of block methods(partitioning is enabled only on multitasking, fixed-step and variable-step solver models). To create partitions from an atomic subsystem block, go to the Block Parameters dialog box. Select Periodic partition from the Schedule as drop-down. Give the partition a name and a discrete sample time and click OK. This creates an explicit partition for this block. To see this partition in the Schedule Editor, update the diagram. The partition appears in the graph and in the Order with the connections based on the signals in the model."
            },
            {
                "heading": "Create Partitions from Model Blocks",
                "content": "To create partitions from a Model block, in the Model events simulation, select Schedule rates and Schedule Editor from the Schedule rates with drop-down. When you enable partitioning from a referenced model, partitions are created from all the Model blocks present in the referenced model. These partitions are scoped by the model block name. To see this partition in the Schedule Editor, update the diagram. The partitions appear in the graph and in the Order column with the connections based on the design of your model."
            },
            {
                "heading": "Export-Function Partitions",
                "content": "In export-function models, partitions are created from the function calls present in the model. To create partitions from the function calls in the export-function models, reference the export-function model in a top model. Schedule the Model block using the Schedule Editor through the block parameters. Partitions are then created from the function calls and their order is determined by the Schedule Editor.\n\nCreate an export-function model.Add a Model block that references the export-function model.Set the parameter to partition the export-function model.\n\nReferencing an export-function model from a Model block allows you to partition the function calls without changing the model itself. Simulink functions in an export-functions model cannot be scheduled, and do not appear as partitions in the Schedule Editor.\n\nAdd a Model block to a new Simulink model. In the Model name box, enter the name of an export-function model. For example, use the export-function model created in Create Export-Function Model.To enable the use of the Schedule Editor, configure the model to be multitasking. Open the Model Configuration Parameters. In Solver selection on the Solver pane, set the Type to Fixed-step. Check the Treat each discrete rate as a separate task and Automatically handle rate transition for data transfer parameters. Click OK. The model is enabled for partitioning.NoteDo not convert a subsystem into a model because it automatically creates Inport blocks.Add Outport blocks to the output_100ms and output_10ms ports for saving simulation data to MATLAB\u00c2\u00ae. For this example, in the export-function model, set the sample time of both the function calls to -1.Add a Sine Wave block to provide data input. Set Amplitude to 2 and Sample time to 0.01.To partition the function calls of the export-function model, in the Block Parameters dialog box for the Model block, select Schedule Editor option from the Schedule Rates with drop-down menu.Open the Schedule Editor and update the diagram to see the function calls as partitions."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/creating-partitions-from-your-model.html#mw_73f885bc-8ea7-48d0-9136-0e0607276236",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/se_implicit_ptn.png",
            "https://in.mathworks.com/help/simulink/ug/se_periodic_partition.png",
            "https://in.mathworks.com/help/simulink/ug/se_aperiodic_partition.png",
            "https://in.mathworks.com/help/simulink/ug/se_ud_icon.png",
            "https://in.mathworks.com/help/simulink/ug/manage_partitions_icon.jpg",
            "https://in.mathworks.com/help/simulink/ug/manage_partitions_create.png",
            "https://in.mathworks.com/help/simulink/ug/se_modelcreatepartition.png",
            "https://in.mathworks.com/help/simulink/ug/manage_partitions.png",
            "https://in.mathworks.com/help/simulink/ug/manage_partitions_create.png",
            "https://in.mathworks.com/help/simulink/ug/manage_partitions_create.png",
            "https://in.mathworks.com/help/simulink/ug/create_subsys.png",
            "https://in.mathworks.com/help/simulink/ug/create_model.png",
            "https://in.mathworks.com/help/simulink/ug/ep_top_mdl.png",
            "https://in.mathworks.com/help/simulink/ug/ep_partitioned.png"
        ]
    },
    {
        "title": "Troubleshoot MATLAB API Call Upgrade for R2020b",
        "introduction": "In R2020b, many objects and functions in the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 API changed. Check model for upgradable Simulink Real-Time features",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "MATLAB\u00c2\u00ae m-scripts written by using the Simulink Real-Time API require updates to run in R2020b and later releases."
            },
            {
                "heading": "Try This Workaround",
                "content": "These tables identify Simulink Real-Time API changes in R2020 and identify new workflows. Use these tables to guide your updates to pre-R2020b m-scripts. For information about Simulink Real-Time in previous releases, see:\n\nhttps://www.mathworks.com/help/doc-archives.html"
            },
            {
                "heading": "Target Computer Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow slrealtime.Application object, ApplicationName property slrealtime.target object, Application propertyGet name of real-time application.Changed nameUse Target object, Application property. slrealtime.target object, Connected property value is 'Yes'.Get communication status between development computer and target computers.Changed nameUse Target object, Connected event.Use connect function to make connection. close functionClose connection between development and target computers.Changed nameUse disconnect function to close connection. getDiskSpace functionGet free space and total space on the drive, in bytes.Moved to Speedgoat APISee the speedgoat.getDiskSpace function at www.speedgoat.com. load functionDownload real-time application to target computer.UnchangedUse load function after creating Target object. The real-time application is not automatically loaded as part of the build process. reboot functionRestart target computer.UnchangedUse reboot function to restart target computer in standalone mode. Other, previously supported boot modes are not available.saveparamsetSave a set of parameters to a real-time applicationChanged name. Changed workflow.Use saveParamSet to save the parameter set to a file.loadparamsetLoad a set of saved parameters to a real-time applicationChanged name. Changed workflow.Use importParamSet to Import the parameter set into a ParameterSet object on the development computer."
            },
            {
                "heading": "Real-Time Execution Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow slrealtime.target object, CPUoverload propertyGet CPU overload status.Changed nameUse Target object, TargetStatus property or ModelStatus property. slrealtime.target object, AvgTET propertyGet average task execution time.Changed nameUse Target object, ModelStatus.TETInfo property. slrealtime.target object, ExecTime propertyGet real-time application execution time.Changed nameUse Target object, ModelStatus.TETInfo property. slrealtime.target object, MaxTET propertyGet maximum task execution time.Changed nameUse Target object, ModelStatus.TETInfo property. slrealtime.target object, MinTET propertyGet minimum task execution time.Changed nameUse Target object, ModelStatus.TETInfo property. slrealtime.target object, SampleTime propertyGet time between samples (step size).Changed nameUse Target object, ModelStatus.TETInfo.Rate property. start functionStart execution of real-time application on target computer.Changed workflowUse start function to start real-time application and set real-time application options. slrealtime.target object, Status propertyGet execution status of real-time application.Changed workflowUse Target object, ModelStatus property or status function. stop functionStop execution of real-time application on target computer.UnchangedUse stop function. slrealtime.target object, StopTime propertyGet or set time when real-time application stops running.Changed workflowGet by using Target object, ModelStatus.StopTime property and set by using setStopTime function. slrealtime.target object, TETLog propertyAccess storage in the MATLAB workspace for task execution time.Changed workflowUse slrtTETMonitor function."
            },
            {
                "heading": "Execution Profiler Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow getProfilerData functionRetrieve profile data object.UnchangedUse getProfilerData function. Start the execution profiler before you start the real-time application. slrealtime.target object, ProfilerStatus propertyGet state of profiler.Changed workflowUse Target object, Application property. There are added property values. resetProfiler functionReset profiling service state to Ready.UnchangedUse resetProfiler function. The profiler resets itself when you start the real-time application. startProfiler functionStart profiling service on target computer.UnchangedUse startProfiler function. Start the execution profiler before you start the real-time application. stopProfiler functionStop profiling service on target computer.Changed limitationUse stopProfiler function. The profiler auto stop at 1GB is eliminated."
            },
            {
                "heading": "Parameter Tuning Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow setparam functionChange value of tunable parameter in real-time application.Changed syntaxUse setparam function. getparam functionRead value of observable parameter in real-time application.Changed syntaxUse getparam function. slrealtime.target object, NumParameters propertyGet number of tunable parameters.Changed workflowUse Application object and getParameters function. slrealtime.target object, Parameters propertyGet list of tunable parameters.Changed workflowUse Application object and getParameters function. slrealtime.target object, ShowParameters propertySet flag to display the list of parameters.Changed workflowUse Application object and getParameters function."
            },
            {
                "heading": "Signal Tracing Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow getsignal functionGet single numerical value of a signal.Changed workflowUse Instrument object and connectScalar function. slrealtime.target object, NumSignals propertyGet number of observable signals.Changed workflowUse Application object and getSignals function. slrealtime.target object, OutputLog propertyAccess storage in MATLAB workspace for output or Y-vector.Changed workflowUse Simulink model Signal logging parameter: set_param(bdroot,... 'SignalLogging','on') slrealtime.target object, ShowSignals propertySet flag to display the list of signals.Changed workflowUse Application object and getSignals function. slrealtime.target object, Signals propertyGet list of observable signals.Changed workflowUse Application object and getSignals function."
            },
            {
                "heading": "Signal Logging Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow importLogData functionImport buffered logging data to the active session of the Simulation Data Inspector.ReplacedUse list function and import function. For more information, see the Target.FileLog object."
            },
            {
                "heading": "Instrumentation Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow addscope functionCreate a scope of specified type.ReplacedUse the Simulation Data Inspector. Use File Log blocks instead File Scope blocks. Use Instrument objects instead of Host Scope blocks. getscope functionReturn scope identified by scope number.ReplacedUse the Simulation Data Inspector. Use File Log blocks instead File Scope blocks. Use Instrumentobjects instead of Host Scope blocks."
            },
            {
                "heading": "Ethernet and EtherCAT Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew WorkflowTarget Computer Settings provided information about Ethernet setup on target computer.Configure Ethernet ports on target computerMoved to Speedgoat APISee the speedgoat.configureEthernet function at www.speedgoat.com. slrealtime.etherCAT.filterNotifications functionDisplay EtherCAT notifications in human-readable formatChanged nameUse slrealtime.EtherCAT.filterNotifications function"
            },
            {
                "heading": "Target Computer Settings Operations",
                "content": "R2020a and Previous CommandCommand DescriptionR2020b and Later Command StatusNew Workflow slrealtime.getTargetSettings functionGet target computer settings.Changed nameUse getTargetSettings function."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-matlab-api-call-upgrade-for-r2020b.html",
        "images": []
    },
    {
        "title": "Install Simulink Real-Time Software Updates",
        "introduction": "The general procedure for updating Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 is: After updating Simulink Real-Time, to re-create your Simulink Real-Time target settings:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/installing-simulink-real-time-software-updates.html",
        "images": []
    },
    {
        "title": "Perform Acceleration",
        "introduction": "",
        "chunks": [
            {
                "heading": "Customize the Build Process",
                "content": "Compiler optimizations are off by default. This results in faster build times, but slower simulation times. You can optimize the build process toward a faster simulation.\n\nOn the Modeling tab, under Setup, click Model Settings.In the Configuration Parameters dialog box, from the Compiler optimization level drop-down list, select Optimizations on (faster runs).Code generation takes longer with this option, but the simulation runs faster.Select Verbose accelerator builds to display progress information using code generation, and to see the compiler options in use."
            },
            {
                "heading": "Changing the Location of Generated Code",
                "content": "By default, accelerator mode places the generated code in a subfolder of the working folder called slprj/accel/modelname (for example, slprj/accel/f14). To change the name of the folder into which accelerator mode writes generated code:\n\nIn the Simulink\u00c2\u00ae Editor window, on the Modeling tab, select Environment > Simulink Preferences.In the Simulink Preferences window, navigate to the Simulation cache folder parameter.Enter the absolute or relative path to your subfolder and click Apply."
            },
            {
                "heading": "Run Acceleration Mode from the User Interface",
                "content": "To accelerate a model, first open it, and then on the Simulation tab, in the Simulate section, select Accelerator or Rapid Accelerator from the drop-down list. Then start the simulation.\n\nThe following example shows how to accelerate the already opened f14 model using accelerator mode:\n\nOn the Simulation tab, in the Simulate section, select Accelerator from the drop-down list.On the Simulation tab, click Run.The accelerator and rapid accelerator modes first check to see if code was previously compiled for your model. If code was created previously, accelerator or rapid accelerator mode runs the model. If code was not previously built, they first generate and compile the C code, and then run the model.For an explanation of why these modes rebuild your model, see Code Regeneration in Accelerated Models.\n\nAccelerator mode places the generated code in a subfolder of the working folder called slprj/accel/modelname (for example, slprj/accel/f14). If you want to change this path, see Changing the Location of Generated Code.\n\nRapid accelerator mode places the generated code in a subfolder of the working folder called slprj/raccel/modelname (for example, slprj/raccel/f14).\n\nNoteThe warnings that blocks generate during simulation (such as divide-by-zero and integer overflow) are not displayed when your model runs in accelerator or rapid accelerator mode."
            },
            {
                "heading": "Making Run-Time Changes",
                "content": "A feature of the accelerator and rapid accelerator modes is that simple adjustments (such as changing the value of a Gain or Constant block) can be made to the model while the simulation is still running. More complex changes (for example, changing from a sin to tan function) are not allowed during run time.\n\nThe Simulink software issues a warning if you attempt to make a change that is not permitted. The absence of a warning indicates that the change was accepted. The warning does not stop the current simulation, and the simulation continues with the previous values. If you wish to alter the model in ways that are not permitted during run time, you must first stop the simulation, make the change, and then restart the simulation.\n\nIn general, simple model changes are more likely to result in code regeneration when in rapid accelerator mode than when in accelerator mode."
            },
            {
                "heading": "Switching Solvers Between Runs",
                "content": "You can switch variable-step solvers between runs and Simulink will automatically determine if a solver change will trigger a rebuild, based on the mathematical structure of the model, such as whether the model is an ordinary differential equation (ODE) or a differential algebraic equation (DAE) model, if the solver needs a Jacobian, whether it handles mass matrices, or if the model contains rate limiter blocks."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/performing-acceleration.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/run_accel.png"
        ]
    },
    {
        "title": "Manage Build Process Folders",
        "introduction": "The build process places generated files from Simulink\u00c2\u00ae diagram updates and model builds into a hierarchy of folders that is specified by default. You can change the default specification for build process folders, if, for example: The MATLAB\u00c2\u00ae session parameters CacheFolder, CodeGenFolder, and CodeGenFolderStructure are file generation control parameters that specify the folder locations for the build process. At the start of a MATLAB session, these Simulink preferences determine the values of the parameters: Simulation cache folder \u00e2\u0080\u0093 CacheFolder Code generation folder \u00e2\u0080\u0093 CodeGenFolder Code generation folder structure \u00e2\u0080\u0093 CodeGenFolderStructure To modify the parameters during a MATLAB session, use Simulink.fileGenControl. The parameter values that you set expire at the end of the MATLAB session. RTW.getBuildDir | Simulink.fileGenControl",
        "chunks": [
            {
                "heading": "File Generation Control Parameters",
                "content": "This table provides information about how you can use the parameters to manage build process folders.\n\nMATLAB Session ParameterSimulink PreferenceDescription CacheFolder Simulation cache folderThe build process places generated files from Simulink diagram updates and model build artifacts for simulation and code generation in the simulation cache folder simulationCacheFolder. The folder is a root folder.By default (CacheFolder = ''), simulationCacheFolder is the current working folder, pwd.You can use the parameter to specify another folder. For example, if you want to: Separate generated files from the models and other source material.Reuse or share previously built simulation targets without having to set the current working folder back to a previous working folder. CodeGenFolder Code generation folder The build process, which uses system target files to generate production code from a Simulink model, places the production code in the code generation folder codeGenerationFolder. The folder is a root folder. If you choose to generate an executable program file, the build process writes the file model.exe (Windows\u00c2\u00ae) or model (UNIX\u00c2\u00ae) to the folder. By default (CodeGenFolder = ''), codeGenerationFolder is the current working folder, pwd. You can use the parameter to specify another folder. For example, if you want to separate generated production code from: Models and other source material.Generated simulation and code generation artifacts. If you specify the root folder of a drive as the code generation folder, the build process cannot generate code for your model. For example, C:\\. CodeGenFolderStructure Code generation folder structureTo specify the folder structure within the code generation folder, use the parameter. For example, if you configure models for different target environments, you can specify a separate subfolder for the generated code from each model."
            },
            {
                "heading": "Build Process Folders",
                "content": "This table provides information about how CodeGenFolderStructure controls the folder structure within the simulation cache folder and the code generation folder.\n\nFolder Name when CodeGenFolderStructure = 'ModelSpecific'Folder Name when CodeGenFolderStructure = 'TargetEnvironmentSubfolder'DescriptioncodeGenerationFolder/model_target_rtwThe default for target is the name of the selected system target file, for example, grt, ert, and rsim. You can change target with the rtwgensettings.BuildDirSuffix field in the system target file.codeGenerationFolder/targetSpecific/modelThe build process uses configuration information for the system target file and the hardware device to produce a unique label for the subfolder, targetSpecific.Build folder, which stores generated source code and other files created by the build process.Contains the generated code modules, model.c and model.h, and generated makefile, model.mk.model.mk is for compiling and linking code generated from model components.model is the name of the source model.codeGenerationFolder/model_target_rtw/servicescodeGenerationFolder/targetSpecific/model/servicesFolder created when you generate code for a component model that uses a service code interface configuration. Contains services.h, the header file that specifies function prototypes for target platform services.For more information, see Generate and Verify Code and Identify and Package Files for Deployment.codeGenerationFolder/model_target_rtw/services/libcodeGenerationFolder/targetSpecific/model/services/libContains buildInfo.mat, which you use for building the component model library that represents the generated code compiled against services.h.For more information, see Generate and Verify Code and Identify and Package Files for Deployment.codeGenerationFolder/model_target_rtw/html codeGenerationFolder/targetSpecific/model/htmlCode generation report folder that contains report files generated by the build process.codeGenerationFolder/slprj/target/model codeGenerationFolder/targetSpecific/_ref/modelModel reference target files.codeGenerationFolder/slprj/target/model/referenced_model_includescodeGenerationFolder/targetSpecific/_ref/model/referenced_model_includesHeader files from models referenced by model.codeGenerationFolder/slprj/target/model/tmwinternal codeGenerationFolder/targetSpecific/_ref/model/tmwinternalMAT-files used during code generation.codeGenerationFolder/slprj/target/_sharedutilscodeGenerationFolder/targetSpecific/_sharedUtility functions for model reference system target files, which are shared across models.Folder also contains rtwshared.mk for compiling generated shared utility codesimulationCacheFolder/slprj/sim/modelsimulationCacheFolder/slprj/sim/modelSimulation target files for referenced models.simulationCacheFolder/slprj/sim/model/tmwinternal simulationCacheFolder/slprj/sim/model/tmwinternalMAT-files used during code generation.simulationCacheFolder/slprj/sim/_sharedutilssimulationCacheFolder/slprj/sim/_sharedutilsUtility functions for simulation system target files, which are shared across models.\n\nIf the system target file is ERT-based, then these model configuration parameters also control the location of shared utility code:\n\nShared code placement (UtilityFuncGeneration)Existing shared code (ExistingSharedCode)\n\nYou can use RTW.getBuildDir to display build folder information for the model."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/build-process-folders.html",
        "images": []
    },
    {
        "title": "Generate ASAP2 and CDF Calibration Files",
        "introduction": "Generate and customize an ASAP2 file and a CDF (Calibration Data Format) file for a model by using the Generate Calibration Files tool. By default, the tool generates the latest supported version of the A2L file according to ASAM MCD-2 MC standards. You can choose to generate a different version. You can customize the options for calibration files, such as the version for the A2L file and the schema type, for the CDF file. For more information on the ASAM MCD-2 MC (ASAP2) standard and the ASAM CDF Standards, see the ASAM website at www.asam.net. coder.cdf.export | coder.asap2.export | Generate Calibration Files",
        "chunks": [
            {
                "heading": "Open Generate Calibration Files Tool",
                "content": "Open the model.Open the Simulink Coder app.NoteFor AUTOSAR models, open the AUTOSAR Component Designer app. And for Simulink Real-Time models, open the Simulink Coder app.Generate code for the model.On the C Code tab, select Share > Generate Calibration Files.\n\nNoteFor AUTOSAR models, select Autosar > Share > Generate Calibration Files.\n\nUsing the tool, you can generate A2L and cdfx files at the same time for a model. You can use the tool for models configured with an ERT-based, GRT-based, Simulink Real-Time, AUTOSAR Classic, or AUTOSAR Adaptive system target file. The tool remembers the last used settings, such as the version of the ASAP2 file, include or exclude comments, turn off or on the ASAP2 file and CDF file generation. Simulink saves these settings in the MATLAB preferences. The settings will override the default settings.\n\nFor AUTOSAR classic models, the tool allows you to include or exclude RTE elements into the ASAP2 file by using the Include AUTOSAR RTE elements option. The RTE elements in the generated ASAP2 file will use RTE API service call names."
            },
            {
                "heading": "ASAP2 File Generation",
                "content": "ASAP2 defines the description format of the internal ECU variables used for tuning parameters and measuring signal data as an application executes. To generate an ASAP2 file:\n\nBy default the Generate ASAP2 option is enabled. If it is not enabled, slide the Generate ASAP2 switch to the On position to enable A2L generation.To change the name of the A2L file, in the File name field, specify the name.By default, the code generator uses the build folder for the folder path of the selected model. If you want to specify a different folder path for the A2L file, you can do that in the Folder path field.To replace ECU addresses in the A2L file, in the Symbol file field, provide a symbol file associated with the application executable. Otherwise, clear the Address replacement field.The tool supports an ELF, PDB, or DWARF file as a symbol file to replace the ECU addresses. Set Version to the required version of the A2L file to be generated. The default version is 1.71.To exclude comments in the A2L file, clear Include comments.For AUTOSAR classic models, to exclude RTE elements in the A2L file, clear Include AUTOSAR RTE elements.To exclude generation of separate files for CompuMethods and record layouts, clear Include shared elements.To exclude referenced model data elements in the A2L file, clear Include referenced models.Click Generate.\n\nTo generate the A2L file programmatically, use the coder.asap2.export function."
            },
            {
                "heading": "CDF File Generation",
                "content": "ASAM CDF defines the data description format for storing the ECU parameter values and the associated meta data. The ASAM CDF files use XML, which can be easily validated, edited, imported, and exported by calibration tools and XML editors. To generate a CDF file by using the tool:\n\nSlide the Generate CDF switch to the On position.To change the name of the CDF file, specify it in the File name field.By default, the code generator selects the build folder for the folder path of the selected model. If you want to specify a different folder path for the CDF file, in the Folder path field, specify the path.Use the Schema type field to set to XSD (XML Schema Definition) or DTD (Document Type Definition). The DTD schema type is the default.\n\nTo generate the CDF file programmatically, use coder.cdf.export function.\n\nNoteCDF file generation is disabled for Simulink Real-Time system target file."
            },
            {
                "heading": "Generate ASAP2 and CDF Data Definition Files",
                "content": "Open Live Script\n\nThis example shows how to export ASAP2 and Calibration Data Format (CDF) files for data measurement and calibration using the Generate Calibration Files tool.\n\nASAP2 standard defines the description format of the internal electronic control unit (ECU) variables used in measurement and calibration and ASAM CDF standard defines the data for storing the ECU parameter values and the associated meta data. These standards are proposed by the Association for Standardization of Automation and Measuring Systems (ASAM). For more information about ASAM MCD-2 MC and ASAM CDF standards, refer to www.asam.net.\n\nThis example uses ASAP2Demo.slx and ASAP2DemoModelRef.slx models.\n\nBuild ASAP2Demo ModelOpen the ASAP2Demo model. open_system(\"ASAP2Demo\");Build the model to generate C Code for both the parent model ASAP2Demo and the child model ASAP2DemoModelRef.slbuild(\"ASAP2Demo\");Open \"Generate Calibration Files\" ToolOn the C code tab, select Share > Generate Calibration Files to open the Generate Calibration Files tool.You can customize the calibration file generation settings such as filename, the destination folder, include or exclude comments in the file.Generate ASAP2 FileFollow these steps to generate the ASAP2 file for the model.Move the Generate ASAP2 switch to On position. By default, the Generate ASAP2 switch is in the On position.Specify a name in the File name field to change the name of the file from ASAP2Demo.Specify the path for the A2L file in the Folder path field. By default, the A2L file is generated in the build directory.Provide a symbol file associated with the application executable in the Symbol file field, to replace ECU addresses in the A2L file. Otherwise, uncheck the Address replacement field. The tool supports an ELF, PDB, DWARF file as a symbol file to replace the ECU addresses.Set Version option to the required version of the A2L file to be generated. The default version is 1.71. Uncheck Include comments option to exclude comments in the A2L file.Uncheck Include referenced models option to exclude referenced model data elements in the A2L file.Click Generate.To generate the A2L file programmatically, use this command.coder.asap2.export(\"ASAP2Demo\");Generate CDF FileFollow these steps to generate the CDF file for the model.Move the Generate CDF switch to the On position. By default, the Generate CDF switch is in the On position.Specify a name in the File name field to change the name of the file from ASAP2Demo.Specify the folder path for the CDF file in the Folder path field. By default, the CDF File is generated in the build directory.Choose the Schema type field as XML Schema Definition (XSD) or Document Type Definition (DTD). By default it is set to DTD schema type.Click Generate.To generate the CDF file programmatically, use this command.coder.cdf.export(\"ASAP2Demo\");You can verify that the calibration files are generated in the specified folder. Now, you can use these calibration files for calibration and measurement of the application."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/asap2-cdf-calibration.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/asap2cdf_generator.png",
            "https://in.mathworks.com/help/rtw/ug/asap2cdf_generator_classicatsr.png",
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/CreateAHostBasedASAMASAP2DataDefinitionFileExample_01.png",
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/CreateAHostBasedASAMASAP2DataDefinitionFileExample_02.png"
        ]
    },
    {
        "title": "Message Communication Interfaces",
        "introduction": "Within a platform environment, code generated from a Simulink\u00c2\u00ae model can communicate with platform software or with other code generated from Simulink models by using message-based communication. Generate C++ component code for message-based communication with platform software. Generate C++ or C component code for message-based communication with other models. Send | Receive | Queue",
        "chunks": [
            {
                "heading": "Generate C++ Messages to Communicate Data Between Simulink and an Operating System or Middleware",
                "content": "To generate C++ code that supports message communication between Simulink top models and external applications, use the Simulink Messages & Events Library Send and Receive blocks. Generating code from a top model to facilitate messages passed outside of the Simulink environment enables your modeled application to communicate in a distributed system that uses an external message protocol service, commonly referred to as an operating system or middleware (for example, DDS, ROS, SOMEIP, or POSIX messages).\n\nSimulink top models pass messages by:\n\nTop models contain message blocks to communicate outside the Simulink environment. If a top model contains a Send block directly connected to a root Outport block, the block converts its signals into messages and passes them outside the Simulink environment. If a top model contains a Receive block directly connected to a root Inport block, the block converts the received messages into signals.The external message protocol manages the message communication according to its own standard, that is, policies that control capacity, order of delivery, and other quality of service (QoS) behavior.\n\nTo generate C++ messages to communicate between Simulink top models and an operating system or middleware, prepare your model, generate code, and integrate that code with your selected operating system or middleware."
            },
            {
                "heading": "Prepare Model",
                "content": "To set up your model so that it can pass messages with an operating system or middleware, configure the model as a top model that has at least one message block, either a Send block connected to a root Outport block or a Receive block connected to a root Inport block. The top model can then connect to your selected operating system or middleware through the message blocks:\n\nWithin a model, the message ports are connected as shown:"
            },
            {
                "heading": "Generate Code",
                "content": "To generate C++ code from a model:\n\nIn the Apps gallery, click Embedded Coder.In the Configuration Parameters dialog box, set these parameters: In the Code Generation pane, set the Language to C++.In the Interface pane, set Code interface packaging to C++ class.In the Templates pane, select Generate an example main program. Generate code. On the C++ Code tab, click Build.View the generated code. On the C++ Code tab, click View Code."
            },
            {
                "heading": "Integrate Code",
                "content": "To integrate the generated C++ code from your model with your selected operating system or middleware use handwritten code to implement send and receive message classes and application code that uses those classes to pass messages. Specifically:\n\nIf you use your own main, create concrete subclasses from the generated abstract classes shown in RecvData_<T>.h and SendData<T>.h. If you use the generated example main program, concrete subclasses are provided in the file.Implement the class functions SendData and RecvData to call into your selected operating system or middleware to send and receive messages.Create an instance of your implemented send and receive message classes (send and receive objects).Create an instance of the model class by using the instances of each message class (send and receive objects) as arguments in the model constructor.Send and receive messages as required by your application. Manage the lifetime of the message queues.The queues must be in a state ready to accept messages prior to the first step of the model.\n\nTo integrate the generated code with a platform main program:\n\nOpen the generated example main program or create your own. If you use the generated example main program, the concrete subclasses RecvData_real_T and SendData_real_T are in the file. If you create your own main, create concrete subclasses in your application code:To receive messages, manually write the implementation of the generated receive class. Implement the class function RecvData to call into your selected operating system or middleware to receive messages.An example implementation for POSIX is:class mHMIHandlerRecvData_real_T: public RecvData_real_T { public: void RecvData(real_T* data, int32_T length, int32_T* status) { // Use POSIX API mq_receive to receive messages unsigned int priority = 1; *status = mq_receive(msgQueue, (char *)data, length, &priority); } }; Create a receive object.static mHMIHandlerRecvData_real_T InMsgRecvData_arg; To send messages, manually write the implementation of the generated send class. Implement the class function SendData to call into your selected operating system or middleware to send messages.An example implementation for POSIX is: class mHMIHandlerSendData_real_T : public SendData_real_T { public: void SendData(const real_T* data, int32_T length, int32_T* status) { // Use the POSIX API mq_send to send messages unsigned int priority = 1; *status = mq_send(msgQueue, (char*)data, length, priority); } }; Create a send object.static mHMIHandlerSendData_real_T OutMesgSendData_arg; Create an instance of the model class by using your send and receive objects as arguments in the model constructor.static mHMIHandler mHMI_Obj(InMsgRecvData_arg, OutMsgSendData_arg); Send and receive messages as required by your application and maintain the lifetime of the message queue.An example implementation for POSIX is:int_T main(int_T argc, const char *argv[]) { // Unused arguments (void)(argc); (void)(argv); //Initialize model mHMI_obj.initialize(); // Open POSIX queue mqd_t msgQueue = mq_open(\"/PosixMQ_Example\", O_RDONLY); if (msgQueue == -1) { printf(\"mq_open failed\\n\"); exit(1); } // Send and Receive messages while (rtmGetErrorStatus(mHMI_Obj.getRTM()) == (NULL)) { //perform application tasks here. rt_OneStep(); } // Close POSIX queue mq_close(msgQueue); // Terminate model mHMI_Obj.terminat(): return 0; }\n\nFor a more complex POSIX integration example, see Model Message-Based Communication Integrated with POSIX Message Queues"
            },
            {
                "heading": "Considerations and Limitations",
                "content": "Handwritten code is the only supported integration technique.You must select the model configuration parameter Generate an example main program. Applications that require a static main are not supported.You cannot configure function prototype control (FPC) for a top model that has root message ports."
            },
            {
                "heading": "Generate C++ Messages to Communicate Data Between Simulink Components",
                "content": "To generate C++ code that supports message-based communication between model components in the Simulink environment, use the Simulink Messages & Events Library blocks Send and Receive. To customize the communication, use the Queue block (from the same library) to set parameters for capacity, sorting policy (LIFO, FIFO, and priority), and overwriting policy (behavior when the queue exceeds capacity). You can generate C++ code for GRT-based system target files by using Simulink Coder or for ERT-based system target files by using Embedded Coder.\n\nMessages are an effective communication technique for distributed and complex systems that you can model within Simulink."
            },
            {
                "heading": "How to Prepare Models in Simulink for Message-Based Communication",
                "content": "In Simulink, model message-based communication between model components:\n\nCreate a model that contains a Send block (referenced model).Create a model that contains a Receive block (referenced model).Create a model that has two Model blocks (top model).Set the first Model block to the model that contains the Send block (model from step 1).Set the second Model block to the model that contains the Receive block (model from step 2).When you run the model, a queue generates in the top model above the message line. A queue, explicit or implicit, controls the message communication. You can use the generated queue or you can add a Queue block in the top model to explicitly specify communication parameters."
            },
            {
                "heading": "How Model Components Pass Messages and How the Code Implements the Behavior",
                "content": "Referenced models pass messages:\n\nIn the model that contains the Send block, the Send block converts signals into messages. The top model that contains the queue manages messages according to parameters that define capacity, order of delivery, and other quality of service (QoS) metrics.In the model that contains the Receive block, the Receive block converts messages back to signals.\n\nIn the generated C++ code, the top model facilitates the connection between the send and receive referenced models by establishing a set interface that the referenced models can access independently of one another.\n\nThe generated C++ code implements message behavior:\n\nA service is created at each model boundary. A service contains a reference to the top model and an entry point function, referred to as a service function, for referenced models to use to pass messages to the top model.The top model initializes each service to create a connection to each referenced model.The referenced models invoke service functions to pass messages to the top model."
            },
            {
                "heading": "C++ Code Generation Example",
                "content": "This example generates and examines C++ code from the model provided in Establish Message Send and Receive Interfaces Between Software Components.\n\nGenerate C++ Code:\n\nOpen the model.In the Apps gallery, click Embedded Coder.For each model (top and both referenced models), in the Configuration Parameters dialog box, set these parameters:In the Code Generation pane, set Language to C++.In the Interface pane, set Code interface packaging to C++ class.Save the model.Generate code. On the C++ Code tab, click Build.View the generated code. On the C++ Code tab, click View Code.\n\nExamine C++ Code:\n\nA service is created at each model boundary. In C++, services are represented as objects that hold an instance of the top model and a service function that referenced models invoke to pass messages.To view the creation of the services, open the top model C++ file MessageSendReceiveDefaultBufferModel.cpp. View the constructor method.The constructor methods, ReceiveComponentRecvData(*this) and SendComponentSendData(*this), create the receive and send service objects respectively by taking as an argument a reference to the instance of the top model. Each service object saves a reference to the top model and defines the message interface (the service functions RecvData and SendData). To view the receive and send service classes, open the top model header file MessageSendReceiveDefaultBufferModel.h, and view the following section.The top model initializes each service to create a connection to each referenced model. To view the initialization, open the top model C++ file MessageSendReceiveDefaultBufferModel.cpp. View the constructor method.The constructor method Receive_ComponentMDLOBJ0(get_ReceiveComponentRecvData()), passes a reference to the receive service to the receive referenced model. The constructor method, Send_ComponentMDLOBJ1(get_SendComponentSendData()), passes a reference to the send service to the send referenced model.The referenced models invoke service functions to pass messages to the top model. In C++, referenced models invoke the top model (common ancestor, if in a hierarchy) service functions to send or receive messages (specifically, a referenced model invokes the abstract service method (RecvData or SendData) from the interface created in step 2).The abstract interface classes are emitted to a shared folder. The implementation of the service functions in each service is defined in the top model C++ file.To view the abstract interface class to send messages, open from the shared folder the header file SendData_real_T.h.To view the implementation of the service function to send messages, open the top model C++ file MessageSendReceiveDefaultBufferModel.cpp.To view how the send referenced model invokes the service function, open its C++ file mSend.cpp. In the step function, the model invokes the service function to send messages to the top model and receives back a return status.To view the abstract interface class to receive messages, open from the shared folder the header file RecvData_real_T.h.To view the implementation of the service function to receive messages, open top model C++ file MessageSendReceiveDefaultBufferModel.cpp.To view how the receive referenced model invokes the service function, open its C++ file mRecieve.cpp. In the step function, the model invokes the service function to receive messages and a status from the top model."
            },
            {
                "heading": "Considerations and Limitations",
                "content": "C++ code support is available for GRT-based system target files by using the Simulink Coder app.C++ code support is available for ERT-based system target files by using the Embedded Coder app.To generate code, for top and referenced models, select the same language (C++) and the same system target file.You cannot configure function prototype control (FPC) for a top model that has root message ports.External models and variant models are not supported.Software-in-the-loop (SIL) and processor-in-the-loop (PIL) simulations are not supported."
            },
            {
                "heading": "Generate C Messages to Communicate Data Between Simulink Components",
                "content": "To generate C code that supports message-based communication between model components in the Simulink environment, use the Simulink Messages & Events Library blocks Send and Receive. To customize the communication, use the Queue block (from the same library) to set parameters for capacity, sorting policy (LIFO, FIFO, and priority), and overwriting policy (behavior when the queue exceeds capacity). You can generate C code for GRT-based system target files by using Simulink Coder or for ERT-based system target files by using Embedded Coder.\n\nMessages are an effective communication technique for distributed and complex systems that you can model within Simulink."
            },
            {
                "heading": "How to Prepare Models in Simulink for Message-Based Communication",
                "content": "In Simulink, you can model message-based communication between model components:\n\nCreate a model that contains a Send block (referenced model).Create a model that contains a Receive block (referenced model).Create a model that has two Model blocks (top model).Set the first Model block to the model that contains the Send block (model from step 1).Set the second Model block to the model that contains the Receive block (model from step 2).When you run the model, a queue generates in the top model above the message line. A queue, explicit or implicit, controls the message communication. You can use the generated queue or you can add a Queue block in the top model to explicitly specify communication parameters."
            },
            {
                "heading": "How Model Components Pass Messages and How the Code Implements the Behavior",
                "content": "Referenced models pass messages:\n\nIn the model that contains the Send block, the Send block converts signals into messages. The top model that contains the queue manages messages according to parameters that define capacity, order of delivery, and other quality of service (QoS) metrics.In the model that contains the Receive block, the Receive block converts messages back to signals.\n\nIn the generated C code, the top model facilitates the connection between the send and receive referenced models by establishing a set interface that the referenced models can access independently of one another.\n\nThe generated C code implements message behavior:\n\nA service is created at each model boundary. A service contains a reference to the top model and an entry point function, referred to as a service function, for referenced models to use to pass messages to the top model.The top model initializes each service to create a connection to each referenced model.The referenced models invoke service functions to pass messages to the top model."
            },
            {
                "heading": "C Code Generation Example",
                "content": "This example generates and examines C code from the model provided in Establish Message Send and Receive Interfaces Between Software Components.\n\nGenerate C Code:\n\nOpen the model.In the Apps gallery, click Embedded Coder.For each model (top and both referenced models), in the Configuration Parameters dialog box, in the Code Generation pane, set Language to C and save the model.Generate code. On the C Code tab, click Build.View the generated code. On the C Code tab, click View Code.\n\nExamine C Code:\n\nA service is created at each model boundary. In C, referenced models represent services as DWork. The service provides a pointer to an instance of the top model and a service function that referenced models invoke to pass messages.To view the service to send messages, open the send referenced model header file mSend.h. View the DWork allocation. To view the send message data type, if the data type is shareable (for example, built-in data types, imported bus types, or exported bus types that have a specified data type) the information is located in a shared header file. If the data type is not shareable, the information is located the model header file mSend.h. For this example, view the shareable data type by opening the shared header file SendData_real_T.h.To view the service to receive messages, open the receive referenced model header file, mReceive.h. View the DWork allocation. To view the received messages data type, if the data type is shareable (for example,built-in data types, imported bus types, or exported bus types that have a specified data type) the information is located in a shared header file. If the data type is not shareable the information is located the model header file, mReceive.h. For this example, view the shareable data type by opening the shared header file RecvData_real_T.h.The top model initializes each service to create a connection to each referenced model. In C, the top model initializes each referenced model DWork. To view the initialization, open the top model C file MessageSendReceiveDefaultBufferModel.c.The referenced models invoke service functions to pass messages to the top model. In C, a referenced model invokes a service function by dereferencing the service function pointer and passing a pointer to the instance of the top model. You can view the prototypes of the service functions in the top model header file. You can view the referenced model invocations of those service functions in the referenced model C files.To view the prototype of the service function to send messages, open the top model header file, MessageSendReceiveDefaultBufferModel.h.To view the implementation of the service function to send messages, open the top model C file, MessageSendReceiveDefaultBufferModel.c.To view how the send referenced model invokes the service function, open the C file for the model mSend.c. In the step function, the model invokes the service to send instance data and a message to the top model and receives back a return status.To view the prototype of the service function to receive messages, open the top model header file MessageSendReceiveDefaultBufferModel.h.To view the implementation of the service function to receive messages, open the top model C file MessageSendReceiveDefaultBufferModel.c.To view how the receive referenced model invokes the service function, open the C file for the model mReceive.c. In the step function, the model invokes the service to receive a message payload and a return status."
            },
            {
                "heading": "Considerations and Limitations",
                "content": "C code support is available for GRT-based system target files by using the Simulink Coder app.C code support is available for ERT-based system target files by using the Embedded Coder app.To generate code, for top and referenced models, select the same language (C) and the same system target file.You cannot configure function prototype control (FPC) for a top model that has root message ports.External models and variant models are not supported.Software-in-the-loop (SIL) and processor-in-the-loop (PIL) simulations are not supported.C code generation is not supported for models that connect a message port of a Simulink block or a Stateflow chart to a top model root-level Inport or Outport block. For those modeling patterns, only C++ code generation is supported."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/message-communication.html#mw_b3d60f69-2274-4ed5-81df-b0842cd23062",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/msgs_cpp_top_model_p1.png",
            "https://in.mathworks.com/help/ecoder/ug/msgs_cpp_top_model_p1_b.png",
            "https://in.mathworks.com/help/ecoder/ug/msgs_cpp_top_model_p4.png",
            "https://in.mathworks.com/help/ecoder/ug/msgs_cpp_top_model_p5.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p1.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p2_p4.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p3.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p2_p4.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p5.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p6.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p7.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p8.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p9.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p10.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p1.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p11_a.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p11_b.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p12_a.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p12_b.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p13.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p14.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p15_a.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p15_b.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p16.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p17.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p18_a.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p18_b.png",
            "https://in.mathworks.com/help/ecoder/ug/msg_cpp_c_p19.png"
        ]
    },
    {
        "title": "Simulink Messages Overview",
        "introduction": "Message-based communication is necessary in various applications, such as control system architectures in which centralized architectures are replaced with distributed architectures due to the complexity of the systems. In a distributed architecture, multiple components of the system communicate via a shared network. A distributed architecture has these three elements: Below is an illustration that shows the composition of a distributed architecture and its elements. When modeling such an architecture, you typically model components that are clearly identifiable, reusable, and deployable. To achieve asynchronous event-based communication between components, use message send and receive interfaces. Model the middleware to facilitate the network topology that represents the connectivity of components, such as one-to-many, many-to-one, or many-to-many based on the number of message sending and receiving components. For an example, see Build a Shared Communication Channel with Multiple Senders and Receivers. To learn how to model a distributed architecture, using Simulink\u00c2\u00ae, SimEvents\u00c2\u00ae, and Stateflow\u00c2\u00ae, see the illustration below. The illustration includes two message sending and three message receiving components that are created as referenced models. You can model components with send and receive interfaces using Simulink Send and Receive blocks. If your send and receive interfaces involve states or require decision logic, use a Stateflow chart. You can also model event-driven or message triggered receive interfaces using Message Triggered Subsystem. After you model your components and interfaces: Sine Wave | Send | Receive | Queue | Sequence Viewer",
        "chunks": [
            {
                "heading": "Model Message Send and Receive Interfaces and Generate Code",
                "content": "Let us start by understanding how message blocks work. To create a model that uses messages, use Send blocks to convert data and send messages and Receive blocks to receive and convert messages to data. For a simple example that shows how Send and Receive blocks work, see Animate and Understand Sending and Receiving Messages.\n\nUse Send and Receive blocks to model message send and receive interfaces for your components. For a simple example that shows the basics of creating send and receive interfaces, see Establish Message Send and Receive Interfaces Between Software Components. To learn how to generate code for the same model, see Generate C++ Messages to Communicate Data Between Simulink Components (Embedded Coder).\n\nYou can further modify send and receive interfaces for custom behavior. For example, you can synchronize when a receive interface executes to when data is available. For more information, see Connect Message Receive Interface with Simulink Functions.\n\nAfter modeling, generate code for your send and receive interfaces and connect them to the middleware or an operating system communication API. For an example that generates code for a top model and allows your application to communicate in a distributed system that uses an external message protocol service (for example, DDS, ROS, SOMEIP, or POSIX messages), see Generate C++ Messages to Communicate Data Between Simulink and an Operating System or Middleware (Embedded Coder)."
            },
            {
                "heading": "Model Event-Driven Receive Interfaces",
                "content": "Use Message Triggered Subsystem block to configure your subsystem to be triggered by messages and to respond to events.\n\nWhen you use Message Triggered Subsystem block in scheduled mode, the execution order of the subsystem can be scheduled as aperiodic partitions using the Schedule Editor to model an asynchronous behavior. The subsystems pull and process the data based on a schedule instead of periodic execution. For an example, see Asynchronous Message Handling in Adaptive Cruise Control."
            },
            {
                "heading": "Simulate Middleware Effects on a Distributed Architecture",
                "content": "Use Queue blocks to store, sort and queue messages. The Queue block allows you to specify message storage capacity and the overwriting and sorting policies for message transitions. For a simple example that shows how a Queue block works, see Use a Queue Block to Manage Messages.\n\nYou can also use SimEvents to model and simulate middleware effects on your communication network. Use the blocks provided by the SimEvents library to model message routing, peer-to-peer communication, wireless communication, packet loss, and channel delays. For more information about SimEvents, see Discrete-Event Simulation in Simulink Models (SimEvents).\n\nFor basic communication patterns that can be modeled by SimEvents, see Modeling Message Communication Patterns with SimEvents. You can use combinations of these patterns to create more complex communication behavior. For an example of a system with multiple message sending and receiving components and an ideal shared channel with delay, see Build a Shared Communication Channel with Multiple Senders and Receivers. To see a model with shared wireless channel with channel failure and packet loss, see Model Wireless Message Communication with Packet Loss and Channel Failure.\n\nTo see an example that shows how to model more complex network behavior, such as an Ethernet communication network with CSMA/CD protocol, see Model an Ethernet Communication Network with CSMA/CD Protocol.\n\nNote SimEvents blocks do not support code generation."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/simulink-messages-overview.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/messages_composition_figure.png",
            "https://in.mathworks.com/help/simulink/ug/messages_composition_modeling_figure.png"
        ]
    },
    {
        "title": "Use the Sequence Viewer to Visualize Messages, Events, and Entities",
        "introduction": "To see the interchange of messages and events between the blocks from the Simulink\u00c2\u00ae Messages & Events library, Stateflow\u00c2\u00ae charts in Simulink models, and SimEvents\u00c2\u00ae blocks, you can: The Sequence Viewer allows you to visualize message transition events and the data that the messages carry. In the Sequence Viewer, you can view event data related to Stateflow chart execution and the exchange of messages between Stateflow charts. The Sequence Viewer window shows messages as they are created, sent, forwarded, received, and destroyed at different times during model execution. The Sequence Viewer window also displays state activity, transitions, and function calls to Stateflow graphical functions, Simulink functions, and MATLAB\u00c2\u00ae functions. With the Sequence Viewer, you can also visualize the movement of entities between blocks when simulating SimEvents models. All SimEvents blocks that can store entities appear as lifelines in the Sequence Viewer window. Entities moving between these blocks appear as lines with arrows. You can view calls to Simulink Function blocks and to MATLAB Function blocks. You can add a Sequence Viewer block to the top level of a model or any subsystem. If you place a Sequence Viewer block in a subsystem that does not have messages, events, or state activity, the Sequence Viewer window informs you that there is nothing to display. For instance, open the Stateflow example sf_msg_traffic_light. This model has three Simulink subsystems: Traffic Light 1, Traffic Light 2, and GUI. During simulation, the Stateflow charts in these subsystems exchange data by sending messages. As messages pass through the system, you can view them in the Sequence Viewer window. The Sequence Viewer window represents each block in the model as a vertical lifeline with simulation time progressing downward.",
        "chunks": [
            {
                "heading": "Components of the Sequence Viewer Window",
                "content": ""
            },
            {
                "heading": "Navigation Toolbar",
                "content": "At the top of the Sequence Viewer window, a navigation toolbar displays the model hierarchy path. Using the toolbar buttons, you can:\n\nShow or hide the Property Inspector. Select an automatic or manual layout. Show or hide inactive lifelines. Save Sequence Viewer settings. Restore Sequence Viewer settings. Configure Sequence Viewer parameters. Access the Sequence Viewer documentation."
            },
            {
                "heading": "Property Inspector",
                "content": "In the Property Inspector, you can choose filters to show or hide:\n\nEventsMessagesFunction CallsState Changes and Transitions"
            },
            {
                "heading": "Header Pane",
                "content": "The header pane below the Sequence Viewer toolbar shows lifeline headers containing the names of the corresponding blocks in a model.\n\nGray rectangular headers correspond to subsystems.White rectangular headers correspond to masked subsystems.Yellow headers with rounded corners correspond to Stateflow charts.\n\nTo open a block in the model, click the name in the corresponding lifeline header. To show or hide a lifeline, double-click the corresponding header. To resize a lifeline header, click and drag its right-hand side. To fit all lifeline headers in the Sequence Viewer window, press the space bar."
            },
            {
                "heading": "Message Pane",
                "content": "Below the header pane is the message pane. The message pane displays messages, events, and function calls between lifelines as arrows from the sender to the receiver. To display sender, receiver, and payload information in the Property Inspector, click the arrow corresponding to the message, event, or function call."
            },
            {
                "heading": "Navigate the Lifeline Hierarchy",
                "content": "In the Sequence Viewer window, the hierarchy of lifelines corresponds to the model hierarchy. When you pause or stop the model, you can expand or contract lifelines and change the root of focus for the viewer."
            },
            {
                "heading": "Expand a Parent Lifeline",
                "content": "In the message pane, a thick, gray lifeline indicates that you can expand the lifeline to see its children. To show the children of a lifeline, click the expander icon below the header or double-click the parent lifeline.\n\nFor example, expanding the lifeline for the Traffic Light 1 block reveals two new lifelines corresponding to the Stateflow charts Ped Button Sensor and Controller."
            },
            {
                "heading": "Expand a Masked Subsystem Lifeline",
                "content": "The Sequence Viewer window displays masked subsystems as white blocks. To show the children of a masked subsystem, point over the bottom left corner of the lifeline header and click the arrow.\n\nFor example, the GUI subsystem contains four masked subsystems: Traffic Lamp 1,Traffic Lamp 2, Ped Lamp 1, and Ped Lamp 2.\n\nYou can display the child lifelines in these masked subsystems by clicking the arrow in the parent lifeline header."
            },
            {
                "heading": "Change Root of Focus",
                "content": "To make a lifeline the root of focus for the viewer, point over the bottom left corner of the lifeline header and click the arrow. Alternatively, you can use the navigation toolbar at the top of the Sequence Viewer window to move the current root up and down the lifeline hierarchy. To move the current root up one level, press the Esc key.\n\nThe Sequence Viewer window displays the current root lifeline path and shows its child lifelines. Any external events and messages are displayed as entering or exiting through vertical slots in the diagram gutter. When you point to a slot in the diagram gutter, a tooltip displays the name of the sending or receiving block."
            },
            {
                "heading": "View State Activity and Transitions",
                "content": "To see state activity and transitions in the Sequence Viewer window, expand the state hierarchy until you have reached the lowest child state. Vertical yellow bars show which state is active. Blue horizontal arrows denote the transitions between states.\n\nIn this example, you can see a transition from Go to PrepareToStop followed, after 1 second, by a transition to Stop.\n\nTo display the start state, end state, and full transition label in the Property Inspector, click the arrow corresponding to the transition.\n\nTo display information about the interactions that occur while a state is active, click the yellow bar corresponding to the state. In the Property Inspector, use the Search Up and Search Down buttons to move through the transitions, messages, events, and function calls that take place while the state is active."
            },
            {
                "heading": "View Function Calls",
                "content": "The Sequence Viewer displays function calls and replies. This table lists the type of support for each type of function call.\n\nFunction Call TypeSupportCalls to Simulink Function blocksFully supported.Calls to Stateflow graphical or Stateflow MATLAB functions Scoped \u00e2\u0080\u0094 Select the Export chart level functions chart option. Use the chartName.functionName dot notation.Global \u00e2\u0080\u0094 Select the Treat exported functions as globally visible chart option. You do not need the dot notation. Calls to function-call subsystemsFully supported and displayed.Calls from MATLAB Function blockSupports displaying function call events with the limitation of calls crossing model reference boundaries.\n\nThe Sequence Viewer window displays function calls as solid arrows labeled with the format function_name(argument_list). Replies to function calls are displayed as dashed arrows labeled with the format [argument_list]=function_name.\n\nFor example, in the model slexPrinterExample, a subsystem calls the Simulink Function block addPrinterJob. The function block replies with an output value of false.\n\nTo open this example, enter:\n\nopenExample(\"slexPrinterExample\")"
            },
            {
                "heading": "Simulation Time in the Sequence Viewer Window",
                "content": "The Sequence Viewer window shows events vertically, ordered in time. Multiple events in Simulink can happen at the same time. Conversely, there can be long periods of time during simulation with no events. As a consequence, the Sequence Viewer window shows time by using a combination of linear and nonlinear displays. The time ruler shows linear simulation time. The time grid shows time in a nonlinear fashion. Each time grid row, bordered by two blue lines, contains events that occur at the same simulation time. The time strip provides the times of the events in that grid row.\n\nTo show events in a specific simulation time range, use the scroll wheel or drag the time slider up and down the time ruler. To navigate to the beginning or end of the simulation, click the Go to first event or Go to last event buttons. To see the entire simulation duration on the time ruler, click the Fit to view button .\n\nWhen using a variable step solver, you can adjust the precision of the time ruler. In the Model Explorer, on the Main tab of the Sequence Viewer Block Parameters pane, adjust the value of the Time Precision for Variable Step field."
            },
            {
                "heading": "Redisplay of Information in the Sequence Viewer Window",
                "content": "The Sequence Viewer saves the order and states of lifelines between simulation runs. When you close and reopen the Sequence Viewer window, it preserves the last open lifeline state. To save a particular viewer state, click the Save Settings button in the toolbar. Saving the model then saves that state information across sessions. To load the saved settings, click the Restore Settings button .\n\nNoteWhen you update your model or rerun simulation, the Sequence Viewer clears results from past runs. To save results from past runs, use the Simulation Data Inspector.\n\nYou can modify the Time Precision for Variable Step and History parameters only between simulations. You can access the buttons in the toolbar before simulation or when the simulation is paused. During a simulation, the buttons in the toolbar are disabled."
            },
            {
                "heading": "Blocks",
                "content": "\u2022 Sequence Viewer"
            },
            {
                "heading": "Tools",
                "content": "\u2022 Sequence Viewer\n\n\u2022 Communicate with Stateflow Charts by Sending Messages (Stateflow)\n\u2022 Model Distributed Traffic Control System by Using Messages (Stateflow)"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/use-sequence-viewer-block.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/sf_msg_traffic_light_model.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display21.png",
            "https://in.mathworks.com/help/simulink/ug/property_inspector_button.png",
            "https://in.mathworks.com/help/simulink/ug/manual_layout_button.png",
            "https://in.mathworks.com/help/simulink/ug/inactive_lifelines_button.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_savesettings.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_restoresettings.png",
            "https://in.mathworks.com/help/simulink/ug/configure_button.png",
            "https://in.mathworks.com/help/simulink/ug/doc_button.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display61.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_payload1.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display9.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display31.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer15.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer13.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display41.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_display51.png",
            "https://in.mathworks.com/help/simulink/ug/state_activity.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_function_call.png",
            "https://in.mathworks.com/help/simulink/ug/message-viewer-time.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_fittoview.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_savesettings.png",
            "https://in.mathworks.com/help/simulink/ug/message_viewer_restoresettings.png"
        ]
    },
    {
        "title": "Design Your Model for Effective Acceleration",
        "introduction": "",
        "chunks": [
            {
                "heading": "Select Blocks for Accelerator Mode",
                "content": "Accelerator mode runs the following blocks as if you were running normal mode because these blocks do not generate code for the accelerator build. Consequently, if your model contains a high percentage of these blocks, accelerator mode may not increase performance significantly. All of these Simulink\u00c2\u00ae blocks use interpreted code.\n\nDisplayFrom FileFrom WorkspaceInport (root level only)Interpreted MATLAB FunctionOutport (root level only)ScopeTo FileTo Workspace\n\nThe following blocks can cause poor simulation runtime performance when run in the default JIT accelerator mode.\n\nTransport DelayVariable Transport Delay"
            },
            {
                "heading": "Select Blocks for Rapid Accelerator Mode",
                "content": "Blocks that do not support code generation (such as SimEvents\u00c2\u00ae) or blocks that generate code only for a specific target cannot be simulated in rapid accelerator mode.\n\nAdditionally, rapid accelerator mode does not work if your model contains any of the following blocks:\n\nInterpreted MATLAB FunctionDevice driver S-functions, such as blocks from the Simulink Real-Time\u00e2\u0084\u00a2 product, or those targeting Freescale\u00c2\u00ae MPC555"
            },
            {
                "heading": "Control S-Function Execution",
                "content": "NoteIn the default JIT accelerator mode, inlining of user-written TLC S-Functions is not supported. If you run a model containing TLC S-Functions in the JIT accelerator mode, there is a possibility of the execution speed reducing. The code generation speed, however, will be high due to JIT acceleration.\n\nInlining S-functions using the Target Language Compiler increases performance with the classic accelerator mode by eliminating unnecessary calls to the Simulink API. By default, however, the classic accelerator mode ignores an inlining TLC file for an S-function, even though the file exists. The rapid accelerator mode always uses the TLC file if one is available.\n\nA device driver S-Function block written to access specific hardware registers on an I/O board is one example of why this behavior was chosen as the default. Because the Simulink software runs on the host system rather than the target, it cannot access the target I/O registers and so would fail when attempting to do so.\n\nTo direct the classic accelerator mode to use the TLC file instead of the S-function MEX-file, specify SS_OPTION_USE_TLC_WITH_ACCELERATOR in the mdlInitializeSizes function of the S-function, as in this example:\n\nstatic void mdlInitializeSizes(SimStruct *S) { /* Code deleted */ ssSetOptions(S, SS_OPTION_USE_TLC_WITH_ACCELERATOR); }\n\nRapid accelerator mode will make use of the MEX file if the S-Function C file is not present in the same folder.\n\nNoteTo use the .c or .cpp code for your S-Function, ensure that they are in the same folder as the S-Function MEX-file. Otherwise, you can include additional files to an S-function or bypass the path limitation by using the rtwmakecfg.m file. For more information, see Use rtwmakecfg.m API to Customize Generated Makefiles (Simulink Coder)."
            },
            {
                "heading": "Accelerator and Rapid Accelerator Mode Data Type Considerations",
                "content": "Accelerator mode supports fixed-point signals and vectors up to 65,535 bits.Rapid accelerator mode supports fixed-point parameters up to 65,535 bits.Rapid accelerator mode supports fixed-point root inputs up to 32 bitsRapid accelerator mode supports root inputs of Enumerated data typeRapid accelerator mode does not support fixed-point data for the From Workspace block.Rapid accelerator mode ignores the Log fixed-point data as a fi object parameter for the To Workspace block.Rapid accelerator mode supports bus objects as parameters.Accelerator mode and rapid accelerator mode store integers as compactly as possible.Fixed-Point Designer\u00e2\u0084\u00a2 does not collect min, max, or overflow data in the accelerator or rapid accelerator modes.Accelerator mode supports a limited set of runtime diagnostics, including the assertion block.Rapid accelerator mode supports a limited set of runtime diagnostics, including the assertion block."
            },
            {
                "heading": "Behavior of Scopes and Viewers with Rapid Accelerator Mode",
                "content": "Running the simulation programmatically or interactively determines the behavior of scopes and viewers in rapid accelerator mode.\n\nScope or Viewer TypeSimulation Run InteractivelySimulation Run ProgrammaticallySimulink Scope blockSame support as normal mode Logging is supportedScope window is not updated Simulink signal viewer scopesGraphics are updated, but logging is not supportedNot supportedOther signal viewer scopesSupport limited to that available in external modeNot supportedSignal loggingSupported.Supported.Visualizers with inputs from logging(Such as the Simulation Data Inspector or Logic Analyzer)Data not visualized during simulation.Data not visualized during simulation.Stateflow\u00c2\u00ae chartsSame support for chart animation as normal modeNot supported\n\nNoteAlthough scopes and viewers do not update when you run rapid accelerator simulations programmatically, they do update when you run the simulation interactively. Run Acceleration Mode from the User Interface shows how to run rapid accelerator mode from the menu. Interact with the Acceleration Modes Programmatically shows how to run the simulation programmatically."
            },
            {
                "heading": "Factors Inhibiting Acceleration",
                "content": "You cannot use accelerator mode or rapid accelerator mode if your model: Passes array parameters to MATLAB\u00c2\u00ae S-functions that are not numeric, logical, or character arrays, are sparse arrays, or that have more than two dimensions.Uses Fcn blocks containing trigonometric functions having complex inputs. In some cases, changes associated with external or custom code do not cause accelerator or rapid accelerator simulation results to change. These include: TLC codeS-function source code, including rtwmakecfg.m filesIntegrated custom codeS-Function Builder In such cases, consider force regeneration of code for a top model. Alternatively, you can force regeneration of top model code by deleting code generation folders, such as slprj or the generated model code folder. NoteWith JIT acceleration, the acceleration target code is in memory. It is therefore available for reuse as long as the model is open, even if you delete the slprj folder."
            },
            {
                "heading": "Rapid Accelerator Mode Limitations",
                "content": "Rapid accelerator mode does not support: Algebraic loops.Targets written in C++.Interpreted MATLAB Function blocks.Noninlined MATLAB language or Fortran S-functions. You must write S-functions in C or inline them using the Target Language Compiler (TLC) or you can also use the MEX file. For more information, see Write Fully Inlined S-Functions (Simulink Coder).Debugging utilities or Simulink Profiler.Run time objects for Simulink.RunTimeBlock and Simulink.BlockCompOutputPortData blocks. Model parameters must be one of these data types:booleanuint8 or int8uint16 or int16uint32 or int32single or doubleFixed-pointEnumeratedYou cannot pause a simulation in rapid accelerator mode.In certain cases, changing block parameters can result in structural changes to your model that change the model checksum. An example of such a change is changing the number of delays in a DSP simulation. In these cases, you must regenerate the code for the model. See Code Regeneration in Accelerated Models for more information.For root inports, when you specify the minimum and maximum values that the block should output, rapid accelerator mode does not recognize these limits during simulation.In rapid accelerator mode, To File or To Workspace blocks inside function-call subsystems do not generate any logging files if the function-call port is connected to Ground or unconnected.Rapid accelerator mode does not support systems that run RHEL / CentOS 6.x or 7.x.In rapid accelerator mode, struct/enum redefinition occurs when model has custom code types.Simulink parameter values larger than 2KB cannot be downloaded to rapid accelerator target."
            },
            {
                "heading": "Reserved Keywords",
                "content": "Certain words are reserved for use by the Simulink Coder\u00e2\u0084\u00a2 code language and by accelerator mode and rapid accelerator mode. These keywords must not appear as function or variable names on a subsystem, or as exported global signal names. Using the reserved keywords results in the Simulink software reporting an error, and the model cannot be compiled or run.\n\nThe keywords reserved for the Simulink Coder product are listed in Construction of Generated Identifiers (Simulink Coder). Additional keywords that apply only to the accelerator and rapid accelerator modes are:\n\nmuDoubleScalarAbs muDoubleScalarCosmuDoubleScalarModmuDoubleScalarAcos muDoubleScalarCoshmuDoubleScalarPower muDoubleScalarAcoshmuDoubleScalarExpmuDoubleScalarRoundmuDoubleScalarAsinmuDoubleScalarFloormuDoubleScalarSignmuDoubleScalarAsinh muDoubleScalarHypotmuDoubleScalarSinmuDoubleScalarAtanmuDoubleScalarLogmuDoubleScalarSinhmuDoubleScalarAtan2muDoubleScalarLog10muDoubleScalarSqrtmuDoubleScalarAtanhmuDoubleScalarMaxmuDoubleScalarTanmuDoubleScalarCeil muDoubleScalarMin muDoubleScalarTanh"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/designing-your-model-for-effective-acceleration.html",
        "images": []
    },
    {
        "title": "Create Standalone Instrument Panel App by Using Application Compiler - MATLAB &amp; Simulink\n",
        "introduction": "Simulink Real-Time Explorer | Instrument",
        "chunks": [
            {
                "heading": "Package App by Using Application Compiler",
                "content": "After developing a real-time application and an App Designer instrument panel app that provides and interface to the real-time application, you can use the Application Compiler to package the app.\n\nOpen MATLAB\u00c2\u00ae and set the current folder to the folder in which you are creating the standalone executable instrument panel.\n\nSelect Apps > Application Compiler. For more information, see Application Compiler (MATLAB Compiler).\n\nPopulate the Application Compiler dialog box with information for the application compiler project. The image shows the example selections for project MyInstPanel_slrt_ex_osc.prj. The compiler settings are:\n\nMain file: myInstPanel_slrt_ex_osc.mlappApplication Name: myInstPanelAuthor Name: J. DoeEmail: jdoe@mycompany.comCompany: MyCompanySummary: This standalone application provides an interface to a real-time application.Description: This standalone application provides an interface to a real-time application.Default installation folder: %ProgramFiles%\\MyCompany\\myAppTesting\\Do not display the Windows Command Shell (console) for execution: Yes\n\nYour choice of whether to select Runtime downloaded or Runtime included packaging options for the project influences the length of time for packaging and for installing the application. If the development computer that will be running the standalone executable instrument panel has internet access, select downloaded. If not, select included.\n\nFor Suggested Support Packages, select the Simulink Real-Time Target Support Package.\n\nFor Files required for your application to run, select the real-time application MLDATX file.\n\nNote: To enable downloading a real-time application to a target computer, the name of the application must be specified in the Load Button component of the instrument panel.\n\nSave the Application Compiler project as myInstPanel.prj.\n\nIn the Application Compiler dialog box, select Package. The Package status indicates completion of the packaging stages. When completed, click Close.\n\nThe packaging process outputs folders for_redistribution, for_redistribution_files_only, and for_testing."
            },
            {
                "heading": "Install Instrument Panel Application",
                "content": "To install the instrument panel application, run the executable file from the for_redistribution folder.\n\nOn Windows\n\nIf you selected Runtime downloaded from web for the project, run installer MyAppInstaller_web.exe.If you selected Runtime included in package for the project, run installer MyAppInstaller_mcr.exe.\n\nOn Linux\n\nIf you selected Runtime downloaded from web for the project, run installer MyAppInstaller_web.install.If you selected Runtime included in package for the project, run installer MyAppInstaller_mcr.install.\n\nFor this example, installer executable file is MyAppInstaller_mcr.exe. When run, this file installs the MATLAB runtime and installs the instrument panel executable file:\n\nC:\\Program Files\\MyCompany\\MyInstPanel_slrt_ex_osc\\application\\MyInstPanel_slrt_ex_osc.exe\n\nTip: Make a note of the MATLAB run time path in this step. The path can be used to run the standalone application on Linux system.\n\nTo test the standalone executable instrument panel, close MATLAB and run the MyInstPanel_slrt_ex_osc EXE file.\n\nOn Windows\n\nrun the MyInstPanel_slrt_ex_osc EXE file\n\nOn Linux\n\nrun the command\n\n./run_MyInstPanel_slrt_ex_osc.sh /usr/local/MATLAB/MATLAB_Runtime/v911\n\nUse the instrument panel to connect to the target computer by inserting the target computer IP address (for example, 192.168.7.5) in place of the target computer name (for example, TargetPC1). Load the real-time application, and start the application. Observe that the instrument panel provides an interface to control the real-time application.\n\nIf you modify your real-time application or instrument panel app and repackage these, you do not need to send the installer to your end-users. Instead, you can send them the updated EXE file from the for_redistribution_files_only folder to replace the EXE file in their application folder.\n\nNote: If your system uses firewall software such as the Window Defender Firewall and you have configured exceptions for MATLAB\u00c2\u00ae to let Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 communicate with the target computer through the firewall, configure exceptions for your compiled application so it can communicate with the target computer. For more information, see Troubleshoot Communication Failure Through Firewall (Windows)."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/create-standalone-instrument-panel-app-by-using-application-compiler.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/CreateStandaloneInstPanelAppWithAppCompilerExample_01.png"
        ]
    },
    {
        "title": "Composite Interface Guidelines",
        "introduction": "To simplify model appearance, you can group signals, messages, or conserving connections to create composite interfaces for model components and blocks. Composite interfaces reduce the number of ports on a model component and the number of lines in a block diagram. Elements of a composite interface retain their separate identities. Virtual buses meet most modeling requirements for composite interfaces, and they give you the flexibility to group different types of elements. They reduce line complexity and clutter in a block diagram and make it easier to change the interface incrementally. For example, if you must add or remove elements from a component interface, modifying a bus can be simpler than adding or removing ports. When you create a composite interface, such as a virtual bus, group lines based on their functionality. By organizing signals, messages, or connections into logical groupings, you reduce the likelihood of significant refactoring in the future. At component interfaces, use In Bus Element and Out Bus Element blocks. In Bus Element blocks let you extract bus elements by name at their point of use. Out Bus Element blocks let you build an output bus by connecting elements to multiple Out Bus Element blocks for the same output port. To enforce the composition of a bus at an interface, use a Simulink.Bus object. To implement the bus definition as a structure in generated code or to iteratively process buses in a subsystem such as a for-each subsystem, consider making the virtual buses into nonvirtual buses.",
        "chunks": [
            {
                "heading": "Visualize Composite Interfaces",
                "content": "Suppose you have this relatively simple model.\n\nEach component interface in this model has multiple ports, and the signal lines clutter the model.\n\nWith composite interfaces, you can simplify the block diagram by reducing the number of lines.\n\nVirtual buses simplify the signal lines in the block diagram based on four different types of functionality: sensor data, system goals, control signals, and system disturbances.\n\nThe components use In Bus Element and Out Bus Element blocks at their interface. For example, consider the contents of the subsystem named Controller.\n\nEach In Bus Element and Out Bus Element block has a label that displays the corresponding element, for example, sensor.x1. In this example, sensor is the name of the port, and x1 is the name of the bus element. Two In Bus Element blocks select this element to avoid a branched signal line."
            },
            {
                "heading": "Define Composite Interfaces",
                "content": "Before you create composite interfaces, consider your high-level and low-level modeling requirements.\n\n1. Explore Composite InterfacesDecide how to group signals, messages, or conserving connections based on your high-level modeling requirements.2. Compare Capabilities of Composite InterfacesCompare virtual buses, nonvirtual buses, and arrays of buses against low-level modeling requirements.\n\nTipTo identify the boundaries, scope of data, and interface attributes of your model component, see Define Interfaces of Model Components."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/composite-signal-techniques.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/model-without-composite-signals.png",
            "https://in.mathworks.com/help/simulink/ug/model-with-composite-signals.png",
            "https://in.mathworks.com/help/simulink/ug/model-with-bus-element-port-blocks.png"
        ]
    },
    {
        "title": "Optimize and Deploy on a Multicore Target",
        "introduction": "This topic shows how to use a model that is configured for concurrent execution using explicit partitioning and deploy it onto a target. To set up your model for concurrent execution, see Configure Your Model for Concurrent Execution. To specify the target architecture, see Specify a Target Architecture. To use explicit partitioning in a model that is set up for concurrent execution, see Partition Your Model Using Explicit Partitioning.",
        "chunks": [
            {
                "heading": "Generate Code",
                "content": "To generate code for a model that is configured for concurrent execution, on the Apps tab of the Simulink\u00c2\u00ae editor, select Simulink Coder. On the C Code tab, select Build. The resulting code includes:\n\nC code for parts of the model that are mapped to tasks and triggers in the Concurrent Execution dialog box. C code generation requires a Simulink Coder\u00e2\u0084\u00a2 license. For more information, see Code Generation (Simulink Coder) and Code Generation (Embedded Coder).HDL code for parts of the model that are mapped to hardware nodes in the Concurrent Execution dialog box. HDL code generation requires an HDL Coder\u00e2\u0084\u00a2 license. For more information, see HDL Code Generation from Simulink (HDL Coder).Code to handle data transfer between the concurrent tasks and triggers and to interface with the hardware and software components.\n\nThe generated C code contains one function for each task or trigger defined in the system. The task and trigger determines the name of the function:\n\nvoid <TriggerName>_TaskName(void);\n\nThe content for each such function consists of target-independent C code, except for:\n\nCode corresponding to blocks that implement target-specific functionalityCustomizations, including those derived from custom storage classes (see Organize Parameter Data into a Structure by Using Struct Storage Class (Embedded Coder)) or Code Replacement Libraries (Simulink Coder)Code that is generated to handle how data is transferred between tasks. In particular, Simulink Coder uses target-specific implementations of mutual exclusion primitives and data synchronization semaphores to implement the data transfer as described in the following table of pseudocode.\n\nData TransferInitializationReaderWriterData Integrity OnlyBufferIndex = 0; Initialize Buffer[1] with ICBegin mutual exclusion Tmp = 1 - BufferIndex; End mutual exclusiton Read Buffer[ Tmp ];Write Buffer[ BufferIndex ]; Begin mutual exclusion BufferIndex = 1 - BufferIndex; End mutual exclusionEnsure Determinism (Maximum Delay)WriterIndex = 0; ReaderIndex = 1; Initialize Buffer[1] with ICRead Buffer[ ReaderIndex ]; ReaderIndex = 1 - ReaderIndex;Write Buffer[ WriterIndex ] WriterIndex = 1 - WriterIndex;Ensure Determinism (Minimum Delay)N/AWait dataReady; Read data; Post readDone;Wait readDone; Write data; Post dataReady;Data Integrity OnlyC-HDL interfaceThe Simulink Coder and HDL Coder products both take advantage of target-specific communication implementations and devices to handle the data transfer between hardware and software components.\n\nThe generated HDL code contains one HDL project for each hardware node."
            },
            {
                "heading": "Build on Desktop",
                "content": "Simulink Coder and Embedded Coder\u00c2\u00ae targets provide an example target to generate code for Windows\u00c2\u00ae, Linux\u00c2\u00ae and macOS operating systems. It is known as the native threads example, which is used to deploy your model to a desktop target. The desktop may not be your final target, but can help to profile and optimize your model before you deploy it on another target.\n\nIf you have specified an Embedded Coder target, make the following changes in the Configuration Parameters dialog box.\n\nSelect the Code Generation > Templates > Generate an example main program check box.From the Code Generation > Templates > Target Operating System list, select NativeThreadsExample.Click OK to save your changes and close the Configuration Parameters dialog box.Apply these settings to all referenced models in your model.\n\nOnce you have set up your model, press Ctrl-B to build and deploy it to your desktop. The native threads example illustrates how Simulink Coder and Embedded Coder use target-specific threading APIs and data management primitives, as shown in Threading APIs Used by Native Threads Example. The data transfer between concurrently executing tasks behaves as described in Data Transfer Options. The coder products use the APIs on supported targets for this behavior, as described in Data Protection and Synchronization APIs Used by Native Threads Example."
            },
            {
                "heading": "Threading APIs Used by Native Threads Example",
                "content": "Aspect of Concurrent ExecutionLinux ImplementationWindows ImplementationmacOS ImplementationPeriodic triggering eventPOSIX timerWindows timerNot applicableAperiodic triggering eventPOSIX real-time signalWindows eventPOSIX non-real-time signalAperiodic triggerFor blocks mapped to an aperiodic task: thread waiting for a signalFor blocks mapped to an aperiodic trigger: signal actionThread waiting for an eventFor blocks mapped to an aperiodic task: thread waiting for a signalFor blocks mapped to an aperiodic trigger: signal actionThreads POSIX\u00c2\u00aeWindowsPOSIXThreads priorityAssigned based on sample time: fastest task has highest priorityPriority class inherited from the parent process. Assigned based on sample time: fastest task has highest priority for the first three fastest tasks. The rest of the tasks share the lowest priority.Assigned based on sample time: fastest task has highest priorityExample of overrun detectionYesYesNo"
            },
            {
                "heading": "Data Protection and Synchronization APIs Used by Native Threads Example",
                "content": "APILinux ImplementationWindows ImplementationmacOS ImplementationData protection APIpthread_mutex_initpthread_mutex_destroypthread_mutex_lockpthread_mutex_unlockCreateMutexCloseHandleWaitForSingleObjectReleaseMutexpthread_mutex_initpthread_mutex_destroypthread_mutex_lockpthread_mutex_unlockSynchronization APIsem_initsem_destroysem_waitsem_postCreateSemaphoreCloseHandleWaitForSingleObjectReleaseSemaphoresem_opensem_unlinksem_wait sem_post"
            },
            {
                "heading": "Profile and Evaluate Explicitly Partitioned Models on a Desktop",
                "content": "Profile the execution of your code on the multicore target using the Profile Report pane of the Concurrent Execution dialog box. You can profile using Simulink Coder (GRT) and Embedded Coder (ERT) targets. Profiling helps you identify the areas in your model that are execution bottlenecks. You can analyze the execution time of each task and find the task that takes most of the execution time. For example, you can compare the average execution times of the tasks. If a task is computation intensive, or does not satisfy real-time requirements and overruns, you can break it into tasks that are less computation intensive and that can run concurrently.\n\nWhen you generate a profile report, the software:\n\nBuilds the model.Generates code for the model.Adds tooling to the generated code to collect data.Executes the generated code on the target and collects data.Collates the data, generates an HTML file (model_name_ProfileReport.html) in the current folder, and displays that HTML file in the Profile Report pane of the Concurrent Execution dialog box.NoteIf an HTML profile report exists for the model, the Profile Report pane displays that file. To generate a new profile report, click .\n\nSectionDescriptionSummarySummarizes model execution statistics, such as total execution time and profile report creation time. It also lists the total number of cores on the host machine.Task Execution TimeDisplays the execution time, in microseconds, for each task in a pie chart color coded by task. Visible for Windows, Linux, and macOS platforms.Task Affinitization to Processor CoresPlatform-dependent. For each time step and task, Simulink displays the processor core number the task started executing on at that time step, color coded by processor.If there is no task scheduled for a particular time step, NR is displayed.Visible for Windows and Linux platforms.\n\nAfter you analyze the profile report, consider changing the mapping of Model blocks to efficiently use the concurrency available on your multicore system (see Map Blocks to Tasks, Triggers, and Nodes)."
            },
            {
                "heading": "Generate Profile Report",
                "content": "This topic assumes a previously configured model ready to be profiled for concurrent execution. For more information, see Configure Your Model for Concurrent Execution.\n\nIn the Concurrent Execution dialog box, click the Profile report node.The profile tool looks for a file named model_name_ProfileReport.html. If such a file does not exist for the current model, the Profile Report pane displays the following.NoteIf an HTML profile report exists for the model, the Profile Report pane displays that file. To generate a new profile report, click .Enter the number of time steps for which you want the profiler to collect data for the model execution.Click the Generate task execution profile report button.This action builds the model, generates code, adds data collection tooling to the code, and executes it on the target, which also generates an HTML profile report. This process can take several minutes. When the process is complete, the contents of the profile report appear in the Profile Report pane. For example:The profiling report shows the summary, execution time for each task, and the mapping of each task to processor cores. We see that tasks 1 and 2 run on core 0, where tasks 3 and 4 run on core 1. The Task Execution Time section of the report indicates that task 1 and task 3 take the most amount of time to run. Note that the period of task 3 is twice that of tasks 1 and 2, and the period of task 4 is twice that of task 3.Analyze the profile report. Create and modify your model or task mapping if needed, and regenerate the profile report.\n\nGenerate Profile Report at Command Line.\u00c2 \u00c2 Alternatively, you can generate a profile report for a model configured for concurrent execution at the command line. Use the Simulink.architecture.profile function.\n\nFor example, to create a profile report for the model slexMulticoreSolverExample:\n\nopenExample('slexMulticoreSolverExample'); Simulink.architecture.profile('slexMulticoreSolverExample');\n\nTo create a profile report with a specific number of samples (100) for the model slexMulticoreSolverExample:\n\nSimulink.architecture.profile('slexMulticoreSolverExample',120);\n\nThe function creates a profile report named slexMulticoreSolverExample_ProfileReport.html in your current folder."
            },
            {
                "heading": "Customize the Generated C Code",
                "content": "The generated code is suitable for many different applications and development environments. To meet your needs, you can customize the generated C code as described in Code and Tool Customization (Embedded Coder). In addition to those customization capabilities, for multicore and heterogeneous targets you can further customize the generated code as follows:\n\nYou can register your preferred implementation of mutual exclusion and data synchronization primitives using the code replacement library.You can define a custom target architecture file that allows you to specify target specific properties for tasks and triggers in the Concurrent Execution dialog box. For more information, see Define a Custom Architecture File."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/building-and-downloading-the-model-to-a-multicore-target.html#bs4bgcj",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/mds_generate_prof.png",
            "https://in.mathworks.com/help/simulink/ug/mds_profile_noreport.png",
            "https://in.mathworks.com/help/simulink/ug/mds_generate_prof.png",
            "https://in.mathworks.com/help/simulink/ug/mds_profile_report.png"
        ]
    },
    {
        "title": "Control Library Location and Naming During Build",
        "introduction": "When you generate precompiled, non-precompiled, and model reference libraries, you can control the library location and library name by using configuration parameters. These parameters control values in generated makefiles during model builds:",
        "chunks": [
            {
                "heading": "Library Control Parameters",
                "content": "Use the library control parameters to:\n\nSpecify the location of precompiled libraries, such as blockset libraries or the Simulink\u00c2\u00ae Coder\u00e2\u0084\u00a2 block library. Typically, a target has cross-compiled versions of these libraries and places them in a target-specific folder.Control the suffix applied to library file names (for example, _target.a or _target.lib).\n\nTargets can set the parameters inside the system target file (STF) select callback. For example:\n\nfunction mytarget_select_callback_handler(varargin) hDig=varargin{1}; hSrc=varargin{2}; slConfigUISetVal(hDig, hSrc, 'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs'); slConfigUISetVal(hDig, hSrc, 'TargetLibSuffix',... '_target.library');\n\nThe TMF has corresponding expansion tokens:\n\n|>EXPAND_LIBRARY_LOCATION<| |>EXPAND_LIBRARY_SUFFIX<|\n\nAlternatively, you can use a call to the set_param function. For example:\n\nset_param(model,'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nNoteIf your model contains referenced models, you can use the make option USE_MDLREF_LIBPATHS to control whether libraries used by the referenced models are copied to the build folder of the parent model. For more information, see Location of Model Reference Libraries."
            },
            {
                "heading": "Identify Library File Type for Toolchain Approach",
                "content": "The toolchain approach for model builds does not use the value of the TargetLibSuffix configuration parameter to select the library file name suffix and extension.\n\nWith the toolchain approach, the final binary name is composed of the modelname, the compilername, and the extension provided by the build tool description in the toolchain definition:\n\nmodel_compilername.extension\n\nYou can identify the static library file name extension from the build tool description in the toolchain definition. To get this information for the default toolchain, use this procedure:\n\nGet the default toolchain name. For example, enter:tc_name = coder.make.getDefaultToolchain()Get the default toolchain handle. For example, enter:tc = coder.make.getToolchainInfoFromRegistry(tc_name)Get the handle to the toolchain object. For example, enter:tool_archiver = tc.getBuildTool('Archiver');Get the extension. For example, enter:ext_archiver = tool_archiver.getFileExtension('Static Library');\n\nNote If you do not set the TargetLibSuffix parameter, template makefile and toolchain approaches produce the same static library file name extension."
            },
            {
                "heading": "Specify the Location of Precompiled Libraries",
                "content": "Use the TargetPreCompLibLocation configuration parameter to:\n\nOverride the precompiled library location specified in the rtwmakecfg.m file (see Use rtwmakecfg.m API to Customize Generated Makefiles for details)Precompile and distribute target-specific versions of product libraries (for example, the DSP System Toolbox\u00e2\u0084\u00a2 product)\n\nFor a precompiled library, such as a blockset library or the Simulink Coder block library, the location specified in rtwmakecfg.m is typically a location specific to the blockset or the Simulink Coder product. The code generator expects that the library exists in this location and links against the library during builds.\n\nFor some applications, such as custom targets, it is preferable to locate the precompiled libraries in a target-specific or other alternate location rather than in the location specified in rtwmakecfg.m. For a custom target, the code generator expects that the target-specific cross-compiler creates the library, and you place the library in the target-specific location. Compile and place libraries supported by the target in the target-specific location, so they can be used during the build process.\n\nYou can set up the TargetPreCompLibLocation parameter in its select callback. The path that you specify for the parameter must be a fully qualified, absolute path to the library location. Relative paths are not supported. For example:\n\nslConfigUISetVal(hDlg, hSrc, 'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nAlternatively, you set the parameter with a call to the set_param function. For example:\n\nset_param(model,'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nDuring makefile generation, the build process replaces the tokens with the location from the rtwmakecfg.m file. For example, if the library name in the rtwmakecfg.m file is 'rtwlib', the template makefile build approach expands the token from:\n\nLIBS += |>EXPAND_LIBRARY_LOCATION<|\\|>EXPAND_LIBRARY_NAME<|\\ _target.library\n\nto:\n\nLIBS += c:\\mytarget\\precomplibs\\rtwlib_target.library\n\nBy default, TargetPreCompLibLocation is an empty character vector. The build process uses the location in rtwmakecfg.m for the token replacement."
            },
            {
                "heading": "Location of Model Reference Libraries",
                "content": "The build process assigns a path such as ../slprj/grt/sub/sub_rtwlib.lib to MODELREF_LINK_LIBS. The build process uses the path to gain access to the library file at link time."
            },
            {
                "heading": "Control the Suffix Applied to Library File Names",
                "content": "With the template makefile approach for model builds, use the TargetLibSuffix configuration parameter to control the suffix applied to library names (for example, _target.lib or _target.a). The specified suffix scheme must include a period (.). You can apply TargetLibSuffix to the following libraries:\n\nLibraries on which a target depends, as specified in the rtwmakecfg.m API. You can use TargetLibSuffix to change the suffix of both precompiled and non-precompiled libraries configured from the rtwmakecfg API. For details, see Use rtwmakecfg.m API to Customize Generated Makefiles.In this case, a target can set the parameter in its select callback. For example: slConfigUISetVal(hDlg, hSrc, 'TargetLibSuffix',... '_target.library');Alternatively, you can use a call to the set_param function. For example:set_param(model,'TargetLibSuffix','_target.library');During the TMF-to-makefile conversion, the build process replaces the token |>EXPAND_LIBRARY_SUFFIX<| with the specified suffix. For example, if the library name specified in the rtwmakecfg.m file is 'rtwlib', the TMF expands from: LIBS += |>EXPAND_LIBRARY_LOCATION<|\\|>EXPAND_LIBRARY_NAME<|\\ |>EXPAND_LIBRARY_SUFFIX<|to: LIBS += c:\\mytarget\\precomplibs\\rtwlib_target.libraryBy default, TargetLibSuffix is set to an empty character vector. In this case, the build process replaces the token |>EXPAND_LIBRARY_SUFFIX<| with an empty character vector.Model libraries created with model reference. For these cases, associated makefile variables do not require the |>EXPAND_LIBRARY_SUFFIX<| token. Instead, the build process includes TargetLibSuffix implicitly. For example, for a top model named topmodel with referenced models named refmodel1 and refmodel2, the TMF of the top model is expanded from:MODELLIB = |>MODELLIB<| MODELREF_LINK_LIBS = |>MODELREF_LINK_LIBS<|to:MODELLIB = topmodellib_target.library MODELREF_LINK_LIBS = \\ refmodel1_rtwlib_target.library refmodel2_rtwlib_target.libraryBy default, the TargetLibSuffix parameter is an empty character vector. In this case, the build process chooses a default suffix for these three tokens using a file extension of .lib on Windows\u00c2\u00ae hosts and .a on UNIX\u00c2\u00ae hosts. For model reference libraries, the default suffix also includes _rtwlib. For example, on a Windows host, the expanded makefile values are:MODELLIB = topmodellib.lib MODELREF_LINK_LIBS = refmodel1_rtwlib.lib refmodel2_rtwlib.lib"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/controlling-the-location-and-naming-of-libraries-during-the-build-process.html#bqg8123",
        "images": []
    },
    {
        "title": "Simulink Real-Time Options Pane",
        "introduction": "Control the code created by Simulink\u00c2\u00ae Coder\u00e2\u0084\u00a2 code generation software for a Simulink Real-Time\u00e2\u0084\u00a2 application. Set up general information about building real-time applications, including target, execution, data logging, and other options.",
        "chunks": [
            {
                "heading": "Configuration",
                "content": "The Simulink Real-Time Options node in the Configuration Parameters dialog box allows you to specify how the software generates the real-time application. To reveal the Simulink Real-Time Options node, do the following:\n\nIn the Code Generation pane, in the System target file list, select slrealtime.tlc or another Simulink Real-Time STF. This setting generates system target code for Simulink Real-Time.NoteIf you open a model that was originally saved with System target file set to xpctarget.tlc, the software updates the setting to slrealtime.tlc. To retain the updated setting, save the updated model."
            },
            {
                "heading": "Tips",
                "content": "The default values work for the generation of most real-time applications. If you want to customize the build of your real-time application, set the option parameters to suit your specifications.To access configuration parameters from the MATLAB\u00c2\u00ae command line, use:gcs \u00e2\u0080\u0094 To access the current model.set_param \u00e2\u0080\u0094 To set the parameter value.get_param \u00e2\u0080\u0094 To get the current value of the parameter."
            },
            {
                "heading": "To get help on an option",
                "content": "Right-click the option text label.From the context menu, select What's This."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ref/simulink-real-time-options-pane.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ref/whatsthis.gif"
        ]
    },
    {
        "title": "Access Logged Signals with Spaces and Newlines in Logged Names - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Functions",
                "content": "\u2022 get | find | getElementNames | Simulink.SimulationData.forEachTimeseries | newline"
            },
            {
                "heading": "Objects",
                "content": "\u2022 Simulink.SimulationData.Dataset | Simulink.SimulationData.Signal\n\n\u2022 Save Run-Time Data from Simulation\n\u2022 Save Signal Data Using Signal Logging\n\u2022 Save Simulation Data"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/spaces-newlines-logged-signals.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/AccessLoggedSignalsWithSpacesAndNewlinesInLoggedNamesExample_01.png"
        ]
    },
    {
        "title": "Concepts in Multicore Programming",
        "introduction": "",
        "chunks": [
            {
                "heading": "Basics of Multicore Programming",
                "content": "Multicore programming helps you create concurrent systems for deployment on multicore processor and multiprocessor systems. A multicore processor system is a single processor with multiple execution cores in one chip. By contrast, a multiprocessor system has multiple processors on the motherboard or chip. A multiprocessor system might include a Field-Programmable Gate Array (FPGA). An FPGA is an integrated circuit containing an array of programmable logic blocks and a hierarchy of reconfigurable interconnects. A processing node processes input data to produce outputs. It can be a processor in a multicore or multiprocessor system, or an FPGA.\n\nThe multicore programming approach can help when:\n\nYou want to take advantage of multicore and FPGA processing to increase the performance of an embedded system.You want to achieve scalability so your deployed system can take advantage of increasing numbers of cores and FPGA processing power over time.\n\nConcurrent systems that you create using multicore programming have multiple tasks executing in parallel. This is known as concurrent execution. When a processor executes multiple parallel tasks, it is known as multitasking. A CPU has firmware called a scheduler, which handles the tasks that execute in parallel. The CPU implements tasks using operating system threads. Your tasks can execute independently but have some data transfer between them, such as data transfer between a data acquisition module and controller for the system. Data transfer between tasks means that there is a data dependency.\n\nMulticore programming is commonly used in signal processing and plant-control systems. In signal processing, you can have a concurrent system that processes multiple frames in parallel. In plant-control systems, the controller and the plant can execute as two separate tasks. Using multicore programming helps to split your system into multiple parallel tasks which run simultaneously.\n\nSimulink\u00c2\u00ae tries to optimize the host computer performance regardless of the modeling method you use. For more information on the ways that Simulink helps you to improve performance, see Optimize Performance.\n\nTo model a concurrently executing system, see Partitioning Guidelines."
            },
            {
                "heading": "Types of Parallelism",
                "content": "The concept of multicore programming is to have multiple system tasks executing in parallel. Types of parallelism include:\n\nData parallelismTask parallelismPipelining"
            },
            {
                "heading": "Data Parallelism",
                "content": "Data parallelism involves processing multiple pieces of data independently in parallel. The processor performs the same operation on each piece of data. You achieve parallelism by feeding the data in parallel.\n\nThe figure shows the timing diagram for this parallelism. The input is divided into four chunks, A, B, C, and D. The same operation F() is applied to each of these pieces and the output is OA, OB, OC, and OD respectively. All four tasks are identical, and they run in parallel.\n\nThe time taken per processor cycle, known as cycle time, is t = tF.\n\nThe total processing time is also tF, since all four tasks run simultaneously. In the absence of parallelism, all four pieces of data are processed by one processing node. The cycle time is tF for each task but the total processing time is 4*tF, since the pieces are processed in succession.\n\nYou can use data parallelism in scenarios where it is possible to process each piece of input data independently. For example, a web database with independent data sets for processing or processing frames of a video independently are good candidates for data parallelism."
            },
            {
                "heading": "Task Parallelism",
                "content": "In contrast to data parallelism, task parallelism doesn\u00e2\u0080\u0099t split up the input data. Instead, it achieves parallelism by splitting up an application into multiple tasks. Task parallelism involves distributing tasks within an application across multiple processing nodes. Some tasks can have data dependency on others, so all tasks do not run at exactly the same time.\n\nConsider a system that involves four functions. Functions F2a() and F2b() are in parallel, that is, they can run simultaneously. In task parallelism, you can divide your computation into two tasks. Function F2b() runs on a separate processing node after it gets data Out1 from Task 1, and it outputs back to F3() in Task 1.\n\nThe figure shows the timing diagram for this parallelism. Task 2 does not run until it gets data Out1 from Task 1. Hence, these tasks do not run completely in parallel. The time taken per processor cycle, known as cycle time, is\n\nt = tF1 + max(tF2a, tF2b) + tF3.\n\nYou can use task parallelism in scenarios such as a factory where the plant and controller run in parallel."
            },
            {
                "heading": "Model Pipeline Execution (Pipelining)",
                "content": "Use model pipeline execution, or pipelining, to work around the problem of task parallelism where threads do not run completely in parallel. This approach involves modifying your system model to introduce delays between tasks where there is a data dependency.\n\nIn this figure, the system is divided into three tasks to run on three different processing nodes, with delays introduced between functions. At each time step, each task takes in the value from the previous time step by way of the delay.\n\nEach task can start processing at the same time, as this timing diagram shows. These tasks are truly parallel and they are no longer serially dependent on each other in one processor cycle. The cycle time does not have any additions but is the maximum processing time of all the tasks.\n\nt = max(Task1, Task2, Task3) = max(tF1, tF2a, tF2b, tF3).\n\nYou can use pipelining wherever you can introduce delays artificially in your concurrently executing system. The resulting overhead due to this introduction must not exceed the time saved by pipelining."
            },
            {
                "heading": "System Partitioning for Parallelism",
                "content": "Partitioning methods help you to designate areas of your system for concurrent execution. Partitioning allows you to create tasks independently of the specifics of the target system on which the application is deployed.\n\nConsider this system. F1\u00e2\u0080\u0093F6 are functions of the system that can be executed independently. An arrow between two functions indicates a data dependency. For example, the execution of F5 has a data dependency on F3.\n\nExecution of these functions is assigned to the different processor nodes in the target system. The gray arrows indicate assignment of the functions to be deployed on the CPU or the FPGA. The CPU scheduler determines when individual tasks run. The CPU and FPGA communicate via a common communication bus.\n\nThe figure shows one possible configuration for partitioning. In general, you test different configurations and iteratively improve until you get the optimal distribution of tasks for your application."
            },
            {
                "heading": "Challenges in Multicore Programming",
                "content": "Manually coding your application onto a multicore processor or an FPGA poses challenges beyond the problems caused by manual coding. In concurrent execution, you must track:\n\nScheduling of the tasks that execute on the embedded processing system multicore processorData transfers to and from the different processing nodes\n\nSimulink manages the implementation of tasks and data transfer between tasks. It also generates the code that is deployed for the application. For more information, see Multicore Programming with Simulink.\n\nIn addition to these challenges, there are challenges when you want to deploy your application to different architectures and when you want to improve the performance of the deployed application."
            },
            {
                "heading": "Portability: Deployment to Different Architectures",
                "content": "The hardware configuration that runs the deployed application is known as the architecture. It can contain multicore processors, multiprocessor systems, FPGAs, or a combination of these. Deployment of the same application to different architectures can require effort due to:\n\nDifferent number and types of processor nodes on the architectureCommunication and data transfer standards for the architectureStandards for certain events, synchronization, and data protection in each architecture\n\nTo deploy the application manually, you must reassign tasks to different processing nodes for each architecture. You might also need to reimplement your application if each architecture uses different standards.\n\nSimulink helps overcome these problems by offering portability across architectures. For more information, see How Simulink Helps You to Overcome Challenges in Multicore Programming."
            },
            {
                "heading": "Deployment Efficiency",
                "content": "You can improve the performance of your deployed application by balancing the load of the different processing nodes in the multicore processing environment. You must iterate and improve upon your distribution of tasks during partitioning, as mentioned in System Partitioning for Parallelism. This process involves moving tasks between different processing nodes and testing the resulting performance. Since it is an iterative process, it takes time to find the most efficient distribution.\n\nSimulink helps you to overcome these problems using profiling. For more information, see How Simulink Helps You to Overcome Challenges in Multicore Programming."
            },
            {
                "heading": "Cyclic Data Dependency",
                "content": "Some tasks of a system depend on the output of other tasks. The data dependency between tasks determines their processing order. Two or more partitions containing data dependencies in a cycle creates a data dependency loop, also known as an algebraic loop.\n\nSimulink identifies loops in your system before deployment. For more information, see How Simulink Helps You to Overcome Challenges in Multicore Programming."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/concepts-in-multicore-programming.html#buuyax5",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/data_parallelism_schematic.png",
            "https://in.mathworks.com/help/simulink/ug/data_parallelism_timing.png",
            "https://in.mathworks.com/help/simulink/ug/task_parallelism_schematic.png",
            "https://in.mathworks.com/help/simulink/ug/task_parallelism_timing.png",
            "https://in.mathworks.com/help/simulink/ug/pipelining_schematic.png",
            "https://in.mathworks.com/help/simulink/ug/pipelining_timing.png",
            "https://in.mathworks.com/help/simulink/ug/workflow.png"
        ]
    },
    {
        "title": "Troubleshoot Folder Names with Spaces or Special Characters Halt Model Builds",
        "introduction": "When a space character appears the file path, the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 model build reports an error: When a special character, such as an open parenthesis character \"(\", appears in the file path, the model build reports an error:",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "For the Simulink Real-Time model build \u00e2\u0080\u00a6 message or for the Error(s) encountered while building \u00e2\u0080\u00a6 message, message indicates that a space character or special character appears in the file path. The QNX\u00c2\u00ae Neutrino\u00c2\u00ae toolchain for the code generation target is not compatible with file paths that contain spaces or special characters, the model build halts and does not output a real-time application."
            },
            {
                "heading": "Try This Workaround",
                "content": "Try these workaround options to resolve the model build errors."
            },
            {
                "heading": "Create a Build Folder",
                "content": "Create a folder name that does not have spaces or special characters in it. Build your model in that folder."
            },
            {
                "heading": "Map the Build Folder",
                "content": "Map the folder name or path that has spaces or special characters in it to a folder name or path without spaces or special characters. Build your model in the mapped folder."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-folder-names-with-spaces-or-special-characters-halt-model-builds.html",
        "images": []
    },
    {
        "title": "Build Process Support for File and Folder Names",
        "introduction": "addAttribute",
        "chunks": [
            {
                "heading": "Filenames with Spaces",
                "content": "For the build process that uses ToolchainInfo objects, only these toolchains support the use of filenames containing spaces:\n\nGNU gcc/g++ | gmake (64-bit Linux) on Linux\u00c2\u00aeMinGW64 | gmake (64-bit Windows) on Windows\u00c2\u00aeXcode with Clang | gmake (64-bit Mac) on Mac\n\nThe build process that uses template makefiles does not support the use of filenames containing spaces."
            },
            {
                "heading": "Folder Names with Spaces",
                "content": "On a Windows system, the code generator maps a drive corresponding to the MATLAB\u00c2\u00ae installation folder for either of these conditions:\n\nThe matlabroot folder is a UNC location.The path the matlabroot folder contains spaces, and the system has no alternative name support.\n\nThese folder paths can contain spaces:\n\nThe path to your MATLAB installation folder (matlabroot). For example, C:\\Program Files\\MATLAB\\R2015bThe path to the current working folder where you start the build (pwd). For example, C:\\Users\\username\\Documents\\My Work.The path to the installation folder for a compiler that the build process uses.\n\nIf your work environment includes one or more of the preceding scenarios, use the following support mechanisms for the build process:\n\nIf you are using the toolchain approach to build generated code, the system support for spaces in folder names influences toolchain operation:For Linux systems and Windows systems with 8.3 name creation enabled, the toolchain manages spaces in folder names by using alternative names from the operating system. The toolchain uses the TransformPathsWithSpaces attribute to manage these names.addAttribute(toolchainObject, 'TransformPathsWithSpaces', true);The security permissions of drives and folders can determine whether the toolchain transforms the path. For example, if the path contains a folder with a security configuration that forbids 8.3 path transformations, the toolchain does not transform the path and the build process produces a warning.For Windows systems with 8.3 name creation disabled, the toolchain manages spaces in folder names by mapping a network drive using a batch file (.bat). This operation requires adding the RequiresBatchFile attribute to the toolchain definition.addAttribute(toolchainObject, 'RequiresBatchFile', true);When developing a toolchain for a Windows system, set both attributes. For more information about the toolchain attributes, see addAttribute.If you are using the template makefile approach to build generated code, the template makefile (.tmf) requires code to manage spaces in folder names. When the alternative folder names (Windows short names) differ from the file system folder names (Windows long names), add this code to the makefile.ALT_MATLAB_ROOT = |>ALT_MATLAB_ROOT<| ALT_MATLAB_BIN = |>ALT_MATLAB_BIN<| !if \"$(MATLAB_ROOT)\" != \"$(ALT_MATLAB_ROOT)\" MATLAB_ROOT = $(ALT_MATLAB_ROOT) !endif !if \"$(MATLAB_BIN)\" != \"$(ALT_MATLAB_BIN)\" MATLAB_BIN = $(ALT_MATLAB_BIN) !endifWhen the values of the location tokens are not equal, this code replaces MATLAB_ROOT with ALT_MATLAB_ROOT. The replacement indicates that the path to your MATLAB installation folder includes spaces. This code applies the same type of replacement for MATLAB_BIN with ALT_MATLAB_BIN. The preceding code is specific to nmake. For platform-specific examples, see the supplied template makefiles.\n\nWith either build approach, when there is an issue with support for creation of alternate names (short names), build errors can occur on Windows. If a build generates an error message similar to the following message, see Troubleshooting Errors When Folder Names Have Spaces.\n\nNMAKE : fatal error U1073: don't know how to make ' ...\n\nWhen using operating system commands, such as system or dos, enclose paths that specify executable files or command parameters in double quotes (\" \"). For example:\n\nsystem('dir \"D:\\Applications\\Common Files\"')\n\nThis table provides a summary of build folder support and limitations for Windows.\n\nBuild Process FoldersApproach for Paths with UNC or SpacesSupport for Windowsmatlabroot folderThe matlabroot value is derived from the MATLAB installation location.During a build, a UNC location such as:\\\\networkdrive\\matlab\\R20xxbcould be remapped as:T:\\During a build on a Windows system with short filename (8.3) support (default for Windows using NTFS), the build process uses the Windows API getShortPathName() for the folder location.During a build on a Windows system without short filename (8.3) support (systems using ReFS or using NTFS with 8.3 support disabled), a location with spaces in the path such as:C:\\Program Files\\MATLAB\\R20xxbcould be remapped as:T:\\R20xxbBuild process folder support available independent of file system (NTFS or ReFS) or file system configuration for short filename support.Limitations:On systems that require drive mapping for the installation location, the build process requires that a drive letter is available for mapping.On systems without short filename (8.3) support (using ReFS or using NTFS with 8.3 support disabled), the final folder in the installation location cannot contain spaces. For example, a final folder name:C:\\Program Files\\MATLAB\\R20xxb sp1is not supported.Code generation folderSimulation cache folderCustom code source file locations\u00e2\u0080\u0094among others, these locations include folders specified by:rtwmakecfg.mModel configuration parameter Additional build informationCode replacement libraryFor UNC locations, build process temporarily maps a drive by using the shell commands pushd and popd.Build process folder support is available independent of file system (NTFS or ReFS) or file system configuration for short path name support.For paths with spaces, build process uses the Windows short path name (8.3) by using the Windows API:getShortPathName()Build process folder support depends on NTFS file system and requires Windows default support. Registry sets value of 2 or 0 for:NtfsDisable8dot3NameCreationLimitations: Build process does not support spaces in the path to these folders for: NTFS file system with short path name support disabled ReFS file system (this file system does not support short path names)"
            },
            {
                "heading": "Troubleshooting Errors When Folder Names Have Spaces",
                "content": "On Windows, when there is an issue with support for creation of short filenames, build process errors can occur. When this issue affects a build, you see an error message similar to:\n\nNMAKE : fatal error U1073: don't know how to make 'C:\\Work\\My'\n\nThis message can occur if a space in the folder name (C:\\Work\\My Models) prevents the build process from finding the model or a file to build. For descriptions of the build-related folders that are sensitive to a space in the folder name or path, see Folder Names with Spaces.\n\nTo avoid issues from folder names with spaces when Windows short filename support for filenames is disabled, do not use paths with spaces. For example, install third-party software to paths without spaces. Do not use paths with spaces for folders containing your models, source files, or libraries.\n\nAn issue can occur with builds that use folder names with spaces, because it is possible to disable Windows alternate name support. The build process uses this alternate name support on Windows systems. There are many terms for this file, folder, and path alternate name support:\n\n8.3 nameDOS pathshort filename (SFN, ShortFileName)long name aliasWindows path alias\n\nVerify the type of file system that the drive uses. In Windows Explorer, right-click the drive icon and select properties.\n\nIf the file system is ReFS (Resilient File System), it is an issue. The ReFS does not provide short filename support. Except for the MATLAB installation folder, the build process does not support folder names with spaces for the ReFS file system. If your work environment requires short filename support for the build folder or for additional external code folders, do not use ReFS.If the file system is NTFS (New Technology File System), it is possible that the build error is related to a registry setting incompatibility. Continue with troubleshooting steps.\n\nThe error could stem from an issue with short filename support on a system using NTFS. Check the Windows registry setting that enables the creation of short names for files, folders, and paths.\n\nOpen the Windows command prompt, running as administrator. For example, from the Windows Start menu, type cmd, right-click the cmd.exe icon, and select Run as administrator.Change to the windows\\system32 folder and query the NtfsDisable8dot3NameCreation status by typing:> fsutil 8dot3name queryIf the registry state of NtfsDisable8dot3NameCreation is not 0 (enable 8dot3 name creation for all volumes on the system), change the value to 0 by typing:> fsutil 8dot3name set 0For more information about enabling creation of short names. See https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/ff621566(v=ws.11).Changing the registry setting enables creation of short names only for files and folders that are created after the change. To create short names for files created while short name creation was disabled, at the Windows command line, use the fsutil utility.To set the short name, the syntax is:> fsutil file setshortname <FileName> <ShortName>For example, to create the short name PROGRA~1 for the long name C:\\Program Files, type:> fsutil file setshortname \"C:\\Program Files\" PROGRA~1The C:\\Program Files folder name is in quotations because it has spaces. \u00c2 To verify that the short name was created, use the dir command with /x option to show short names.> dir C:\\ /x"
            },
            {
                "heading": "Folder Names with Special Characters",
                "content": "The build process might produce an error if a build-related folder path contains:\n\nUnicode\u00c2\u00ae characters that do not belong to the system locale. This limitation does not apply if the build process uses a Microsoft\u00c2\u00ae Visual C++\u00c2\u00ae compiler.A Japanese (multibyte) character where the final byte is equal to the 5C hexadecimal character. The make and compiler tools might incorrectly interpret the final byte as the '\\' (backslash) character.One or more of these characters: '&' (ampersand)':' (colon)';' (semicolon)'$' (dollar sign)'(' (left parenthesis)')' (right parenthesis)'^' (circumflex accent)"
            },
            {
                "heading": "Very Long Folder Paths",
                "content": "For the MinGW\u00c2\u00ae compiler, the build process produces an error when the command line length exceeds the Windows limit of 32,767 characters. If this error occurs, check the length of include paths. You can reduce the command line length by building the generated code in a code generation folder that has a shorter name"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/enable-build-process-for-folder-names-with-spaces.html#bviznfr",
        "images": []
    },
    {
        "title": "Target Computer CPU Overload",
        "introduction": "Sometimes a real-time application running on the Speedgoat\u00c2\u00ae target computer does not have enough time to complete processing before the next time step. This condition is called a CPU overload. An overload is registered every time an execution step is triggered while the previous step is running. SLRT Overload Options",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/target-computer-cpu-overloads.html",
        "images": []
    },
    {
        "title": "Troubleshoot Communication Failure Through Firewall (Windows)",
        "introduction": "When attempting to connect to the Speedgoat\u00c2\u00ae target computer by using Simulink Real-Time Explorer, this error message appears. Even though the connection fails, clicking on the Update button or Reboot button in Simulink Real-Time Explorer works. These operations indicate that the target computer can be reached through the Ethernet port.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "In R2020b and later releases, Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 uses a protocol for the development-to-target computer connection that is blocked by default in Window Defender Firewall for networks classified as Public. Windows also classifies all Ethernet connections as Public by default.\n\nIf you do not select the correct options when first running MATLAB\u00c2\u00ae, it is can be possible to ping, update, and reboot the target computer from MATLAB. But, these incorrect option selections prevent communication connection to the target computer. This communication connection is necessary to load and run real-time applications on the target computer."
            },
            {
                "heading": "Try These Workarounds",
                "content": "Resolve this issue by allowing MATLAB to communicate on all types of networks. Apply this setting when prompted on first connection or apply this setting later through the Windows Defender Firewall Allow an app through Windows Firewall selection. If that is not possible due to privilege restrictions, the issue can also be resolved by changing the classification of the Ethernet interface used for development-to-target computer connection from Public to Private.\n\nNoteIf you develop a compiled application as described in Create Standalone Instrument Panel App by Using Application Compiler, apply these workarounds to let the compiled application communicate with the target computer through the firewall."
            },
            {
                "heading": "Allow MATLAB for Public and Private Networks by Using Prompt",
                "content": "When you first try to connect to a target computer, Windows Defender Firewall prompts you to allow MATLAB to communicate on Private and Public networks. Make sure that both Private and Public options are selected. Only one is selected by default.\n\nClick Allow access."
            },
            {
                "heading": "Manually Allow MATLAB for Public and Private Networks",
                "content": "From the Windows\u00c2\u00ae Start menu, search Allow an app through Windows Firewall.\n\nClick the Allow an app through Windows Firewall option.\n\nScroll down in the Allowed apps and features list and find the MATLAB release that you are using. This rule should apply to the application path:\n\nC:\\Program Files\\MATLAB\\RXXXXx\\bin\\win64\\matlab.exe\n\nwhere RXXXXx is the release number. You can show this path by double-clicking on the rule. If missing, this rule can be added manually.\n\nIf both Private and Public check boxes are selected, see Configure Development-to-Target Computer Ethernet Interface as Private.\n\nClick the Change settings button and confirm the security dialog. Make sure that the Private and Public boxes are selected. A Domain option or others may be available, but these options are not relevant for the MATLAB network access configuration."
            },
            {
                "heading": "Configure Development-to-Target Computer Ethernet Interface as Private",
                "content": "You can use the Windows UI or PowerShell command window to configure development-to-target computer Ethernet interface as private.\n\nWindows UI Method\n\nThe Windows UI method is straightforward, but may not be available depending on your system configuration. If not, use the PowerShell Command Window Method.\n\nRight-click on the Wi-Fi\u00c2\u00ae or Ethernet network icon in the lower right corner of the Windows taskbar (next to the clock). Select Open Network & Internet settings. Under the Ethernet section, click Properties. Select the radio button for Private.\n\nPowerShell Command Window Method\n\nRight-click on the Windows Start menu and click the Windows PowerShell (Admin) selection. Run the command Get-NetConnectionProfile. Find the name of the Ethernet interface that you are using for development-to-target computer communication.Enter the command Set-NetConnectionProfile. Use the interface name that you find as the Name argument. Confirm the changes by running Get-NetConnectionProfile.\n\nFor example, if the interface is named Unidentified network, enter the command:\n\nSet-NetConnectionProfile -Name \"Unidentified network\" -NetworkCategory \"Private\""
            },
            {
                "heading": "Confirm Successful Configuration",
                "content": "To confirm successful configuration, in Simulink Real-Time Explorer or in the Simulink Editor on the Real-Time tab, click the Disconnected button. Confirm that the button label changes to Connected.\n\nIf the label does not change to Connected, the connection problem persists. Contact a systems administrator for further assistance. Administrator credentials may be required to configure the Windows Defender Firewall, or there may be another firewall on the development computer that requires configuration. A systems administrator may need to allow communications on specific ports or add more specific firewall rules."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-communication-failure-through-firewall.html#mw_ab9e2152-94a2-4e31-b407-0a612ebe3495",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/window-cannot-connect-to-target-error.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-windows-defender-firewall-blocked.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-windows-network-setup1.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-windows-network-setup2.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-windows-network-setup3.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-powershell-screen.png"
        ]
    },
    {
        "title": "Apply Functional Mock-up Units by Using Simulink Real-Time - MATLAB &amp; Simulink\n",
        "introduction": "FMU",
        "chunks": [
            {
                "heading": "FMU Limitations for Simulink Real-Time",
                "content": "These limitations apply:\n\nSimulink Real-Time supports FMU blocks for Co-Simulation mode.Simulink Real-Time does not support FMU blocks for Model Exchange mode.Simulink Real-Time generates a mask dialog box that contains both numeric-valued and string-valued parameters. Simulink Real-Time generates code for only numeric-valued parameters.\n\nTo convert a Simulink model that contains FMU blocks to a Simulink Real-Time model, set the model configuration parameters to values compatible with real-time execution:\n\nIn the Code Generation pane, set System target file to speedgoat.tlc or other Simulink Real-Time STF.In the Solver pane, set Type to Fixed-step.In the Solver pane, set Fixed-step size to a step size compatible with the real-time requirements of your model.Generate a shared object SO file by using the QNX Neutrino tools for the FMU. For more information, see slrealtime.fmu.compileFMUSources.\n\nYou can then build and download the model to a target computer and run the real-time application. This process loads the required FMU binary files on the target computer. For more information about creating the FMU files, see Compile Source Code for Functional Mock-up Units."
            },
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Open the Model",
                "content": "To open an example model that contains FMU blocks running in Simulink Real-Time, in the Command Window, type:\n\nmodel = 'slrt_ex_vanderpol'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF);"
            },
            {
                "heading": "Close the Model",
                "content": "bdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/apply-functional-mockup-units-with-simulink-real-time.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtApplyFunctionalMockupUnitsByUsingSimulinkRealTimeExample_01.png"
        ]
    },
    {
        "title": "Calibrate Parameters with ETAS Inca",
        "introduction": "This example shows how to view signals and tune parameters by using ETAS\u00c2\u00ae Inca. You must have already completed the steps in Prepare ASAP2 Data Description File. You also must be familiar with the ETAS Inca user interface. For information about the user interface, see the vendor documentation (www.etas.com).",
        "chunks": [
            {
                "heading": "Prepare Database",
                "content": "Open model slrt_ex_osc_cal.openExample('slrt_ex_osc_cal');Build and download real-time application slrt_ex_osc_cal. Start the real-time application by selecting REAL-TIME > RUN ON TARGET > Start Application.Disconnect the connection from MATLAB:tg = slrealtime disconnect(tg)You can then connect to third-party calibration tools.Open ETAS Inca.Add an ETAS Inca database by using the folder named SLRTDatabase.Add subfolders named Experiment, Project, and Workspace."
            },
            {
                "heading": "Prepare Project",
                "content": "Under folder Project, add an ECU project.When prompted, select A2L file slrt_ex_osc_cal.a2l, which is extracted from the project file. Ignore the prompt for a HEX file.If you change and rebuild the real-time application, delete the ECU project and recreate it with the new A2L file."
            },
            {
                "heading": "Prepare Workspace",
                "content": "Under folder Workspace, add workspace slrt_ex_osc_cal_wksp.Add project slrt_ex_osc_cal_slrt to workspace slrt_ex_osc_cal_wksp.When prompted, add an Ethernet system XCP device to the workspace.Configure the XCP device and initialize it. Autoconfigure the ETAS network. To upload data from the device hardware, use enhanced operations on memory pages.Data is uploaded from the real-time application on the target computer."
            },
            {
                "heading": "Prepare Experiment",
                "content": "Under folder Experiment, add experiment slrt_ex_osc_cal_exp.Add experiment slrt_ex_osc_cal_exp to workspace slrt_ex_osc_cal_wksp."
            },
            {
                "heading": "Configure Signals and Parameters",
                "content": "Start experiment slrt_ex_osc_cal_exp.To create graphic controls for the variables, add variables Kg, DampedOsc, SignalGenerator, L_1D, and L_2D.Add YT oscilloscopes for DampedOsc, SignalGenerator, L_1D, and L_2D.For each signal, set the sample time to the base sample time of the real-time application (250 \u00c2\u00b5s)."
            },
            {
                "heading": "Measure Signals and Calibrate Parameters",
                "content": "Start the ETAS Inca measurement.To shorten the ring time on DampedOsc, L_1D, and L_2D, set parameter Kg to 800.As required, toggle between the reference page and the working page.\n\nWhen using the Run on Target button on the Simulink Editor Real-Time tab to run the simulation, there is a time lag of a couple of seconds between the start of the real-time application on the target computer and the connect model operation on the development computer. If you are examining signals at or very close to application start, consider using the step-by-step approach to connect model and then using an SSH connection (for example, using PuTTY) start the real-time application. For more information, see Execute Real-Time Application in Simulink External Mode by Using Step-by-Step Commands and Execute Target Computer RTOS Commands at Target Computer Command Line."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/calibrate-by-using-etas-inca.html",
        "images": []
    },
    {
        "title": "Log or Stream Real-Time Signals by Using the Simulation Data Inspector",
        "introduction": "With the Simulation Data Inspector and Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2, you can send real-time signal data directly to the Simulation Data Inspector or by logging signal data by recording it through a File Log block. If streaming signal data directly, you view the output in real time as the application produces it. The application can produce more data than the Speedgoat\u00c2\u00ae target computer can transmit in real time to the MATLAB\u00c2\u00ae development computer. Data accumulates in the network buffer, and, if the buffer fills up, the RTOS drops data points. Streaming signal data directly does not support decimation or limit data points. To avoid dropped data points caused by network buffer overruns, you can use logging through a File Log block. When logging, you connect signals to File Log blocks in the model. In the real-time application, these blocks store data for the buffered signals on the target computer. At the end of execution, the real-time application transmits the data to the development computer for display in the Simulation Data Inspector. You can then view the most important signals immediately and view the buffered signals afterward. Logging signal data through a File Log block supports decimation or limit data points and supports conditional block execution semantics. Some examples are logging signal data by enabling data logging for a signal inside a for-iterator, function-call, or enabled/triggered subsystem. For more information, see Simulation Data Inspector and Real-Time Signal Logging is Affected by How Application is Run.",
        "chunks": [
            {
                "heading": "Set Up Model for Logging",
                "content": "To set up the model for logging signal data:\n\nOpen slrt_ex_osc.Select the MuxOut output signal, place your cursor over the signal, and select Enable Data Logging.TipConsider whether to configure the Logging sample time in the Instrumentation Properties for the logged signal. Use this property to set a lower sample time for signals that go into the Simulation Data Inspector while the simulation is running. Configuring this property can help makes the Simulation Data Inspector more responsive and easier to use.Double-click the File Log block. The Decimation value is 1."
            },
            {
                "heading": "Set Up Simulation Data Inspector",
                "content": "To set up the Simulation Data Inspector:\n\nOpen the Simulation Data Inspector (). Click Layout ().Select two horizontal displays."
            },
            {
                "heading": "View Simulation Data",
                "content": "To view the simulation data:\n\nBuild and download slrt_ex_osc.Start real-time execution.When the Simulation Data Inspector button glows , click the top display and select the Sum output signal.Click in the bottom display and select the Mux output signals.Stop real-time execution.When the Sum output appears, click Fit to View ().To zoom in on a time segment of interest, for example, 10.0\u00e2\u0080\u009310.1 s, click Zoom in Time () and use the mouse and mouse wheel.To save the Simulation Data Inspector session as an MLDATX file, click Save."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/log-or-stream-real-time-signals-by-using-simulation-data-inspector.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-sdi.png",
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-sdi-layout.png",
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-sdi-gold.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-sdi-immediate.png",
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-sdi-fit-to-view.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-sdi-deferred.png",
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-sdi-time-zoom.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-sdi-deferred-zoom.png"
        ]
    },
    {
        "title": "Call External Device Drivers",
        "introduction": "Device drivers for protocols and target hardware are essential to many real-time development projects. For example, you can have a working device driver that you want to integrate with algorithmic code that has to read data from and write data to the I/O device that the driver supports. The code generator can produce a single set of application source files from an algorithm model and integrated driver code written in C or C++. To call external device driver code from the Simulink\u00c2\u00ae environment, iterate through the tasks in this table.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/ecoder/ug/import-calls-to-external-hardware-specific-code-into-generated-algorithmic-code.html",
        "images": []
    },
    {
        "title": "Create Export-Function Model",
        "introduction": "The first step for creating independent functions in the generated code from a Simulink\u00c2\u00ae model is to define the functions in the context of an export-function model. For high-level information about export-function models, see Export-Function Models Overview. Function-Call Subsystem",
        "chunks": [
            {
                "heading": "Designate Model as Export-Function Model and Satisfy Export-Function Model Requirements",
                "content": "To designate a model as an export-function model:\n\nClick the canvas to clear the selection from any blocks. Open the Property Inspector and go to the Execution tab.Select the Set execution domain parameter.From the Domain list, select Export function.\n\nTo satisfy export-function model requirements:\n\nOpen the Configuration Parameters dialog box. On the Modeling tab, select Model Settings .In the Solver pane, set solver selection Type to Fixed-step, Solver to auto, and Fixed-step size to auto.In the Code Generation pane, set System target file to ert.tlc. This step requires an Embedded Coder\u00c2\u00ae license."
            },
            {
                "heading": "Create Model Algorithms",
                "content": "At the top level of an export-function model, functions are modeled within Function-Call Subsystem, function-call Model, Simulink Function, and S-Function blocks. This example uses Function-Call Subsystem blocks to model two functions.\n\nAdd two Function-Call Subsystem blocks.In the first subsystem, model a unit delay that increments by 0.05 at each time step.In the second subsystem, model the square of an input signal.At the top level of the model, add Inport and Outport blocks."
            },
            {
                "heading": "Add Function-Call Inputs",
                "content": "Inport blocks configured to output function-call signals control the execution of Function-Call Subsystem blocks during a simulation. The function-call Inport blocks also create an entry-point function in the generated code.\n\nConnect Inport blocks to the function() input ports on the Function-Call Subsystem blocks.Specify sample times. Open the Inport block dialog boxes and select the Signal Attributes tab. Select the Output function call parameter. Set Sample time for the delay function to 0.1 (100 ms) and the square function to 0.01 (10 ms).Setting the sample time is only for simulation testing. Sample time values do not affect the generated code. However, comments are added in the code identifying the rate you should call the functions.You could set the sample times to -1 and allow any function-call rate (periodic or aperiodic) during simulation. By setting sample times, the software checks the calling rate with the specified rate and displays an error if there is a mismatch.Rename blocks. The names help to identify signals in the generated code.Update the model (Ctrl+D). Dotted-and-dashed lines identify function-call signals."
            },
            {
                "heading": "Export-Function Model with Unit Delay and Square Functions",
                "content": "Open Script\n\nTo open the completed export-function model, open the model named export_function_model.\n\nThe model contains two function-call subsystems. One subsystem contains a Unit Delay block, while the other subsystem contains a Square block."
            },
            {
                "heading": "Test Model",
                "content": "After you create an export-function model, test it with simulations. Choose one of these simulation testing methods:\n\nTest Export-Function Model Simulation Using Input MatrixTest Export-Function Model Simulation Using Function-Call GeneratorsTest Export-Function Model Simulation Using Stateflow ChartTest Export-Function Model Simulation Using Schedule Editor"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/create-export-function-model.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/icon_model_settings.png",
            "https://in.mathworks.com/help/simulink/ug/export_function_model_create_model_delay.png",
            "https://in.mathworks.com/help/simulink/ug/export_function_model_create_model_square.png",
            "https://in.mathworks.com/help/simulink/ug/export_function_model_create_model_functions.png",
            "https://in.mathworks.com/help/simulink/ug/export_function_model_create_model_inports.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ExportfunctionModelWithUnitDelayAndSquareFunctionsExample_01.png"
        ]
    },
    {
        "title": "Programmatically Specify Block Parameters and Properties",
        "introduction": "Block parameters typically define model dynamics and mathematics. They also let you configure the appearance of the block. Whether a block has parameters that you can set and the nature of those parameters is specific to each block. Block properties typically describe fundamental block characteristics and help determine when the block executes. Block properties include block annotations, callbacks that execute when a block event occurs, execution order priority, and tags that help identify the block. To write scripts that create and modify models, use the get_param and set_param functions to query and modify block property and parameter values. For example, suppose you have a Gain block in a model named mymodel. For background information on programmatic modeling, see Programmatic Modeling Basics. For information about how to specify paths that contain multiline names or special characters, see Specify Paths That Contain Multiline Names and Special Characters. get_param | set_param",
        "chunks": [
            {
                "heading": "Block-Specific Parameters",
                "content": "Most block-specific parameters are documented on the page that documents the block. For example, the parameters of the Gain block are documented on the Gain block reference page. For programmatic information on a parameter, expand the corresponding parameter entry on the block reference page.\n\nFor a script that gets and sets the values of the block-specific parameters, select a block and open the Property Inspector. In the Property Inspector, click Script Reference. The script gets the parameter values with the get_param function and sets the parameter values with the set_param function. If you change the value of a parameter, the script updates to reflect the new value.\n\nTo get a list of programmatic block parameters, select a block. Then, query one of these properties with the get_param function.\n\nDialogParameters \u00e2\u0080\u0094 Block-specific parameters for an unmasked block, or mask parameters for a masked block.IntrinsicDialogParameters \u00e2\u0080\u0094 Block-specific parameters for masked or unmasked blocks.ObjectParameters \u00e2\u0080\u0094 Block-specific parameters and common block properties.\n\nSome of the returned parameters and properties can be for internal use only. When a block property or parameter is undocumented, consider that parameter to be for internal use only."
            },
            {
                "heading": "Common Block Properties",
                "content": "A common property of Simulink\u00c2\u00ae objects is the read-only Type property. For blocks, this property returns 'block'.\n\nEach block has a block type. For some blocks, the block type is the same as the block name in the Library Browser. For example, the block type of a Gain block is Gain. For other blocks, the block type differs from the block name in the Library Browser. For example, the block type of an Add block is Sum.\n\nTo get the block type for blocks without a mask, query the read-only BlockType property with the get_param function.To get the block type for blocks with a mask, query the MaskType property with the get_param function. Typically, masked blocks have a BlockType of SubSystem.\n\nFor information about the properties of a masked block, see Mask Parameters.\n\nFor information about block callback properties, see Block Callbacks.\n\nThese tables list additional properties common to Simulink blocks.\n\nCommon Block Properties: Names and HandlesPropertyDescriptionValuesHandle (read-only)Numeric block handle.Assign the handle to a variable and use that variable name to specify the block. The handle applies to only the current MATLAB\u00c2\u00ae session.double numberInputSignalNames (read-only)Names of input signals.cell arrayLineHandles (read-only)Handles of lines connected to block.Assign a line handle to a variable and use that variable name to specify the line. The handle applies to only the current MATLAB session.structureNameBlock or signal name.To specify a signal name, use the corresponding port or line handle.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport(1); set_param(out1,Name=\"NewName\"); To propagate the signal name, compile the model.set_param(gcs,SimulationCommand=\"update\");Alternatively, to name an output signal of a block, use SignalNameFromLabel.character vectorOutputSignalNames (read-only)Names of output signals.cell arrayParent (read-only)Name of the system that owns the block.character vectorPortHandles (read-only)Handles of the block ports.Assign a port handle to a variable and use that variable name to specify the port. The handle applies to only the current MATLAB session.The structure has these fields: Inport \u00e2\u0080\u0094 Handles of the input portsOutport \u00e2\u0080\u0094 Handles of the output portsEnable \u00e2\u0080\u0094 Handle of the enable portTrigger \u00e2\u0080\u0094 Handle of the trigger portState \u00e2\u0080\u0094 Handle of the state portLConn \u00e2\u0080\u0094 Handles of the left connection ports for blocks that support physical modeling toolsRConn \u00e2\u0080\u0094 Handles of the right connection ports for blocks that support physical modeling toolsIfaction \u00e2\u0080\u0094 Handle of the action portReset \u00e2\u0080\u0094 Handle of the reset portEvent \u00e2\u0080\u0094 Handles of the subsystem reinitialize event ports structure array\n\nCommon Block Properties: PortsPropertyDescriptionValuesCompiledBusType (read-only)Returns whether the port connects to a virtual bus or nonvirtual bus.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); bt = get_param(out1,\"CompiledBusType\") feval(gcs,[],[],[],\"term\");See Display Bus Information.'NOT_BUS' | 'VIRTUAL_BUS' | 'NON_VIRTUAL_BUS'CompiledPortComplexSignals (read-only)Complexity of port signals after updating diagram.To get compiled information about the ports, compile the model.feval(gcs,[],[],[],\"compile\"); cs = get_param(gcb,\"CompiledPortComplexSignals\") feval(gcs,[],[],[],\"term\");structure arrayCompiledPortDataTypes (read-only)Data types of port signals after updating diagram.To get compiled information about the ports, compile the model.feval(gcs,[],[],[],\"compile\"); dt = get_param(gcb,\"CompiledPortDataTypes\") feval(gcs,[],[],[],\"term\");structure arrayCompiledPortDesignMin (read-only)Design minimum of port signals after updating diagram.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); min = get_param(out1,\"CompiledPortDesignMin\") feval(gcs,[],[],[],\"term\"); structure arrayCompiledPortDesignMax (read-only)Design maximum of port signals at compile time.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); max = get_param(out1,\"CompiledPortDesignMax\") feval(gcs,[],[],[],\"term\"); structure arrayCompiledPortDimensions (read-only)Dimensions of port signals after updating diagram.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); d = get_param(out1,\"CompiledPortDimensions\") feval(gcs,[],[],[],\"term\"); For details, see Get Compiled Port Dimensions.numeric arrayCompiledPortDimensionsMode (read-only)Indication of whether the port signal has a variable size after updating diagram. 0 indicates the signal does not have a variable size. 1 indicates the signal has a variable size.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); dm = get_param(out1,\"CompiledPortDimensionsMode\") feval(gcs,[],[],[],\"term\"); See Determine Whether Signal Line Has Variable Size.double numberCompiledPortFrameData (read-only)Frame mode of port signals after updating diagram.To get compiled information about the port, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); fd = get_param(out1,\"CompiledPortFrameData\") feval(gcs,[],[],[],\"term\"); structure arrayCompiledPortUnits (read-only)Structure array of block port units after updating diagram.To get compiled information about the port, compile the model.feval(gcs,[],[],[],\"compile\"); units = get_param(gcb,\"CompiledPortUnits\") feval(gcs,[],[],[],\"term\"); structure arrayCompiledPortWidths (read-only)Structure of port widths after updating diagram.To get compiled information about the port, compile the model.feval(gcs,[],[],[],\"compile\"); units = get_param(gcb,\"CompiledPortWidths\") feval(gcs,[],[],[],\"term\"); structure arrayIOSignalStringsBlock paths to objects that are connected to the Viewers and Generators Manager. The software saves these paths when the model is saved.listPortConnectivity (read-only)Array of structures, each of which describes one of the block input or output ports. Each port structure has these fields:Type \u00e2\u0080\u0094 Port type, port number, or both. The value can be:n, where n is the number of the port for data ports'enable' if the port is an enable port'trigger' if the port is a trigger port'state' for state ports'ifaction' for action ports'LConn#' for a left connection port where # is the port number'RConn#' for a right connection port where # is the port number'event' for reinitialize event ports of subsystemsPosition \u00e2\u0080\u0094 A two-element vector, [x y], that specifies the port position.SrcBlock \u00e2\u0080\u0094 Handle of the block connected to this port. For output ports, the value is []. For unconnected input ports, the value is -1. The SrcBlock property is a valid source handle for Variant Subsystem blocks. SrcPort \u00e2\u0080\u0094 Number of the port connected to this port, starting at zero. For both output ports and unconnected input ports, the value is [].DstBlock \u00e2\u0080\u0094 Handle of the block to which this port is connected. For input ports, the value is []. For unconnected output ports, the value is a 1-by-0 empty matrix.DstPort \u00e2\u0080\u0094 Number of the port to which this port is connected, starting at zero. For input ports, the value is []. For unconnected output ports, the value is a 1-by-0 empty matrix. For Simscape\u00e2\u0084\u00a2 blocks, the value is port handles.structure arrayPortRotationType (read-only)Type of port rotation used by this block.'default' | 'physical'Ports (read-only)Number of each kind of port this block has.The order of the elements in the returned vector corresponds to these port types: Inport \u00e2\u0080\u0094 Input portOutport \u00e2\u0080\u0094 Output portEnable \u00e2\u0080\u0094 Enable portTrigger \u00e2\u0080\u0094 Trigger portState \u00e2\u0080\u0094 State portLConn \u00e2\u0080\u0094 Left connection portRConn \u00e2\u0080\u0094 Right connection portIfaction \u00e2\u0080\u0094 Action portReset \u00e2\u0080\u0094 Reset event portEvent \u00e2\u0080\u0094 Reinitialize event port vectorSignalHierarchy (read-only)If the signal is a bus, returns the name and hierarchy of the elements in the bus.To get the signal hierarchy, use the corresponding port or line handle and compile the model.ports = get_param(gcb,\"PortHandles\"); out1 = ports.Outport; feval(gcs,[],[],[],\"compile\"); sh = get_param(out1,\"SignalHierarchy\") feval(gcs,[],[],[],\"term\"); See Display Bus Information.values that reflect the structure of the signal\n\nCommon Block Properties: BehaviorPropertyDescriptionValuesCommentedExclude block from simulation.'off' (default) | 'on' | 'through'CompiledIsActive (read-only)Specifies whether the block status is active at compile time.CompiledIsActive returns off if any one of these conditions is true at compile time:Block is an inactive path of an inline variant.Block is an inactive choice of a variant subsystem.Block is in a subsystem that is commented out.Block is inactive due to a condition propagated from a variant subsystem.CompiledisActive returns off for inactive choices and returns on for active choices of a variant subsystem.'off' | 'on'CompiledSampleTime (read-only)Block sample time after updating diagram.To get the sample time, compile the model.feval(gcs,[],[],[],\"compile\"); ts = get_param(gcb,\"CompiledSampleTime\") feval(gcs,[],[],[],\"term\"); vector or cell array of sample time and offset time, respectivelyIsStateOwnerBlock (read-only)Indicates whether the block is a supported state owner block that can be used with the State Reader and State Writer blocks.'off' | 'on'ExtModeLoggingSupported (read-only)Enable a block to support uploading of signal data in external mode, for example, with a scope block.'off' (default) | 'on'ExtModeLoggingTrigEnable a block to act as the trigger block for external mode signal uploading.'off' (default) | 'on'ExtModeUploadOptionEnable a block to upload signal data in external mode when the Select all check box on the External Signal & Triggering dialog box is not selected. A value of log indicates the block uploads signals. A value of none indicates the block does not upload signals. The value monitor is currently not in use. If the Select all check box on the External Signal & Triggering dialog box is selected, it overrides this parameter setting.'none' (default) | 'log' | 'monitor'SelectedStatus of whether or not block is selected.'on' (default) | 'off'StatePerturbationForJacobianState perturbation size to use during linearization. For details, see Change Perturbation Level of Blocks Perturbed During Linearization (Simulink Control Design).character vectorPrioritySpecifies the block order of execution relative to other blocks in the same model. Set by the Priority field on the General pane of the Block Properties dialog box.'' (default) | character vector\n\nCommon Block Properties: AppearancePropertyDescriptionValuesBackgroundColorBlock background color.'black' | 'white' | 'red' | 'green' | 'blue' | 'cyan' | 'magenta' | 'yellow' | 'gray' | 'lightBlue' | 'orange' | 'darkGreen' | '[r,g,b]' | '[r,g,b,a]', where r, g, and b are the red, green, and blue values of the color in the range 0.0 to 1.0. If specified, the alpha value (a) is ignored.BlockMirrorBlock mirror.'off' (default) | 'on'BlockRotationBlock rotation angle.For 0 degrees rotation, the value is 0. For 270 degree rotation, the value is 270.double numberDropShadowDisplay drop shadow.'off' (default) | 'on'FontAngleFont angle.'auto' (default) | 'normal' | 'italic' | 'oblique'FontNameFont name.character arrayFontSizeFont size.A value of -1 specifies that this block inherits the font size specified by the DefaultBlockFontSize model parameter.'-1' (default) | realFontWeightFont weight.'auto' (default) | 'light' | 'normal' | 'demi' | 'bold'ForegroundColorForeground color of block icon.The value changes if it is too similar to the canvas color specified by the ScreenColor parameter. To get the actual value, use the get_param function. 'black' | 'white' | 'red' | 'green' | 'blue' | 'cyan' | 'magenta' | 'yellow' | 'gray' | 'lightBlue' | 'orange' | 'darkGreen' | '[r,g,b]' | '[r,g,b,a]', where r, g, and b are the red, green, and blue values of the color in the range 0.0 to 1.0. If specified, the alpha value (a) is ignored. HideAutomaticNameSpecify whether the block name given automatically by the Simulink Editor displays in the model.For information on using this parameter, see Hide or Display Block Names.'on' (default) | 'off'NamePlacementPosition of block name.'normal' (default) | 'alternate'OrientationDirection block faces.'right' (default) | 'left' | 'up' | 'down'PositionPosition of block in model window.The origin is the upper-left corner of the Simulink Editor canvas before any canvas resizing. Supported coordinates are between -1073740824 and 1073740823, inclusive. Positive values are to the right of and down from the origin. Negative values are to the left of and up from the origin.To help with block alignment, the position you set can differ from the actual block position by a few pixels. To return the actual position, use the get_param function.vector of coordinates, in pixels: [left top right bottom]ShowNameDisplay or hide block name.For information on using this parameter, see Hide or Display Block Names.'on' (default) | 'off'\n\nCommon Block Properties: MetadataPropertyDescriptionValuesAttributesFormatStringBlock annotation text that corresponds to block properties.character vectorBlockDescription (read-only)Block description shown at the top of the block parameters dialog box or property inspector.character arrayDescriptionDescription of block. Set by the Description field in the General pane of the Block Properties dialog box.text and tokensRTWDataUser specified data, used by Simulink Coder\u00e2\u0084\u00a2 software. Intended only for use with user written S-functions. For details, see S-Function RTWdata (Simulink Coder).structure of character vectorsTagText that appears in the block label that Simulink software generates. Set by the Tag field on the General pane of the Block Properties dialog box. '' (default) | character vector UserDataUser-specified data that can have any MATLAB data type.'[]' (default)UserDataPersistentStatus of whether or not UserData will be saved in the model file.'off' (default) | 'on'\n\nCommon Block Properties: LibrariesPropertyDescriptionValuesAncestorBlockName of the library block that the block is linked to for blocks with a disabled link.character vectorBlockKeywordsAssociates one or more keywords with a custom library block.character vector | string scalar | string arrayLibraryVersion For a linked block, the initial value of this property is the ModelVersion of the library at the time the link was created. The value updates with increments in the model version of the library.'1.1' (default) | character vector LinkDataArray of details about changes to the blocks inside the link that differ between a parameterized link and its library, listing the block names and parameter values. Use [] to reset to deparameterized, for example, set_param(gcb,'linkData',[]).cell arrayLinkStatusLink status of block. Updates out-of-date linked blocks when queried using the get_param function.See Control Linked Blocks Programmatically.'none' | 'resolved' | 'unresolved' | 'implicit' | 'inactive' | 'restore' | 'propagate' | 'propagateHierarchy' | 'restoreHierarchy' ReferenceBlockName of the library block to which this block links.'' (default) | character vectorStaticLinkStatus (read-only)Link status of block. Does not update out-of-date linked blocks when queried using the get_param function. See also LinkStatus.'none' | 'resolved' | 'unresolved' | 'implicit' | 'inactive' | 'restore' | 'propagate' | 'propagateHierarchy' | 'restoreHierarchy'\n\nSome common block properties are for internal use only. For example, these properties are for internal use only:\n\nDataTypeOverride_CompiledDiagnosticsHiliteAncestorsIOTypeMinMaxOverflowLogging_CompiledModelParamTableInfoRequirementInfo"
            },
            {
                "heading": "Maximum Size Limits for Block Parameter Values",
                "content": "For block parameters that accept array values, the number of elements in the array cannot exceed what int_T can represent. This limitation applies to both simulation and Simulink Coder code generation.\n\nThe maximum number of characters that a parameter edit field can contain is 49,000."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/slref/block-parameters-and-properties.html",
        "images": [
            "https://in.mathworks.com/help/simulink/slref/property-inspector-script-reference.gif"
        ]
    },
    {
        "title": "Create Structures in MATLAB Function Blocks",
        "introduction": "You can create and use structures for input, output, local, persistent, or parameter variables in MATLAB Function blocks. Structures in MATLAB Function blocks can contain fields of any type and size, including mux signals, buses, and arrays of structures. Before you create a structure, you must decide the scope of the MATLAB Function variable. See Create and Define MATLAB Function Block Variables. MATLAB Function",
        "chunks": [
            {
                "heading": "Input Variables",
                "content": "When you create structure for input variables, the MATLAB Function block determines the type, size, and complexity of the structure from the input signal. To define a structure for an input variable:\n\nCreate a Simulink.Bus object in the base workspace that defines the structure.Identify or add an input variable to the MATLAB Function block. Input variables have the Scope property set to Input.Set the variable Type property to Inherit: Same as Simulink or Bus: <object name>. For <object name>, enter the name of the Simulink.Bus object that defines the structure properties.\n\nBuses in a Simulink\u00c2\u00ae model appear inside MATLAB Function blocks as structures."
            },
            {
                "heading": "Output Variables",
                "content": "When you create structures for outputs variables, you create a Simulink.Bus object and then define the type, size, and complexity of the variable in the MATLAB\u00c2\u00ae function code. The properties in the code and the object must match. To define structures for outputs variables:\n\nCreate a Simulink.Bus object in the base workspace to define the structure.Identify or add output variables to the MATLAB Function block. Output variables have the Scope property set to Output.Set the Type property to Bus: <object name>. For <object name>, enter the name of the Simulink.Bus object that defines the structure.Initialize the output structure as a variable in the MATLAB function, as described in Structure Definition for Code Generation. Match the structure configuration of the output variable to the Simulink.Bus object, including the number, type, and sizes of each element.\n\nStructure outputs from the MATLAB Function block appear as buses in Simulink models. MATLAB Function blocks support nonvirtual bus outputs but do not support virtual bus outputs."
            },
            {
                "heading": "Local Variables",
                "content": "To define local variables that are structures, define the structure in the MATLAB function, as described in Structure Definition for Code Generation. You do not define local variables in the Symbols pane, and you cannot modify the properties in the Property Inspector. By default, MATLAB Function blocks clear local variable values after each time step."
            },
            {
                "heading": "Persistent Variables",
                "content": "To define persistent variables that are structures, declare the variable as persistent in the function code. See persistent and Initialize Persistent Variables in MATLAB Functions. For example, to declare the persistent variable, myVar, enter:\n\npersistent myVar\n\nThen define the variable structure in the MATLAB function. You do not define persistent variables in the Symbols pane, and they do not have properties that you can modify in the Property Inspector."
            },
            {
                "heading": "Parameter Variables",
                "content": "To define parameter variables that are structures:\n\nCreate a structure variable in the base workspace, model workspace, or a masked subsystem that contains the MATLAB Function block.Identify or add parameter variables to the MATLAB Function block. See Use Data in Multiple MATLAB Function Blocks by Defining Parameter Variables. Parameter variables have the Scope property set to Parameter. Match the names of the variables."
            },
            {
                "heading": "fimath Properties of Nontunable Structure Parameters",
                "content": "The initial values of the structure determine the fimath properties for nontunable structure parameters that contain fixed-point values. The fimath properties of the MATLAB Function block that you define in the Property Inspector do not specify these values."
            },
            {
                "heading": "Global Variables",
                "content": "You can define global variables in MATLAB Function blocks to access simulation data from Simulink.Signal objects or Data Store Memory blocks. See Access Data Store Data in MATLAB Function Blocks. To define global variables that are structures:\n\nCreate a Simulink.Bus object in the base workspace to define the structure.Identify or add global variables to the MATLAB Function block. Global variables have the Scope property set to Data Store Memory. Variables with this scope inherit their properties from the associated data in the Data Store Memory block or Simulink.Signal object.Declare the global variable in the function code. For example, to declare the global variable myVar, enter:global myVar\n\nFor an example, see Write Buses from Data Store Memory to a MATLAB Function Block."
            },
            {
                "heading": "Assign Values to Structures and Fields",
                "content": "After you define the structure, you can assign values to the structure, substructure, or field of the structure variable. Follow these guidelines:\n\nOperationConditionsAssign one structure to another structureYou must define each structure with the same number, type, and size of fields, either as Simulink.Bus objects in the base workspace or locally as implicit structure declarations.Assign one structure to a substructure of a different structureYou must define the structure with the same number, type, and size of fields as the substructure, either as Simulink.Bus objects in the base workspace or locally as a structure declaration.Assign an element of one structure to an element of another structureThe elements must have the same type and size.\n\nFor example, this table describes valid and invalid structure assignments based on the specifications for the model described in Read and Write Buses with a MATLAB Function Block:\n\nAssignmentValid or Invalid?Rationaleoutbus = mystruct;ValidThe Simulink.Bus object MainBus defines the structure outbus and the local definition of mystruct matches the field properties of MainBus.outbus = inbus;ValidThe Simulink.Bus object, MainBus, defines both outbus and inbus.outbus1 = inbus.ele3;ValidBecause the Simulink.Bus object SubBus defines both outbus1 and inbus.ele3, they have the same type and size.outbus1 = inbus;InvalidA different Simulink.Bus object defines structure outbus1 and inbus."
            },
            {
                "heading": "Limitations for Structures in MATLAB Function Blocks",
                "content": "You cannot use structures that contain cell arrays or classes for Simulink signals, parameters, or data store memory.You cannot use variable-size data with arrays of buses. See Group Nonvirtual Buses in Arrays of Buses."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/create-structures-in-matlab-function-blocks.html",
        "images": []
    },
    {
        "title": "Apply Persistent Variables in Real-Time Applications - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Examine Persistent Variables in the Model",
                "content": "The model slrt_ex_persist computes the final position by using information from the speed input and initial position input. The Persistent Variable Read block variable position provides the initial value for the first run of the application from variable default value when the variable position does not exist on target computer. When the application stops, the Persistent Variable Write block variable position stores the final position from the run. The real-time application uses this value as the initial position for the next run."
            },
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Build Real-Time Application",
                "content": "To open the model and examine the Persistent Variable block values, in the Command Window, type:\n\nmodel = 'slrt_ex_persist'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF)"
            },
            {
                "heading": "Build and Load the Real-Time Application",
                "content": "To build and load the real-time application, in the Command Window, type:\n\nevalc('slbuild(model)'); load(tg,model);"
            },
            {
                "heading": "Initial Value of Persistent Variable",
                "content": "The initial value of the persistent variable position when it does not exist on target computer is 0.\n\nThe value is set by the Default value parameter of the Persistent Variable Read block."
            },
            {
                "heading": "Observe How Persistent Variable Changes in First Run",
                "content": "To run the real-time application, in the Command Window, type:\n\nstart(tg);\n\nCheck the value of the persistent variable after the stop time expires and the real-time application stops.\n\npause(5); myPersistVars = getPersistentVariables(tg)\n\nmyPersistVars = struct with fields: position: 20"
            },
            {
                "heading": "Observe How Persistent Variable Changes in Second Run",
                "content": "To run the real-time application, in the Command Window, type:\n\nload(tg,model); start(tg);\n\nCheck the value of the persistent variable after the stop time expires and the real-time application stops.\n\npause(5); myPersistVars = getPersistentVariables(tg)\n\nmyPersistVars = struct with fields: position: 40"
            },
            {
                "heading": "Clear the Persistent Variable Values",
                "content": "Because the persistent variable values remain on the target computer after the real-time application stops, you must clear the retained values if the retained values are not needed. These steps show a way to clear the position persistent variable values.\n\nmyNewPersistVars = rmfield(myPersistVars,'position'); setPersistentVariables(tg,myNewPersistVars); myPersistVars = getPersistentVariables(tg)\n\nmyPersistVars = []\n\nYou can also remove all persistent variable values by using this command.\n\nsetPersistentVariables(tg, []);"
            },
            {
                "heading": "Preserve Persistent Variable Data by Safe Shutdown of Target Computer",
                "content": "The previous steps demonstrate how Persistent Variable values are stored when the real-time application stops and are reloaded when the real-time application starts. These variables are also retained when the target computer is shut down.\n\nTarget computers can handle being shut down by turning off power to the computer, but using this approach is not the best practice for the target computer. Also, if you just turn off the target computer while the real-time application is running, you can lose the last few seconds of data for the Persistent Variables.\n\nTo preserve all persistent variable data and safely shut down the target computer:\n\n1. On the target computer, stop the real-time application (for example, stop(tg)). The values for persistent variables are stored.\n\n2. Open a system terminal window.\n\n3. On the development computer, for user slrt and target computer IP address 192.168.7.5, type command: ssh slrt@192.168.7.5\n\n4. Complete the login with password: slrt\n\n5. At the target computer system prompt that appears in the terminal window, shut down the target computer by using QNX Neutrino command: shutdown -S system\n\n6. After the shutdown command runs, you can safely turn off power to the target computer.\n\nFor more shutdown command info, see shutdown in the QNX Neutrino documentation."
            },
            {
                "heading": "Close All Files",
                "content": "bdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/apply-persistent-variables-in-real-time-applications.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/ApplyPersistentVariablesInRealTimeAppsExample_01.png"
        ]
    },
    {
        "title": "Create Nonvirtual Buses",
        "introduction": "A nonvirtual bus is analogous to a structure in C code. Use nonvirtual buses to: A Simulink.Bus object data type must define the bus you want to make nonvirtual. A bus becomes nonvirtual when you select a block parameter such as Output as nonvirtual bus. Making the bus nonvirtual causes simulation and code generation to apply the structure defined by the bus object. When the bus is virtual, the bus object only validates the properties of the bus. To simulate a model that contains nonvirtual buses, the referenced bus objects must be in the base workspace or a data dictionary used by the model. For more information, see Specify Bus Properties with Bus Objects. Nonvirtual buses also require all elements of the bus to have the same sample time. For more information, see Modify Sample Times for Nonvirtual Buses. The way to create nonvirtual buses differs based on the location of the bus and the block that creates the bus: To focus on fundamental steps, the examples are simple. However, buses are most useful when you have many signals to combine.",
        "chunks": [
            {
                "heading": "Create Nonvirtual Buses Within Component",
                "content": "Open Live Script\n\nYou can use Bus Creator blocks to create nonvirtual buses within components.\n\nOpen and compile the model named BusHierarchy, which uses Bus Creator blocks to create a hierarchy of virtual buses. To compile the model, on the Modeling tab of the Simulink\u00c2\u00ae Toolstrip, click Update Model or Run. Compiling the model updates the line styles, which you can use to visually identify buses.\n\nmdl = BusHierarchy; open_system(mdl) set_param(mdl,SimulationCommand=\"Update\")\n\nTo create this model, see Group Signal Lines Within Component.\n\nThe virtual buses in this model are not defined by Simulink.Bus objects. To change the output of the Bus Creator blocks to nonvirtual buses, you must have bus objects that match the bus hierarchy.\n\nTo create the bus objects that correspond to TopBus and NestedBus, use the Simulink.Bus.createObject function. In the MATLAB\u00c2\u00ae Command Window, enter this command.\n\nSimulink.Bus.createObject(\"BusHierarchy\",\"BusHierarchy/Bus Creator1\");\n\nThis function creates the bus object that corresponds to the output bus of the specified block. If the output bus contains nested buses, the function also creates bus objects that correspond to the nested buses. In this example, the function creates two bus objects that are named after the corresponding buses, TopBus and NestedBus.\n\nTo view the bus objects, open the Type Editor. In the Simulink Toolstrip, on the Modeling tab, in the Design gallery, click Type Editor. To expand an external data source or bus, click the arrow next to its name.\n\nNow that you have bus objects that correspond to the nonvirtual buses you want to create, create the nonvirtual buses. In the Simulink Editor, double-click the Bus Creator block named Bus Creator1. In the Block Parameters dialog box, set Output data type to Bus: TopBus, select the Output as nonvirtual bus check box, and click OK. TopBus is now a nonvirtual bus, while NestedBus remains a virtual bus. To identify the nonvirtual bus by line style, compile the model.\n\nDouble-click the block named Bus Creator. In the Block Parameters dialog box, set Output data type to Bus: NestedBus, select the Output as nonvirtual bus check box, and click OK. NestedBus is now a nonvirtual bus. To update its line style, compile the model.\n\nIf you do not save the bus objects, then you must recreate the bus objects when you reopen the model. For information on how to save the bus objects, see Specify Bus Properties with Bus Objects."
            },
            {
                "heading": "Create Nonvirtual Buses at Interfaces",
                "content": "Open Live Script\n\nTo create a nonvirtual bus at an interface, connect the bus elements to Out Bus Element blocks and specify that the output bus is nonvirtual.\n\nOpen the model named BusOutput, which uses three Out Bus Element blocks to create a virtual bus at the output port.\n\nTo create this model, see Connect Multiple Output Signals to a Port.\n\nNonvirtual buses require a Simulink.Bus object data type. Create the bus object that corresponds to the output bus.\n\nIn the Simulink\u00c2\u00ae Toolstrip, on the Modeling tab, in the Design gallery, select Type Editor.In the Type Editor, create bus objects named Interface and Sinusoidal.For each bus object, create the Simulink.BusElement objects that correspond to the elements of the buses. In Sinusoidal, create elements named Chirp and Sine. In Interface, create elements named NestedBus and Step.Specify a bus object data type for any nested buses. For NestedBus, set Data type to Bus: Sinusoidal.\n\nTo output a nonvirtual bus, specify the bus object data type and bus virtuality.\n\nOpen the dialog box for the port by double-clicking one of the Out Bus Element blocks.In the tree hierarchy of the dialog box, pause on OutBus. Then, click the pencil icon that appears next to OutBus.Specify the bus object data type. Set Data type to Bus: Interface.In the tree hierarchy of the dialog box, click the signal attributes that now appear next to OutBus.Specify the bus virtuality. Set Bus virtuality to nonvirtual.\n\nThe output of the model is a nonvirtual bus. To see the nonvirtual bus, reference the model in another model or move the Out Bus Element blocks into a subsystem. The line styles update when you compile the model. To compile the model, on the Modeling tab of the Simulink Toolstrip, click Update Model or Run.\n\nIf you do not save the bus objects, you must recreate the bus objects when you reopen the model. For information on how to save the bus objects, see Specify Bus Properties with Bus Objects.\n\nIn Bus Element blocks use the Bus virtuality parameter to determine whether they inherit or define the bus virtuality. If the block defines the bus virtuality and the virtuality of the input bus does not match, compiling the model produces an error.\n\nRoot Inport and Outport blocks can also create nonvirtual buses at interfaces. To specify the bus virtuality:\n\nFor a root Inport block, on the Signal Attributes tab of the dialog box, select Output as nonvirtual bus.For a root Outport block, on the Signal Attributes tab of the dialog box, select Output as nonvirtual bus in parent model."
            },
            {
                "heading": "Convert Virtual Bus to Nonvirtual Bus",
                "content": "Open Live Script\n\nYou can convert a virtual bus to a nonvirtual bus anywhere within a model by using a Signal Conversion block.\n\nOpen and compile the model named BusConversion, which contains a virtual bus hierarchy created by Bus Creator blocks. To compile the model, on the Modeling tab of the Simulink Toolstrip, click Update Model or Run. Compiling the model updates the line styles, which you can use to visually identify buses.\n\nTo define the buses and support conversion to nonvirtual buses, the Bus Creator blocks specify Simulink.Bus object data types. To create the bus objects in the base workspace when the model is loaded, the model uses the PreLoadFcn callback.\n\nTo view the callback, in the Simulink Toolstrip, on the Modeling tab, click Model Settings > Model Properties. In the Model Properties dialog box, open the Callbacks tab and select the PreLoadFcn model callback.\n\nTo view the bus objects, open the Type Editor.\n\nTo convert a virtual bus to a nonvirtual bus, use a To Nonvirtual Bus block, which is a preconfigured version of the Signal Conversion block that has Output set to Nonvirtual bus.\n\nIn the example model:\n\nAdd a To Nonvirtual Bus block to the model.Drag the To Nonvirtual Bus block onto the line between the Bus Creator block named Bus Creator1 and the Scope block. When you drag the block onto the line, the block connects to the line at both ends.\n\nSuppose the data type of the bus you want to convert is not specified by a bus object. You would need to perform these additional actions:\n\nCreate the corresponding bus objects.Specify the bus object data type for the bus. For example, set the Data type parameter of the To Nonvirtual Bus block to the bus object that corresponds to the input bus.\n\nThe input to the To Nonvirtual Bus block is a virtual bus, and the output is a nonvirtual bus. To see the nonvirtual bus line style, compile the model."
            },
            {
                "heading": "Create Nonvirtual Bus from MATLAB Structure",
                "content": "Open Live Script\n\nYou can use a Constant block to compactly represent a nonvirtual bus with constant-valued elements.\n\nOn the Constant block, specify:\n\nA MATLAB structure for Constant value.A Simulink.Bus object as the Output data type.\n\nConstant blocks only support MATLAB structures when the output data type is a Bus object.\n\nFor example, define a MATLAB structure named const_param_struct with elements named Offset, Gain, and Threshold.\n\nconst_param_struct.Offset = 197; const_param_struct.Gain = 4.32; const_param_struct.Threshold = 795.68;\n\nDefine the corresponding Bus object data type.\n\nSimulink.Bus.createObject(const_param_struct)\n\nThe new Bus object uses the default name slBus1.\n\nOpen and simulate the example model, which contains a Constant block with Constant value set to const_param_struct and Output data type set to Bus: slBus1.\n\nopen_system('NonvirtualBusFromStructModel') sim('NonvirtualBusFromStructModel');\n\nThe output of the Constant block is a nonvirtual bus."
            },
            {
                "heading": "Blocks",
                "content": "\u2022 Bus Creator"
            },
            {
                "heading": "Objects",
                "content": "\u2022 Simulink.Bus\n\n\u2022 Composite Interface Guidelines\n\u2022 Programmatically Create Bus Element Ports\n\u2022 Specify Bus Properties with Bus Objects\n\u2022 Modify Sample Times for Nonvirtual Buses\n\u2022 Inspect Generated Code for Nonvirtual Buses\n\u2022 Create Structures in MATLAB Function Blocks"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/create-nonvirtual-buses.html#mw_4bc621b4-576a-46c5-afe9-b43e8bcd16dd",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusesWithinAComponentExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusesWithinAComponentExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusesWithinAComponentExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusesWithinAComponentExample_04.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusAtInterfaceExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusAtInterfaceExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusAtInterfaceExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusAtInterfaceExample_04.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ConvertVirtualBusToNonvirtualBusExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ConvertVirtualBusToNonvirtualBusExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ConvertVirtualBusToNonvirtualBusExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateNonvirtualBusFromStructureExample_01.png"
        ]
    },
    {
        "title": "Write Fully Inlined S-Functions with mdlRTW Routine",
        "introduction": "You can inline more complex S-functions by using the S-function mdlRTW routine. The mdlRTW routine provides the code generation process with more information about how the S-function is to be inlined by creating a parameter record of a non-tunable parameter for use with a TLC file. The mdlRTW routine places information in the model.rtw file. The mdlRTW function is described in the text file matlabroot/toolbox/simulink/blocks/src/sfuntmpl_doc.c. To use the mdlRTW function, take steps to create a direct-index lookup S-function. Lookup tables are collections of ordered data points of a function. Typically, these tables use some interpolation scheme to approximate values of the associated function between known data points. To incorporate the example lookup table algorithm into a Simulink\u00c2\u00ae model, the first step is to write an S-function that executes the algorithm in mdlOutputs. To produce the most efficient code, the next step is to create a corresponding TLC file to eliminate computational overhead and improve the speed of the lookup computations. The Simulink product provides support for general-purpose lookup 1-D, 2-D, and n-D algorithms. You can use these algorithms as they are or create a custom lookup table S-function to fit your requirements. You can create a 1-D lookup S-function, sfun_directlook.c, and its corresponding inlined sfun_directlook.tlc file (see Target Language Compiler for more details). You can:",
        "chunks": [
            {
                "heading": "S-Function RTWdata",
                "content": "RTWdata is a property of blocks, which can be used by the Target Language Compiler when inlining an S-function. RTWdata is a structure of character vectors that you can attach to a block. RTWdata is saved with the model and placed in the model.rtw file when you generate code. For example, this set of MATLAB\u00c2\u00ae commands:\n\nmydata.field1 = 'information for field1'; mydata.field2 = 'information for field2'; set_param(gcb,'RTWdata',mydata) get_param(gcb,'RTWdata')\n\nproduces this result:\n\nans = field1: 'information for field1' field2: 'information for field2'\n\nThe information for the associated S-Function block inside the model.rtw file is:\n\nBlock { \u00c2 \u00c2 Type \"S-Function\" \u00c2 \u00c2 RTWdata { \u00c2 \u00c2 \u00c2 \u00c2 field1 \"information for field1\" \u00c2 \u00c2 \u00c2 \u00c2 field2 \"information for field2\" \u00c2 \u00c2 }\n\nNoteRTWdata is saved in the model file for S-functions that are not linked to a library. However, RTWdata is not persistent for S-Function blocks that are linked to a library."
            },
            {
                "heading": "Direct-Index Lookup Table Algorithm",
                "content": "The 1-D lookup table block provided in the Simulink library uses interpolation or extrapolation when computing outputs. In this example, you create a lookup table that directly indexes the output vector (y-data vector) based on the current input (x-data) point.\n\nThis direct 1-D lookup example computes an approximate solution p(x)to a partially known function f(x) at x=x0, given data point pairs (x,y) in the form of an x-data vector and a y-data vector. For a given data pair (for example, the i'th pair), y_i = f(x_i). It is assumed that the x-data values are monotonically increasing. If x0 is outside the range of the x-data vector, the first or last point is returned.\n\nThe parameters to the S-function are:\n\nXData, YData, XEvenlySpaced\n\nXData and YData are double vectors of equal length representing the values of the unknown function. XDataEvenlySpaced is a scalar, 0.0 for false and 1.0 for true. If the XData vector is evenly spaced, XDataEvenlySpaced is 1.0 and more efficient code is generated.\n\nThe graph shows how the parameters XData=[1:6]and YData=[1,2,7,4,5,9] are handled. For example, if the input (x-value) to the S-Function block is 3, the output (y-value) is 7."
            },
            {
                "heading": "Direct-Index Lookup Table Example",
                "content": "Improve the lookup table by inlining a direct-index S-function with a TLC file. This direct-index lookup table S-function does not require a TLC file. The example uses a TLC file for the direct-index lookup table S-function to reduce the code size and increase efficiency of the generated code.\n\nImplementation of the direct-index algorithm with an inlined TLC file requires the S-function main module, sfun_directlook.c and a corresponding lookup_index.c module. The lookup_index.c module contains the GetDirectLookupIndex function that is used to locate the index in the XData for the current x input value when the XData is unevenly spaced. The GetDirectLookupIndex routine is called from the S-function and the generated code. The example uses the wrapper concept for sharing C/C++ code between Simulink MEX-files and the generated code.\n\nIf the XData is evenly spaced, then both the S-function main module and the generated code contain the lookup algorithm to compute the y-value of a given x-value because the algorithm is short.\n\nThe inlined TLC file is sfun_directlook.tlc, which is used to either perform a wrapper call or embed the optimal C/C++ code for the S-function. (See the example in mdlRTW Usage)."
            },
            {
                "heading": "Error Handling",
                "content": "In sfun_directlook.tlc, the mdlCheckParameters routine verifies that:\n\nThe new parameter settings are valid.XData and YData are vectors of the same length containing real, finite numbers.XDataEvenlySpaced is a scalar. The XData vector is a monotonically increasing vector and evenly spaced.\n\nThe mdlInitializeSizes function explicitly calls mdlCheckParameters after it verifies the number of parameters passed to the S-function. After the Simulink engine calls mdlInitializeSizes, it then calls mdlCheckParameters whenever you change the parameters or reevaluate them."
            },
            {
                "heading": "User Data Caching",
                "content": "In sfun_directlook.tlc, the mdlStart routine shows how to cache information that does not change during the simulation or while the generated code is executing. The example caches the value of the XDataEvenlySpaced parameter in UserData, a field of the SimStruct. The following line in mdlInitializeSizes instructs the Simulink engine to disallow changes to XDataEvenlySpaced.\n\nssSetSFcnParamTunable(S, iParam, SS_PRM_NOT_TUNABLE);\n\nDuring execution, mdlOutputs accesses the value of XDataEvenlySpaced from UserData rather than calling the mxGetPr MATLAB API function."
            },
            {
                "heading": "mdlRTW Usage",
                "content": "The code generator calls the mdlRTW routine while generating the model.rtw file. To produce optimal code for your Simulink model, you can add information to the model.rtw file about the mode in which your S-Function block is operating.\n\nThe example adds parameter settings to the model.rtw file. The parameter settings do not change during execution. In this case, the XDataEvenlySpaced S-function parameter cannot change during execution (ssSetSFcnParamTunable was specified as false (0) for it in mdlInitializeSizes). The parameter setting (XSpacing) uses the function ssWriteRTWParamSettings.\n\nBecause xData and yData are registered as run-time parameters in mdlSetWorkWidths, the code generator writes to the model.rtw file automatically.\n\nBefore examining the S-function and the inlined TLC file, consider the generated code for this model.\n\nThe model uses evenly spaced XData in the top S-Function block and unevenly spaced XData in the bottom S-Function block. When creating this model, specify the following commands for each S-Function block.\n\nset_param('sfun_directlook_ex/S-Function','SFunctionModules','lookup_index') set_param('sfun_directlook_ex/S-Function1','SFunctionModules','lookup_index')\n\nThe build process uses the module lookup_index.c when creating the executable.\n\nWhen generating code for this model, the code generator uses the S-function mdlRTW method to generate a model.rtw file with the value EvenlySpaced for the XSpacing parameter for the top S-Function block and the value UnEvenlySpaced for the XSpacing parameter for the bottom S-Function block. The TLC-file uses the value of XSpacing to determine what algorithm to include in the generated code. The generated code contains the lookup algorithm when the XData is evenly spaced, but calls the GetDirectLookupIndex routine when the XData is unevenly spaced. The generated model.c or model.cpp code for the lookup table example model is similar to this code:\n\n/* * sfun_directlook_ex.c * * Code generation for Simulink model * \"sfun_directlook_ex.slx\". * ... */ #include \"sfun_directlook_ex.h\" #include \"sfun_directlook_ex_private.h\" /* External outputs (root outports fed by signals with auto storage) */ ExtY_sfun_directlook_ex_T sfun_directlook_ex_Y; /* Real-time model */ RT_MODEL_sfun_directlook_ex_T sfun_directlook_ex_M_; RT_MODEL_sfun_directlook_ex_T *const sfun_directlook_ex_M = &sfun_directlook_ex_M_; /* Model output function */ void sfun_directlook_ex_output(void) { /* local block i/o variables */ real_T rtb_SFunction; real_T rtb_SFunction1; /* Sin: '<Root>/Sine Wave' */ rtb_SFunction1 = sin(sfun_directlook_ex_M->Timing.t[0]); /* Code that is inlined for the top S-function block in the * sfun_directlook_ex model */ /* S-Function (sfun_directlook): '<Root>/S-Function' */ { const real_T *xData = sfun_directlook_ex_ConstP.SFunction_XData; const real_T *yData = sfun_directlook_ex_ConstP.SFunction_YData; real_T spacing = xData[1] - xData[0]; if (rtb_SFunction1 <= xData[0] ) { rtb_SFunction = yData[0]; } else if (rtb_SFunction1 >= yData[20] ) { rtb_SFunction = yData[20]; } else { int_T idx = (int_T)( ( rtb_SFunction1 - xData[0] ) / spacing ); rtb_SFunction = yData[idx]; } } /* Outport: '<Root>/Out1' */ sfun_directlook_ex_Y.Out1 = rtb_SFunction; /* Code that is inlined for the bottom S-function block in the * sfun_directlook_ex model */ /* S-Function (sfun_directlook): '<Root>/S-Function1' */ { const real_T *xData = sfun_directlook_ex_ConstP.SFunction1_XData; const real_T *yData = sfun_directlook_ex_ConstP.SFunction1_YData; int_T idx; idx = GetDirectLookupIndex(xData, 5, rtb_SFunction1); rtb_SFunction1 = yData[idx]; } /* Outport: '<Root>/Out2' */ sfun_directlook_ex_Y.Out2 = rtb_SFunction1; } /* Model update function */ void sfun_directlook_ex_update(void) { /* signal main to stop simulation */ { /* Sample time: [0.0s, 0.0s] */ if ((rtmGetTFinal(sfun_directlook_ex_M)!=-1) && !((rtmGetTFinal(sfun_directlook_ex_M)-sfun_directlook_ex_M->Timing.t[0]) > sfun_directlook_ex_M->Timing.t[0] * (DBL_EPSILON))) { rtmSetErrorStatus(sfun_directlook_ex_M, \"Simulation finished\"); } } /* Update absolute time for base rate */ /* The \"clockTick0\" counts the number of times the code of this task has * been executed. The absolute time is the multiplication of \"clockTick0\" * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not * overflow during the application lifespan selected. * Timer of this task consists of two 32 bit unsigned integers. * The two integers represent the low bits Timing.clockTick0 and the high bits * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment. */ if (!(++sfun_directlook_ex_M->Timing.clockTick0)) { ++sfun_directlook_ex_M->Timing.clockTickH0; } sfun_directlook_ex_M->Timing.t[0] = sfun_directlook_ex_M->Timing.clockTick0 * sfun_directlook_ex_M->Timing.stepSize0 + sfun_directlook_ex_M->Timing.clockTickH0 * sfun_directlook_ex_M->Timing.stepSize0 * 4294967296.0; } ..."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/write-fully-inlined-s-functions-with-mdlrtw-routine.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/xdata_ydata_plot.gif",
            "https://in.mathworks.com/help/rtw/ug/sfcn_rtw6.png"
        ]
    },
    {
        "title": "Implement Data Parallelism in Simulink - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Configure Model for Concurrent Execution",
                "content": "Open the ex_data_parallelism_initial model.Convert areas in this model to referenced models. Use the same referenced model to replace each of the functional components that process the input."
            },
            {
                "heading": "Set Model Configuration Parameters",
                "content": "Click Configure Tasks. In the Concurrent Execution dialog box, in the right pane, select the Enable explicit model partitioning for concurrent behavior check box. With explicit partitioning, you can partition your model manually.On the Modeling tab, click Model Settings.Select Code Generation > Interface > Advanced parameters. Clear the MAT-file logging check box.Select Solver, set Type to Fixed-step, and click Apply.On the Solver pane, expand Solver details. Check that Periodic sample time constraint is set to Unconstrained. Under Tasking and sample time options, select Allow tasks to execute concurrently on target."
            },
            {
                "heading": "Partition Model Using Explicit Partitioning",
                "content": "Partition the top model.\n\nIn the Concurrent Execution tree, under Tasks and Mapping, select CPU. Click Add task four times to add four new tasks."
            },
            {
                "heading": "Map Blocks to Tasks",
                "content": "In the Concurrent Execution tree, select Tasks and Mapping. On the Map block to tasks pane:\n\nUnder Block: Input, click select task and select Periodic: Task.Under Block: Function 1, select Periodic: Task1.Under Block: Function 2, select Periodic: Task2.Under Block: Function 3, select Periodic: Task3.Under Block: Output, select Periodic: Task.\n\nThis maps your partitions to the tasks you created. The Input and Output model blocks are on one task. Each functional component is assigned a separate task.\n\nIn the Concurrent Execution tree, select Data transfer. In the Data Transfer Options pane, set the parameter Periodic signals to Ensure deterministic transfer (minimum delay). Click Apply and close the Concurrent Execution dialog box."
            },
            {
                "heading": "Finalize Model",
                "content": ""
            },
            {
                "heading": "Share Configuration Parameters with Referenced Models",
                "content": "Apply configuration parameters to all referenced models."
            },
            {
                "heading": "Initialize Data Dictionary to Store Configuration Set",
                "content": "Create a Simulink.data.dictionary.Entry object that represents the configuration set, which is an entry in the dictionary. For this example, suppose the name of the dictionary is myData.sldd and the name of the Simulink.ConfigSet object is myConfigs.Store a copy of the target Simulink.ConfigSet object in a temporary variable.Save changes made to the dictionary.Create a freestanding configuration set in the base workspace by copying the active configuration set of the model.Create a separate configuration reference for the top model and each reference model. To point the reference to your freestanding configuration, set the SourceName property to freeConfigSet, the variable that represents your configuration.Attach the configuration reference to each model by using the ConfigSetRef object. To use the configuration reference in the model, activate it for each model.\n\nFor more information, see Share a Configuration with Multiple Models, Automate Model Configuration by Using a Script, and Make Changes to Configuration Set Stored in Dictionary."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/implement-data-parallelism-in-simulink.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementDataParallelismInSimulinkExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementDataParallelismInSimulinkExample_02.png"
        ]
    },
    {
        "title": "Deploy Generated Software",
        "introduction": "Simulink\u00c2\u00ae provides capabilities for designing top models and deploying them as generated code that behaves in a target execution environment like the model behaves during simulation. This figure and the following table shows the steps required for software deployment by using Simulink and Embedded Coder\u00c2\u00ae.",
        "chunks": [
            {
                "heading": "Identify Requirements",
                "content": "Identify the requirements for your project. The requirements help you determine whether to deploy your top model as an application or component. This figure shows how scheduling and processing architecture differ between the deployment objectives.\n\nYou will need to decide which of these deployment objectives meets scheduling and other target environment needs of your project. For application deployment, generated code includes an example main program that applies a single-tasking, rate-monotonic scheduling (RMS), or concurrent scheduling scheme. This scheme is configured for the model and determines how entry-point functions are assigned to tasks. For executing the algorithm code, you can use the generated scheduling and data transfer code as is, change it, or replace it. Meanwhile, component deployment requires integration of generated function code with an external function scheduler and other target environment software.\n\nCode that you generate for application deployment can run on a single-process or multiprocess architecture as part of a real-time or non-real-time application, while code for component deployment can only run on a single-process architecture. For a single-process architecture, the generated code is optimized for a specific target device and meets hard real-time requirements. Multiprocess deployment addresses requirements of high-throughput and distributed execution applications.\n\nFor a list of requirements and conditions that apply to each deployment objective, see Software Deployment Objectives and Deployment Types. Use that information to identify the deployment type that best aligns with your project requirements.\n\nFor more information about assessing project requirements, see Map Embedded System Architecture to Simulink Modeling Environment."
            },
            {
                "heading": "Create C Code Interface Configuration",
                "content": "After researching C code interface requirements, you create a code interface configuration by using the Embedded Coder Dictionary. You can create data and service code interface configurations, as Code Interfaces and Code Interface Specification and Code Interface Configurations describe. The interfaces that you create as part of a code interface configuration depend on your project requirements and deployment objective.\n\nFor details about creating code interface configurations, see Code Interface Definitions."
            },
            {
                "heading": "Research for Code Interface Requirements",
                "content": "Before you can define a custom code interface configuration that aligns with specific target environment requirements, you need to gather requirements. Research the required application or component interactions with your target environment software. Identify sources of input and required output. Determine what the code for interfacing with other target environment resources must look like and how it must behave. For example, does your model or generated code need to exchange data with target environment services? If so, map inputs, outputs, and parameters to corresponding service interfaces. Typical service interfaces involve function arguments and return values, global variables, and access functions.\n\nThe following questions can help you identify interface requirements that are relevant to application or component deployment. Answers that you gather serve as input when defining a code interface configuration.\n\nCategoryQuestionsTarget environment services Does the target environment use standard platform middleware, such as AUTOSAR or DDS? For information about AUTOSAR or DDS, see AUTOSAR Blockset and DDS Blockset.What target environment software will the deployed code interact with? For example, does the target environment include an operating system? What target services are available? A code interface configuration defines interfaces for the services that you identify.Does the target software expect the deployed code to handle startup or shutdown events? If so, the code interface configuration should define interfaces for initialize and terminate functions.Does the target software have naming requirements for entry-point functions that it calls to initiate execution of deployed code? If so, the code interface configuration should specify function names or function naming rules that align with the requirements.What are the names of the functions that the deployed code needs to call to use target services? The code interface configuration should specify function naming rules that align with the requirements. Data communication What data communication methods do target services use for handling concurrent access to data when communicating with deployed code (direct access, outside execution, or during execution)? The code interface configuration should define interfaces that use data communication methods that align with those used by the target environment services. Data types Does the target environment expect the input and output of deployed code to be represented as arrays, structures, or enumerated types? In the Simulink environment, you can represent these types as vectors, buses, and IntEnum, respectively.Is fixed-point support required? If you use the Simulink fixed-point interface, you can scale and specify offsets.Does the target environment software use organization-specific data types? If yes and you have Embedded Coder software, create alias types to represent those types. The code generator uses the alias types in the code that it produces. For example, once defined, you can specify an alias type in a function prototype, for a temporary variable, or for block output. Memory usage and latency Does the deployed code need to access shared memory? If yes, define and use memory sections in the code interface configuration.Do you need to deploy code that minimizes latency or optimizes memory usage when sending, receiving or sharing data? Does the target environment require that deployed code optimize memory usage when sending data? Define and map model elements to code interfaces that use data communication methods that align with the requirements. Parameter tuning and data measurement Does the target environment require access to variables that represent parameters for tuning or data for measurement purposes? If so, how does the target environment expect the data to be represented in the deployed code? Does the data need to reside in a specific header file? Define the interface to align with the requirements. Deployment objective Does the generated code running in the target environment consist of multiple deployed source code modules developed independently and integrated manually with a target function scheduler? Or, is the code a generated executable program that runs standalone on the target device (single-processing) or as a collection of executable programs that run concurrently in a multiprocessing architecture?\n\nFor some projects, these requirements are captured in an interface control document (ICD). An ICD provides the details about the interfaces between deployed units of code and target environment services."
            },
            {
                "heading": "Decide on a Type of Interface Configuration and Storage",
                "content": "Decide whether you are creating a data or service interface configuration and whether the configuration will be model-owned or shared.\n\nGoalData InterfaceIn R2022b: Service InterfaceModel-Owned with Data InterfaceSharedCode interfacing for application deployment.X\u00c2 X\u00c2 Code interfacing for component deploymentXXX\u00c2 Enable mapping of model elements to storage classes and specific property settings (for example, to support legacy models).X\u00c2 X\u00c2 Customize interface code to include built-in safeguards for maintaining data coherence for outside-execution or during-execution data communication.\u00c2 X\u00c2 \u00c2 Customize code for data transfers between functions outside of (before and after) function execution.\u00c2 X\u00c2 \u00c2 Support accessing time values in tasks.\u00c2 X\u00c2 \u00c2 Enable mapping of model elements to complete interface abstractions.\u00c2 X\u00c2 \u00c2 For models of smaller scope or that do not share code interface requirements with other models.\u00c2 \u00c2 X\u00c2 Enable multiple models to attach the same shared Embedded Coder Dictionary and use the same code interface configuration defined in that dictionary.\u00c2 \u00c2 \u00c2 XStandardize interface code generated from models designed across and organization for a specific target environment. \u00c2 \u00c2 \u00c2 XEnable code generation from a model that meets requirements of different target environments.\u00c2 \u00c2 \u00c2 X\n\nTo customize the default model-owned dictionary, on the Embedded Coder app toolstrip, click Code Interface > Embedded Coder Dictionary (Model).\n\nTo create a shared Embedded Coder Dictionary, in the Model Explorer, click New > Create Embedded Coder Dictionary or in the Embedded Coder app, click Code Interface > Set up shared Embedded Coder Dictionary.\n\nFor more information see Code Interfaces and Code Interface Specification, Code Interface Configurations, Choose Code Interface for Code Generation."
            },
            {
                "heading": "Develop Deployable Code",
                "content": "This figure shows the steps for developing a top model that you intend to deploy as generated code.\n\nTo deploy code from a top model, design your top model by decomposing the algorithm into subcomponents and identify relevant utilities. Choose and implement a modeling style and modeling patterns that align with how you intend to deploy the generated code. Apply relevant modeling guidelines.\n\nWhen you are ready to generate code, complete this one-time code generation setup. You can optionally use a model template to create a model that is automatically configured according to this setup.\n\nIf relevant, attach a shared Embedded Coder Dictionary to the model. This step is required when you are deploying a component that uses a service code interface. This step is not relevant when you are deploying C++ code. Select an output type for code generation. Depending on the deployment goals for a model, an output type specifies one or a combination of the system target file to apply, programming language of the output, or platform middleware, such as AUTOSAR or DDS. For information about AUTOSAR or DDS, see AUTOSAR Blockset and DDS Blockset.Check whether the deployment type displayed in the Embedded Coder toolstrip aligns with your expectations. Typically, you can accept default deployment type settings. Deployment ObjectiveDeployment Type SettingC application deploymentAutomatic. The code generator produces deployable application or component code based on the model contents and configuration. For example,for an export-function model that is configured with a data interface, the code generator produces deployable component code. The code generator automatically configures reference models as subcomponents.C component deploymentComponent. The code generator automatically configures reference models as subcomponents.C++ code generationNot applicable.\n\nThen, iterate through these steps:\n\nMap model elements to code interfaces. For example, for the C language, available code interfaces are defined in the model Embedded Coder Dictionary. The mappings inform the code generator about appearance, placement, and behavior requirements of the code for model elements.Use the Model Advisor to check whether the model is ready for code generation. Use the Code Generation Advisor to check and configure a model for code generation application objectives, such as traceability or debugging.Generate code and confirm that the output meets the code interface requirements.If necessary, adjust your model design and repeat steps 1 to 3.\n\nModeling guidelines and tooling facilitate development of top models that you intend to deploy as:\n\nC function source code modules that are integrated with a target environment function scheduler and other target services that run in a single-processing environment.Standalone executable program that replicates the simulation scheduler and optimizes scheduling code for single-tasking, rate-monotonic multitasking, or concurrent execution, depending on the model configuration. The executable program runs as a single-process or multiprocess application. Code for a single-process application is intended to run on a specific target device.\n\nWhen deploying a component, you develop each component in isolation. Then, you or someone else in your organization integrates the generated function code into a complete application program at the source code level.\n\nFor models that you deploy as components that use a data interface, see the Component Deployment Guidelines for Embedded Coder Support Package, which provides guidelines and tools to help produce code that aligns with these aspects of target platform services:\n\nInterface of generated callable entry-point functionsInterface of calls to platform servicesData communication methods"
            },
            {
                "heading": "Design Model",
                "content": "You can design models for code generation where the code generator uses code interface mappings to produce code that aligns with target service requirements.\n\nTo start the design work for a deployment project, partition the project as an application or into components. For each application or component identify subcomponents and potential utilities.\n\nHigh-level code interface requirements of an application or component model can include:\n\nResponses to startup and shutdown eventsScheduling of periodic and aperiodic ratesCommunication service interfaces that safely handle access to data, including data that is shared by tasks or threads that execute concurrentlyNonvolatile memory service interfacesTimer service interfacesProgramming interface customizations for accessing data\n\nThe deployment type of a model determines how the model constructs map to interfaces for services provided by the target environment and the rules for peer interaction and scope for data and function accessibility for models in the hierarchy. Each model in the hierarchy gets associated with a deployment type based on the role of the model. For component deployment with a service interface configuration, the code generator sets the deployment type to Component. Otherwise, the code generator sets it to Automatic. In either case, for incremental development, you can change the setting to Subcomponent.\n\nChoose and implement a modeling style and modeling patterns that align with how you intend to deploy the generated code. Apply relevant modeling guidelines. For information on modeling styles, see Periodic and Aperiodic Function Interfaces. For information on modeling guidelines, see Standards, Guidelines, and Block Usage.\n\nThe Component Deployment Guidelines for Embedded Coder Support Package provides component modeling guidelines for deployment components that use a data interface. The guidelines help you design component models from which the code generator produces code that can integrate and interface with platform services and other component code that runs on a target platform. The guidelines identify model elements and model element code configurations for execution and other service requirements. When you design and configure a component based on the component modeling guidelines:\n\nThe code generator produces a collection of callable entry-point functions that align with target scheduler service calls.Within the generated function code, calls to target platform service functions align with the target service programming interfaces.The generated function code honors data communication methods that target platform services use.\n\nFor more information, see Architecture and Component Design."
            },
            {
                "heading": "Attach Dictionary",
                "content": "If you choose to use a shared Embedded Coder Dictionary, you must attach the dictionary to your model. When you are deploying a component that uses a service code interface, the code generator requires use of a shared Embedded Coder Dictionary. Embedded Coder Dictionaries are not relevant when you are deploying C++ code.\n\nTo attach an Embedded Coder Dictionary to a model, in the Embedded Coder app, click Code Interface > Set up shared Embedded Coder Dictionary. In the dialog box that appears, click Open, browse and select a dictionary (SLDD) file that contains the code interface configuration, and click OK. Alternatively, you can create a coder dictionary and attach it to the model.\n\nFor more information about creating and attaching Embedded Coder Dictionaries, see Embedded Coder Dictionary."
            },
            {
                "heading": "Select Output Type",
                "content": "When using the Embedded Coder app, before you generate code for a loaded model, you must select an output type. Available output types are listed in the toolstrip Output menu. For more information, see Code Generation Output."
            },
            {
                "heading": "Check Deployment Types",
                "content": "For C code generation configurations, in the Embedded Coder app toolstrip, the Deployment Type field shows the deployment type of the currently loaded model. Typically, you do not need to adjust the deployment type setting. The code generator sets the deployment type based on the model style and code interface configuration. For models configured with a data interface configuration, the code generator sets the field to Automatic. If you want to generate code for a subcomponent of a model, you can change the setting to Subcomponent.\n\nIf the code generator determines that you are deploying a component that uses a service code interface, for models in the component model hierarchy, you can configure the deployment types. By default, the code generator sets the deployment type of the loaded model to Component and models referenced by that model to Subcomponent. For each model in the model hierarchy, you can select a deployment type based on the role of the model.\n\nRole of ModelDeployment TypePublish code interfaces according to the code interface configuration associated with the model. Code generated from the model can interact with target environment software directly.ComponentReferenced by and runs as part of a parent component model. Execution and communication interfaces are accessible within the context of the parent model only. Generated code is not accessible to target environment software.Subcomponent\n\nTo review or set the deployment types for models throughout the model hierarchy, from the Deployment Type menu, select Set Up Deployment Type for Model Hierarchy. For more information, see Configure C Code Deployment Types for Model Hierarchy."
            },
            {
                "heading": "Map Model Elements to Code Interfaces",
                "content": "In the Embedded Coder app, use the Code Mappings editor to map model interface elements to code interface elements. Alternatively, you can use the code mappings programming interface. The code interface elements to which you can map model elements depend on the type of code interface configuration that is associated with the model (data or service). For C code generation, available code interface elements are defined in an Embedded Coder Dictionary that is associated with the model.\n\nFor more information, see:\n\nChoose Code Interface for Code GenerationC Data Code Interface Configuration for Model Interface ElementsCode Mappings editorcoder.mapping.api.CodeMappingInteractively Configure C++ InterfaceProgrammatically Configure C++ Interfacecoder.mapping.api.CodeMappingCPP"
            },
            {
                "heading": "Assess Code Generation Readiness",
                "content": "Verify that your model is ready for code generation by using the Model Advisor and Code Generation Advisor. The Model Advisor checks to assess readiness to generate code. General Embedded Coder checks and checks for component deployment of models configured with a service interface configuration are available in Simulink Check\u00e2\u0084\u00a2. Checks for component deployment of models configured with a data interface configuration are available as part of the Component Deployment Guidelines for Embedded Coder Support Package.\n\nThe Code Generation Advisor checks your model for code generation application objectives such as traceability or debugging.\n\nFor information about using Model Advisor, see:\n\nCheck Your Model Using the Model AdvisorEmbedded Coder ChecksComponent Deployment Guidelines for Embedded Coder Support Package\n\nFor information about using the Code Generation Advisor, see Configure Model for Code Generation Objectives by Using Code Generation Advisor."
            },
            {
                "heading": "Generate and Verify Code",
                "content": "You have different options for generating code depending on whether you are generating code for an application or component model. For an application model, by default, the code generator produces source code for algorithms represented in your model and a main function that handles function scheduling. Then, the code generator compiles and links the generated code into an executable program. Alternatively, you can generate source code and suppress compiling and linking by selecting model configuration parameter Generate code only and customizing the process for producing an executable program.\n\nFor a component model, you can generate source code and suppress compilation and linking or you can generate a component model library. The code generator produces build artifacts, including a header file services.h, in folder codeGenerationFolder/modelBuildFolder/services, and a MAT-file buildInfo.mat, in folder codeGenerationFolder/modelBuildFolder/services/lib. The services.h file, which you can rename in the Embedded Coder Dictionary, specifies function prototypes for target platform services. The buildInfo.mat file stores an RTW.BuildInfo object that contains information for compiling the generated code and producing a library. By default, the code generator produces source code and does not perform compilation and linking. To generate a library, clear model configuration parameter Generate code only. If you configure a component model for library generation or to run as a software-in-the-loop (SIL) or processor -in-the-loop (PIL) simulation, the code generator builds a component model library according to the model toolchain configuration. SIL or PIL simulations verify the code that the library contains.\n\nWhen you generate source code without compiling and linking, you can build an executable program for an application or a component model library outside of the MATLAB\u00c2\u00ae environment by using a CMake workflow. You can create a:\n\nCMake configuration (CMakeLists.txt) file by using the codebuild functionZIP file for transferring files to another development environment by setting model configuration parameter Package code and artifacts and using the packNGo function\n\nFor an example, see Deploy Component Algorithm as Component Model Library by Using CMake.\n\nTo verify whether the generated code aligns with code interface requirements, use the code view pane in the coder app and the generated Code Interface Report. Several other tools are available for other types of verification, such as profiling code execution, testing for numeric equivalence between simulations and code execution, and checking for unintended functionality.\n\nTo explore verification of code generated from component models, you can use the test harness example models provided in Deploy Export-Function Component Configured for C Service Interface Code Generation and Deploy Single-Rate, Rate-Based Component Configured for C Service Interface Code Generation.\n\nFor more information, see:\n\nSource Code GenerationGenerated Code CompilationVerification, Testing, and Certification"
            },
            {
                "heading": "Deploy Generated Code",
                "content": "After you generate and verify code, deploy it. How you deploy the generated code depends on whether you are deploying an application or component.\n\nDeployment TypeDeployment GoalsApplication Run generated executable program in the target environment as a standalone application.Integrate generated executable program to run with other code in the target environment.Customize generated source code to integrate with other code that runs in the target environment. In this case, you might use the generated example main as a starting point for developing a custom main program. ComponentIntegrate generated component source code or component model library with other code that runs in the target environment."
            },
            {
                "heading": "Application Deployment Workflow Options",
                "content": "For application deployment, by default, the code generator compiles and links generated source code into an executable program that you can download to a target execution environment to run. If you choose to configure the code generator to produce source code without compiling and linking, you can:\n\nCustomize or replace the generated main function. You must take care to align the code interfaces with the interfaces generated for the model algorithm code.Produce an executable program by using the codebuild command to compile and link the generated code.\n\nSee Manage Build Process Folders, Approaches for Building Code Generated from Simulink Models, and Compile Code in Another Development Environment."
            },
            {
                "heading": "Component Deployment Workflow Options",
                "content": "For component deployment, you have multiple workflow options. In each case, you must integrate your generated code with an external main program that handles function scheduling.\n\nYou can:\n\nIntegrate generated source code with an external main function and other target environment source code and build an executable program.Link a generated component model library with an external main function and other target environment code to create an executable program.Use the codebuild command to build a component model library from generated source code. Then, within or outside of the MATLAB environment, link the library with an external main function and other target environment code to create an executable program.\n\nSee Manage Build Process Folders, Configure CMake Build Process, Approaches for Building Code Generated from Simulink Models, and Compile Code in Another Development Environment."
            },
            {
                "heading": "Integrate Generated Component Code with Target Environment Code",
                "content": "For an embedded system, the main function:\n\nDefines function interfaces (function prototypes).Includes files that declare external data.Defines extern data.Initializes data.Uses simulated or actual hardware.Calls algorithmic functions.\n\nTo integrate generated component code with a main function and other target environment code, you must:\n\nMatch the data and function interfaces of the generated code with other interfaces of existing system code.Connect input data.Connect output data.Access other data, such as block state values, local parameters, and time.\n\nDesign and configure the component model such that generated code aligns with the code interfaces of the target environment. For example, if your target environment software defines a global variable for storing output data and the generated code reads that data as input, you can configure the corresponding inport so that the generated code interacts with the existing variable. The target environment software that calls the entry-point functions must provide input signal data and, depending on your application, scheduling information. Also, suppose that the generated algorithm calculates output data that the calling environment can use. The target environment software and the algorithm can exchange this data by using global variables or formal parameters (arguments). The set of input and output data and data access mechanisms constitute the interfaces of the entry-point functions.\n\nWhen you understand the code interfaces and how to control them, you can:\n\nGenerate code that can be called by other component code and target services.Write code that calls the generated code.Generate reusable (reentrant) code that you can call multiple times in a single application.Integrate the generated code with other, external code in your application.\n\nIn a model, root-level inports and outports represent the primary inputs and outputs of the component algorithm. By default, the code generator aggregates this input and output data into standard structures.\n\nFor examples, see Configure Generated Code According to Interface Control Document Specifications and Integrate External Application Code with Code Generated from PID Controller.\n\nFor more information, see Deployment, Integration, and Supported Hardware."
            },
            {
                "heading": "Review Generated Interface Code",
                "content": "Confirm that the code generator produces expected interface code by reviewing the Code Interface Report. The report describes the generated code interface, including interface information for:\n\nEach component model entry-point function (function name, prototype, timing information, arguments, return value, and header file)Each model root-level inport and root-level outport (block name, code identifier, data type, scaling information, and dimensions)Tunable parameters that are associated with the model (data store source, code identifier, data type, scaling information, and dimensions)Global data stores and data stores with non-Auto storage that are associated with the model\n\nFor models configured for component deployment with service interfaces, the report includes information for:\n\nEach periodic and aperiodic callable entry-point function (prototype, header file, simulation rate, and service call prototypes)Initialize and terminate callable entry-point functions (prototype and header file)Each type of service (function prototypes, data communication method, function names, data types, dimensions, and header file)\n\nConfigure the code generator to produce a Code Interface Report as part of the generated HTML report.\n\nFor more information about the report, see Analyze Generated Data Code Interface Report."
            },
            {
                "heading": "Get Meta Information About Generated Code",
                "content": "By default, the code generator creates a code descriptor file (codedescriptor.dmr) in the build folder. That file contains meta information about the generated code, including:\n\nData interfaces (inports, outports, parameters, data stores, and internal data)Function interfaces (initialize, output, update, and terminate)Execution information for the data and function interfaces, such as timing requirementsModel hierarchy information and information for referenced models\n\nYou can use the code descriptor programming interface to get access to the contents of the code descriptor file and use the results to confirm that generated interfaces meet integration requirements. You can also use the programming interface to provide input to tools that generate interfaces for target platform services.\n\nFor more information, see Get Code Description of Generated Code and coder.codedescriptor.CodeDescriptor class."
            },
            {
                "heading": "Identify and Package Files for Deployment",
                "content": "For component deployment, after you review and, if necessary, refine the code interfaces generated for a model, identify files required to build the integrated code. You can generate code for a component model and compile a component model library for deployment by clearing model configuration parameter Generate code only and initiating a model build. If code for the component model is already generated, you can build a component model library by using the codebuild command with the path codeGenerationFolder/modelBuildFolder/services/lib. You can link the generated component model library with a main function and other target environment code to create an executable program.\n\nWhen you generate source code without compiling and linking, you can build a component model library outside of the MATLAB environment by using a CMake workflow. You can create a:\n\nCMake configuration (CMakeLists.txt) file by using the codebuild function. See Configure CMake Build Process.ZIP file by setting model configuration parameter Package code and artifacts and using the packNGo function. The packNGo utility finds and packages files that you need to build an executable image. Then, you can relocate the ZIP file to another development environment, such as a dedicated application build system. See Relocate or Share Generated Code."
            },
            {
                "heading": "Build Integrated Code Into Executable Program",
                "content": "Embedded Coder provides extensive capabilities for customizing the build process. For example:\n\nChoose between a CMake, toolchain, or template makefile approach. See Approaches for Building Code Generated from Simulink Models.Compile a component model library that you can link with a main function and other target environment code to create an executable program. See Deploy Component Algorithm as Component Model Library by Using CMake.Control compiler optimizations. See Control Compiler Optimizations.Reduce build time by building referenced models in parallel. See Reduce Build Time for Referenced Models by Using Parallel Builds.Customize build processing that occurs after code generation to include third-party tools. See Customize Post-Code-Generation Build Processing.Compile code in another development environment. See Compile Code in Another Development Environment."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/deploy-component-model.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/software_deployment_workflow.png",
            "https://in.mathworks.com/help/ecoder/ug/framework_types.png",
            "https://in.mathworks.com/help/ecoder/ug/workflow_develop_component.png"
        ]
    },
    {
        "title": "Customize Build Process with STF_make_rtw_hook File",
        "introduction": "The build process lets you supply optional custom code in hook methods that are executed at specified points in the code generation and make process. You can use hook methods to add target-specific actions to the build process.",
        "chunks": [
            {
                "heading": "STF_make_rtw_hook File",
                "content": "You can modify hook methods in a file generically referred to as STF_make_rtw_hook.m, where STF is the name of a system target file, such as ert or mytarget. This file implements a function, STF_make_rtw_hook, that dispatches to a specific action, depending on the hookMethod argument passed in.\n\nThe build process calls STF_make_rtw_hook, passing in the hookMethod argument and other arguments. You implement only those hook methods that your build process requires.\n\nIf your model contains reference models, you can implement an STF_make_rtw_hook.m for each reference model as required. The build process calls each STF_make_rtw_hook for reference models, processing these files recursively (in dependency order)."
            },
            {
                "heading": "Conventions for Using the STF_make_rtw_hook File",
                "content": "For the build process to call the STF_make_rtw_hook, check that the following conditions are met:\n\nThe STF_make_rtw_hook.m file is on the MATLAB\u00c2\u00ae path.The file name is the name of your system target file (STF), appended to the text _make_rtw_hook.m. For example, if you generate code with a custom system target file mytarget.tlc, name your hook file mytarget_make_rtw_hook.m, and name the hook function implemented within the file mytarget_make_rtw_hook.The hook function implemented in the file uses the function prototype described in STF_make_rtw_hook.m Function Prototype and Arguments."
            },
            {
                "heading": "STF_make_rtw_hook.m Function Prototype and Arguments",
                "content": "The function prototype for STF_make_rtw_hook is:\n\nfunction STF_make_rtw_hook(hookMethod, modelName, rtwRoot, templateMakefile, buildOpts, buildArgs, buildInfo)\n\nThe arguments are defined as:\n\nhookMethod: Character vector specifying the stage of build process from which the STF_make_rtw_hook function is called. The following flow chart summarizes the build process, highlighting the hook points. Valid values for hookMethod are 'entry', 'before_tlc', 'after_tlc', 'before_make', 'after_make', 'exit', and 'error'. The STF_make_rtw_hook function dispatches to the relevant code with a switch statement.\n\nmodelName: Character vector specifying the name of the model. Valid at all stages of the build process.rtwRoot: Reserved.templateMakefile: Name of template makefile. buildOpts: A MATLAB structure that contains the Boolean field codeWasUpToDate. Valid for the 'before_make', 'after_make', and 'exit' stages only.buildArgs: Character vector containing the argument to make_rtw. When you invoke the build process, buildArgs is copied from the argument following \"make_rtw\" in the Configuration Parameters + Code Generation + Make command field.For example, the following make arguments from the Make command fieldmake_rtw VAR1=0 VAR2=4generate the following:% make -f untitled.mk VAR1=0 VAR2=4The buildArgs argument does not apply for toolchain approach builds because these builds do not allow adding make arguments to the make_rtw call. On the compiler command line, to provide custom definitions (for example, VAR1=0 VAR2=4) that apply for both TMF approach and toolchain approach builds, use the Configuration Parameters > Code Generation > Custom Code > Defines field.buildInfo: The RTW.BuildInfo object that contains information for compiling and linking generated code. Available only for the 'after_tlc', 'before_make', 'after_make', and 'exit' stages. The information in the object at the end of the 'after_tlc' stage might not be complete. In later stages, the 'before_make' and 'after_make' hook methods can also add information to the object. For more information about using the RTW.BuildInfo object, see Code Compilation Customization."
            },
            {
                "heading": "Applications for STF_make_rtw_hook.m",
                "content": "This section shows how you can use the STF_make_rtw_hook.m hook methods.\n\nIn general, use the 'entry' hook to initialize the build process, for example, to change or validate settings before code is generated. One application for the 'entry' hook is to rerun the auto-configuration script that initially ran at target selection time to compare model parameters before and after the script executes, for validation purposes.\n\nThe other hook points, 'before_tlc', 'after_tlc', 'before_make', 'after_make', 'exit', and 'error' are useful for interfacing with external tool chains, source control tools, and other environment tools.\n\nFor example, you can use the STF_make_rtw_hook.m file at a stage after 'entry' to obtain the path to the build folder. At the 'exit' stage, you can then locate generated code files within the build folder and check them into your version control system. You can use 'error' to clean up static or global data used by the hook function when an error occurs during code generation or the build process.\n\nNoteThe build process temporarily changes the MATLAB working folder to the build folder for stages 'before_make', 'after_make', 'exit', and 'error'. Your STF_make_rtw_hook.m file must not make incorrect assumptions about the location of the build folder. At a point after the 'entry' stage, you can obtain the path to the build folder. In the following MATLAB code example, the build folder path is returned as a character vector to the variable buildDirPath.buildDirPath = rtwprivate('get_makertwsettings',gcs,'BuildDirectory');\n\nNoteDo not use the STF_make_rtw_hook.m file to: Change the model configuration. For example, do not use a hook method to: Switch between model variants.Call the set_param function. Changing the model configuration might produce unexpected code generation results.Run commands that compile the model. Compiling the model might produce unexpected behavior."
            },
            {
                "heading": "Control Code Regeneration Using STF_make_rtw_hook.m",
                "content": "When you rebuild a model, by default, the build process performs checks to determine whether changes to the model or relevant settings require regeneration of the top model code. (For details on the criteria, see Control Regeneration of Top Model Code.) If the checks determine that top model code generation is required, the build process fully regenerates and compiles the model code. If the checks indicate that the top model generated code is current with respect to the model, and model settings do not require full regeneration, the build process omits regeneration of the top model code.\n\nRegardless of whether the top model code is regenerated, the build process subsequently calls the build process hooks, including STF_make_rtw_hook functions and the post code generation command. The following mechanisms allow you to perform actions related to code regeneration in the STF_make_rtw_hook functions:\n\nTo force code regeneration, use the following function call from the 'entry' hook:rtw.targetNeedsCodeGen('set', true);In hooks from 'before_tlc' through 'exit', the buildOpts structure passed to the hook has a Boolean field codeWasUpToDate. The field is set to true if model code was up to date and code was not regenerated, or false if code was not up to date and code was regenerated. You can customize hook actions based on the value of this field. For example:... case 'before_tlc' if buildOpts.codeWasUpToDate %Perform hook actions for up to date model else %Perform hook actions for full code generation end ..."
            },
            {
                "heading": "Use STF_make_rtw_hook.m for Your Build Procedure",
                "content": "To create a custom STF_make_rtw_hook hook file for your build procedure, copy and edit the example ert_make_rtw_hook.m file, which is located in the foldermatlabroot/toolbox/coder/embeddedcoder (open), as follows:\n\nCopy ert_make_rtw_hook.m to a folder in the MATLAB path. Rename it in accordance with the naming conventions described in Conventions for Using the STF_make_rtw_hook File. For example, to use it with the GRT target grt.tlc, rename it to grt_make_rtw_hook.m.Rename the ert_make_rtw_hook function within the file to match the file name.Implement the hooks that you require by adding code to case statements within the switch hookMethod statement."
            },
            {
                "heading": "Hook Method after_tlc",
                "content": "The after_tlc hook method is available solely for backwards compatibility.\n\nThe format of the generated code during the after_tlc stage is not the final format."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/customizing-the-target-build-process-with-the-stf-make-rtw-hook-file.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/build_flowchart_with_hook_points_17b.png"
        ]
    },
    {
        "title": "Manage Build Process File Dependencies",
        "introduction": "An important control of the size of generated code is managing the number and size of included files (dependencies). To reduce the number of system header files and generated header files that generated code requires, it is helpful to understand the dependencies that the build process generates and the conditions that lead to dependencies. The dependency relationships among generated source and header files appear in the figure. Arrows coming from a file point to files it includes. Other dependencies exist, for example, on Simulink\u00c2\u00ae header files tmwtypes.h and simstruc_types.h, plus C or C++ library files. The figure maps inclusion relations between only those files that are generated in the build folder. These files can reference utility and model reference code located in a code generation folder. For more information about the folders and files that the build process creates, see Manage Build Process Folders and Manage Build Process Files. The two tables identify the conditions that control creation of dependency files for GRT and ERT targets. To manage build-related dependencies, consider how these conditions apply to your model and code generation process. Then, configure model parameters and code generation options to manage build process file dependencies. Due to differences in file packaging options for code generated with ERT-based system target files, the file dependencies differ slightly from file packaging for code generated with GRT-based system target files. See Manage File Packaging of Generated Code Modules. The parent system header files (model.h) include child subsystem header files (subsystem.h). In more layered models, subsystems similarly include their children's header files in the model hierarchy. As a consequence, subsystems are able to view recursively into their descendant subsystems and view into the root system because every subsystem.c or subsystem.cpp includes model.h and model_private.h. In the figure, files model.h, model_private.h, and subsystem.h depend on the header file rtwtypes.h. For ERT system target files, the dependency on rtwtypes.h exists only if Data type replacement is set to Use coder typedefs. If you use system target files that are not based on the ERT system target file, the source files that you generate can have additional dependencies on tmwtypes.h and simstruc_types.h.",
        "chunks": [
            {
                "heading": "System Header Files",
                "content": "The system header files make function declarations, type definitions, and macro definitions available to the legacy or external code. Some code generation scenarios require including header files that are specific to the code generator product.\n\nThe code generator includes some system header files for broadly defined cases. For example, generated code includes <stddef.h> when the model contains a utility function that requires this header file. This approach helps identify header file dependencies:\n\nSet model configuration parameter Shared code placement to 'Shared location' and build the model. The code generator places the utility functions in __sharedutils folder.Use a find-in-file utility (for example, grep utility) to search the .c and .h files in the __sharedutils folder for #include. The search results list the utilities with header file dependencies.Use this information to identify utilities to remove from the model and reduce header file dependencies in the generated code.\n\nFor more information, see Generate Shared Utility Code for Fixed-Point Functions.\n\nSystem Header FileDescription and Inclusion Conditions for GRT or ERT System Target Files<math.h>Defines math constantsGRT\u00e2\u0080\u0094Generated code does not include this file.ERT\u00e2\u0080\u0094Generated code includes this file when the code honors your model configuration for solver Stop time and either: Your model configuration enables parameter MAT-file logging. See MAT-file logging.Your model configuration enables parameter External mode. <float.h>Provides floating-point math functionsGRT\u00e2\u0080\u0094Generated code includes this file when your model contains a floating-point math function.ERT\u00e2\u0080\u0094Generated code includes this file when your model contains a floating-point math function, unless a code replacement library entry overrides the function. For more information, see Choose a Code Replacement Library.<stddef.h>Defines NULLGRT and ERT\u00e2\u0080\u0094Generated code includes this file when your model contains a utility function that requires this file.<stdio.h>Provides file I/O functionsGRT\u00e2\u0080\u0094Generated code includes this file when your model includes a To File block.ERT\u00e2\u0080\u0094Generated code includes this file when either: Your model includes a To File block.Your model configuration enables parameter MAT-file logging. See MAT-file logging. <stdlib.h>Provides utility functions such as the integer versions of div() and abs()GRT\u00e2\u0080\u0094Generated code includes this file when either: Your model includes a Stateflow\u00c2\u00ae chart.Your model includes a math function block configured for mod() or rem(), which generate calls to div(). ERT\u00e2\u0080\u0094Generated code includes this file when either: Your model includes a Stateflow chart, and you select model configuration parameter Support: floating-point numbers.Your model includes a math function block configured for mod() or rem(), which generate calls to div(). <string.h>Provides memory functions such as memset() and memcpy()GRT\u00e2\u0080\u0094Generated code includes this file when your model initialization code calls memset(). ERT\u00e2\u0080\u0094Generated code includes this file when a block or model initialization code calls memcpy() or memset().For a list of relevant blocks, in the Command Window, type:showblockdatatypetableLook for blocks with the N2 note. To omit calls to memset() from model initialization code, select model configuration parameters Remove root level I/O zero initialization and Remove internal data zero initialization."
            },
            {
                "heading": "Code Generator Header Files",
                "content": "Dependencies in the table for generated header files apply to the system target files grt.tlc and ert.tlc. System target files derived from these base system target files can have additional header dependencies. Code generation for blocks from blocksets, embedded targets, and custom S-functions can introduce additional header dependencies.\n\nHeader FileDescription and Inclusion Conditions for GRT or ERT System Target Filesbuiltin_typeid_types.hDefines an enumerated type corresponding to built-in data typesGRT and ERT\u00e2\u0080\u0094Generated code includes this file when one or more of these conditions apply: Your model contains a Stateflow chart that uses messages.Your model configuration enables: MAT-file logging. See MAT-file logging.Your model configuration selects C API options at Code Generation > Interface. dt_info.hDefines data structures for external modeGRT and ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration enables external mode.ext_work.hDefines external mode functionsGRT and ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration enables external mode.fixedpoint.hProvides fixed-point support for noninlined S-functionsGRT\u00e2\u0080\u0094Generated code includes this file.ERT\u00e2\u0080\u0094Generated code includes this file when your model uses noninlined S-functions.model_reference_types.hContains type definitions for timing bridgesGRT and ERT\u00e2\u0080\u0094Generated code includes this file when building a reference model or building a model that contains model blocks.model_types.hDefines model-specific data typesGRT and ERT\u00e2\u0080\u0094Generated code includes this file.multiword_types.hContains type definitions for multiword-wide data types and their word-size chunksGRT and ERT\u00e2\u0080\u0094Generated code includes this file when one or more of these conditions apply: Your model uses multiword data types.Your model configuration selects parameter MAT-file logging. See MAT-file logging.Your model configuration selects External mode. For a model that uses multiword data types, the code generator overwrites the file if the data types are greater in length than those of the model for which code was last generated. To avoid overwriting this file, set: MultiwordTypeDef to 'User defined'MultiwordLength to the biggest length that is required by your models. rtGetInf.hrtGetNaN.hrt_nonfinite.hSupport nonfinite numbersGRT\u00e2\u0080\u0094Generated code includes this file when one or more of these conditions apply: Your model contains S-functions.The generated code requires nonfinite numbers.Your model configuration selects parameter MAT-file logging. See MAT-file logging. ERT\u00e2\u0080\u0094Generated code includes this file when one or more of these conditions apply: Your model contains S-functions.The generated code requires nonfinite numbers.Your model configuration selects parameter MAT-file logging. See MAT-file logging. rt_defines.hContains type definitions for special mathematical constants (such as \u00cf\u0080 and e) and defines the UNUSED_PARAMETER macroGRT and ERT\u00e2\u0080\u0094Generated code includes this file when either: The generated code requires a mathematical constant definition.The function body does not access a required model function argument. rt_logging.hSupports MAT-file logging and includes:rtwtypes.h builtin_typeid_types.h multiword_types.h rt_mxclassid.h rtw_matlogging.hGRT\u00e2\u0080\u0094Generated code includes this file.ERT\u00e2\u0080\u0094Generated code includes this file when you model configuration selects parameter MAT-file logging. See MAT-file logging.rt_mxclassid.hDefines mxArray class ID enumerationsGRT and ERT\u00e2\u0080\u0094Generated code includes this file when the code includes rt_logging.c.rtw_continuous.hSupports continuous timeGRT\u00e2\u0080\u0094Generated code includes this file when the code includes simstruc_types.h. ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration selects parameter Support: continuous time and when the code does not already include simstruc.h.rtw_extmode.hSupports external modeGRT\u00e2\u0080\u0094Generated code includes this file when the code includes simstruc_types.h.ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration selects external mode and when the code does not already include simstruc.h.rtw_matlogging.hSupports MAT-file loggingGRT\u00e2\u0080\u0094Generated code includes this file when the code includes simstruc_types.h and rt_logging.h.ERT\u00e2\u0080\u0094Generated code includes this file when the code includes rt_logging.h.rtw_solver.hSupports continuous statesGRT\u00e2\u0080\u0094Generated code includes this file when the code includes simstruc_types.h.ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration selects parameter Support: continuous time and when the code does not already include simstruc.h.rtwtypes.hDefines code generator data typesGRT\u00e2\u0080\u0094Generated code includes this file. Uses a verbose version of the file, which includes tmwtypes.h.ERT\u00e2\u0080\u0094Generated code includes this file if one of these conditions applies: Data type replacement is set to Use coder typedefs.Data type replacement is set to Use C data types with fixed-width integers and Coder typedefs compatibility is selected. See rtwtypes.h.The code generator overwrites the previously generated rtwtypes.h when you enable (previously disabled) support for: Complex numbers (SupportComplex set to 'on').Noninlined S-functions (SupportNonInlinedSFcns set to 'on') To avoid rewriting rtwtypes.h, you can: Specify support for complex datatypes for your models even if the models do not currently use complex data types.Disable support for noninlined S-functions. In this case, the use of a noninlined S-function produces an error. To avoid the error, convert the S-function to an inlined S-function. For more information, see Inlining S-Functions. simstruc.hSupports calling noninlined S-functions that use the Simstruct definition; also includes:limits.h string.h tmwtypes.h simstruc_types.hGRT\u00e2\u0080\u0094Generated code includes this file.ERT\u00e2\u0080\u0094Generated code includes this file when your model uses noninlined S-functions.simstruc_types.hProvides definitions that the generated code uses and includes the header files:rtw_matlogging.h rtw_extmode.h rtw_continuous.h rtw_solver.h sysran_types.hGRT\u00e2\u0080\u0094Generated code includes this file when the code includes rtwtypes.h. ERT\u00e2\u0080\u0094Generated code does not include this file. For ERT, rtwtypes.h contains definitions, and model.h contains header files.sysran_types.hSupports external modeGRT\u00e2\u0080\u0094Generated code includes this file when the code includes simstruc_types.h.ERT\u00e2\u0080\u0094Generated code includes this file when your model configuration selects external mode and when the code does not already include simstruc.h.zero_crossing_types.hContains zero-crossing definitions for models with triggered subsystems where the trigger is rising, falling, or either. File is generated only if required by the model as determined by the data type of the trigger signal.GRT\u00e2\u0080\u0094Generated code does not include this file for GRT code generation targets.ERT\u00e2\u0080\u0094Generated code includes this file when a model has a conditionally executed subsystem where a trigger uses zero crossing detection. If generated, the content of zero_crossing_types.h is always the same."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/build-process-file-dependencies.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/rtw_generated_file_dependencies.png"
        ]
    },
    {
        "title": "Generate Code and Executables for Individual Subsystems",
        "introduction": "You can generate code and build a standalone executable for a subsystem within a model. When you generate code for an individual subsystem, the code generation and build process uses the code generation and build parameters of the root model.",
        "chunks": [
            {
                "heading": "Subsystem Build Limitations",
                "content": "These limitations apply to building subsystems:\n\nYou cannot use a subsystem build for a model configured with an ERT-based system target file and service code interface.A subsystem build does not support a subsystem that has a function-call trigger input or a function-call output.When you build a subsystem that includes an Outport block for which the Data type parameter specifies a bus object, you must address errors that result from setting signal labels. To configure the software to display these errors, in the Configuration Parameters dialog box for the parent model, on the Diagnostics > Connectivity pane, set the Signal label mismatch parameter to error.When building a subsystem, the code generator inserts traceability tags for root-level Inport and Outport blocks in place of subsystem Inport and Outport blocks, which are virtual (see Nonvirtual and Virtual Blocks). For instance: /* Outport: '<Root>/Out1' incorporates: * Inport: '<Root>/In1'However, you cannot trace these root-level tags to the Inport and Outport blocks of the root-level model.When a subsystem is in a triggered or function-call subsystem, the right-click build process might fail if the subsystem code is not sample-time independent. To determine whether a subsystem is sample-time independent:Copy all blocks in the subsystem to an empty model.In the Configuration Parameters dialog box, on the Solver pane, set:Type to Fixed-step.Periodic sample time constraint to Ensure sample time independent.Click Apply.Update the model. If the model is sample-time dependent, Simulink generates an error in the process of updating the diagram.When you use the right-click build process for a subsystem, the code generator attempts to use the subsystem name for generated code files. In some cases, there can be a conflict with the name that you specify when you set, for example, File name options to Use function name or Function name options to Use subsystem name. You see an error:The subsystem 'model/subsys' is trying to generate code to an reserved file (subsys) for the model 'subsys'...To resolve the error, modify one of the conflicting file names so that the names are unique.In a subsystem build warning, the subsystem block path hyperlink that is created references a temporary model block path instead of the actual model block path. In the Diagnostic Viewer, clicking the subsystem hyperlink does not take you to the block. In the Command Window, you see a message:... No system or file called 'subsystemName' found. ..."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/generate-code-and-executables-for-an-individual-subsystem.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/rtwdemo_atomic.png"
        ]
    },
    {
        "title": "Code Configuration Functions",
        "introduction": "",
        "chunks": [
            {
                "heading": "LibAddSourceFileCustomSection (file, builtInSection, newSection)",
                "content": "Adds a custom section to a source file. You must associate a custom section with one of the built-in sections: Includes, Defines, Types, Enums, Definitions, Declarations, Functions, or Documentation. Nothing happens if the section already exists, except to report an error if an inconsistent built-in section association is attempted. LibAddSourceFileCustomSection is available only with the Embedded Coder\u00c2\u00ae product."
            },
            {
                "heading": "Arguments",
                "content": "file \u00e2\u0080\u0094 Source file reference\n\nbuiltInSection \u00e2\u0080\u0094 Name of the associated built-in section\n\nnewSection \u00e2\u0080\u0094 Name of the new (custom) section\n\nSee LibAddSourceFileCustomSection in codetemplatelib.tlc."
            },
            {
                "heading": "LibAddToCommonIncludes(incFileName)",
                "content": "Adds items to a list of #include /package specification items. Each member of the list is unique. Attempting to add a duplicate member does nothing.\n\nLibAddToCommonIncludes should be called from block TLC methods to specify generation of #include statements in model.h. Specify the names of files on the include path inside angle brackets, e.g., <sysinclude.h>. Specify the names of local files without angle brackets, e.g., myinclude.h. Each call to LibAddToCommonIncludes adds the specified file to the list only if it is not already there. Filenames with and without angle brackets (e.g., <math.h> and math.h) are considered different. The #include statements are placed inside model.h."
            },
            {
                "heading": "Example",
                "content": "LibAddToCommonIncludes(\"tpu332lib.h\")\n\nSee LibAddToCommonIncludes in cachelib.tlc."
            },
            {
                "heading": "LibAddToModelSources(newFile)",
                "content": "LibAddToModelSources serves two purposes:\n\nTo notify the build process that it must build with the specified source file To update the SOURCES: file1.c file2.c ... comment in the generated code.\n\nFor inlined S-functions, LibAddToModelSources is generally called from BlockTypeSetup. LibAddToModelSources adds a filename to the list of sources for building this model. LibAddToModelSources returns 1 if the filename passed in was a duplicate (i.e., it was already in the sources list) and 0 if it was not a duplicate.\n\nYou can use the LibAddToModelSources function for other purposes in TLC aside from writing S-functions. If you write your own S-functions, use the SFunctionModules block parameter instead of LibAddToModelSources. See LibAddToModelSources in utils_api.tlc."
            },
            {
                "heading": "LibCacheDefine(buffer)",
                "content": "Each call to LibCacheDefine appends your buffer to the existing cache buffer. For blocks, LibCacheDefine is generally called from BlockTypeSetup.\n\nLibCacheDefine caches #define statements for inclusion in model_private.h or model.c. Call LibCacheDefine from inside BlockTypeSetup to cache a #define statement. Each call to LibCacheDefine appends your buffer to the existing cache buffer. The #define statements are placed inside model_private.h or model.c."
            },
            {
                "heading": "Example",
                "content": "%openfile buffer #define INTERP(x,x1,x2,y1,y2) ( y1+((y2 - y1)/(x2 - x1))*(x-x1)) #define this that %closefile buffer %<LibCacheDefine(buffer)>\n\nSee LibCacheDefine in codecache_api.tlc."
            },
            {
                "heading": "LibCacheExtern(buffer)",
                "content": "LibCacheExtern should be called from inside BlockTypeSetup to cache an extern statement. Each call to LibCacheExtern appends your buffer to the existing cache buffer. The extern statements are placed in model_private.h."
            },
            {
                "heading": "Example",
                "content": "%openfile buffer extern real_T mydata; %closefile buffer %<LibCacheExtern(buffer)>\n\nSee LibCacheExtern in codecache_api.tlc."
            },
            {
                "heading": "LibCacheFunctionPrototype(buffer)",
                "content": "LibCacheFunctionPrototype should be called from inside BlockTypeSetup to cache a function prototype. Each call to LibCacheFunctionPrototype appends your buffer to the existing cache buffer. The prototypes are placed inside model_private.h."
            },
            {
                "heading": "Example",
                "content": "%openfile buffer extern int_T fun1(real_T x); extern real_T fun2(real_T y, int_T i); %closefile buffer %<LibCacheFunctionPrototype(buffer)>\n\nSee LibCacheFunctionPrototype in codecache_api.tlc."
            },
            {
                "heading": "LibCacheTypedefs(buffer)",
                "content": "LibCacheTypedefs should be called from inside BlockTypeSetup to cache typedef declarations. Each call to LibCacheTypedefs appends your buffer to the existing cache buffer. The typedef statements are placed inside model.h (or model_common.h)."
            },
            {
                "heading": "Example",
                "content": "%openfile buffer typedef foo bar; %closefile buffer %<LibCacheTypedefs(buffer)>\n\nSee LibCacheTypedefs in codecache_api.tlc."
            },
            {
                "heading": "LibCallModelInitialize()",
                "content": "Returns code for calling the model's initialize function (valid for ERT only).\n\nSee LibCallModelInitialize in codetemplatelib.tlc."
            },
            {
                "heading": "LibCallModelStep(tid)",
                "content": "Returns code for calling the model's step function (valid for ERT only).\n\nSee LibCallModelStep in codetemplatelib.tlc."
            },
            {
                "heading": "LibCallModelTerminate()",
                "content": "Returns code for calling the model's terminate function (valid for ERT only).\n\nSee LibCallModelTerminate in codetemplatelib.tlc."
            },
            {
                "heading": "LibCallSetEventForThisBaseStep(buffername)",
                "content": "Returns code for calling the model's set events function (valid for ERT only)."
            },
            {
                "heading": "Argument",
                "content": "buffername \u00e2\u0080\u0094 Name of the variable used to buffer the events. For the example ert_main.c, this is eventFlags.\n\nSee LibCallSetEventForThisBaseStep in codetemplatelib.tlc."
            },
            {
                "heading": "LibClearFileSectionContents(fileIdx, attrib)",
                "content": "Before writing file to disk, clear file sections with custom values."
            },
            {
                "heading": "Arguments",
                "content": "fileIdx (scope or number) \u00e2\u0080\u0094 File index\n\nattrib (string) \u00e2\u0080\u0094 Name of model attribute\n\nSee LibGetSourceFileAttribute in codetemplatelib.tlc."
            },
            {
                "heading": "LibCreateSourceFile(type, creator, name)",
                "content": "Creates a new C or C++ file and returns its reference. If the file already exists, LibCreateSourceFile returns the existing file's reference."
            },
            {
                "heading": "Syntax",
                "content": "%assign fileH = LibCreateSourceFile (\"Source\", \"Custom\", \"foofile\")"
            },
            {
                "heading": "Arguments",
                "content": "type (string) \u00e2\u0080\u0094 Valid values are \"Source\" and \"Header\" for .c and .h files, respectively.\n\ncreator (string) \u00e2\u0080\u0094 Who is creating the file? An error is reported if different creators attempt to create the same file.\n\nname (string) \u00e2\u0080\u0094 Base name of the file (i.e., without the extension). Note that files are not written to disk if they are empty."
            },
            {
                "heading": "Returns",
                "content": "Reference to the model file (scope).\n\nSee LibCreateSourceFile in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetFileRecordName (file)",
                "content": "Returns model file name (including the path) without the file extension. To retrieve the file name (including the path) with the file extension, use LibGetSourceFileSection."
            },
            {
                "heading": "Arguments",
                "content": "file \u00e2\u0080\u0094 Source file reference\n\nSee LibGetFileRecordName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlPrvHdrBaseName()",
                "content": "Returns the base name of the model's private header file, for example, model_private.h.\n\nSee LibGetMdlPrvHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlPubHdrBaseName()",
                "content": "Returns the base name of the model's public header file, for example, model.h.\n\nSee LibGetMdlPubHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlSrcBaseName()",
                "content": "Returns the base name of the model's main source file, for example, model.c.\n\nSee LibGetMdlSrcBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlDataSrcBaseName()",
                "content": "Returns the base name of the model's data file, for example, model_data.c.\n\nSee LibGetMdlDataSrcBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlTypesHdrBaseName()",
                "content": "Returns the base name of the model types file, for example, model_types.h.\n\nSee LibGetMdlTypesHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlCapiHdrBaseName()",
                "content": "Returns the base name of the model capi header file, for example, model_capi.h.\n\nSee LibGetMdlCapiHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlCapiSrcBaseName()",
                "content": "Returns the base name of the model capi source file, for example, model_capi.c.\n\nSee LibGetMdlCapiSrcBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlCapiHostHdrBaseName()",
                "content": "Returns the base name of the model capi host header file, for example, model_host_capi.h.\n\nSee LibGetMdlCapiHostHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlTestIfHdrBaseName()",
                "content": "Returns the base name of the model testinterface header file, for example, model_testinterface.h.\n\nSee LibGetMdlTestIfHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetMdlTestIfSrcBaseName()",
                "content": "Returns the base name of the model testinterface source file, for example, model_testinterface.c.\n\nSee LibGetMdlTestIfSrcBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetDataTypeTransHdrBaseName()",
                "content": "Returns the base name of the data type transition file, for example, model_dt.h for code generation's Real-Time and Embedded-C code formats.\n\nSee LibGetDataTypeTransHdrBaseName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetModelDotCFile()",
                "content": "Returns a reference to the model.c or .cpp source file. You can then cache additional code using LibSetSourceFileSection."
            },
            {
                "heading": "Syntax",
                "content": "%assign srcFile = LibGetModelDotCFile() %<LibSetSourceFileSection(srcFile, \"Functions\", mybuf)>"
            },
            {
                "heading": "Returns",
                "content": "Returns a reference to the model.c or .cpp source file.\n\nSee LibGetModelDotCFile in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetModelDotHFile()",
                "content": "Returns a reference to the model.h source file. You can then cache additional code using LibSetSourceFileSection."
            },
            {
                "heading": "Syntax",
                "content": "%assign hdrFile = LibGetModelDotHFile() %<LibSetSourceFileSection(hdrFile, \"Functions\", mybuf)>"
            },
            {
                "heading": "Returns",
                "content": "Returns a reference to the model.h source file.\n\nSee LibGetModelDotHFile in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetModelName()",
                "content": "Returns the name of the model (without an extension).\n\nSee LibGetModelName in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetNumSourceFiles()",
                "content": "Returns the number of source files (.c or .cpp and .h) that have been created."
            },
            {
                "heading": "Syntax",
                "content": "%assign numFiles = LibGetNumSourceFiles()"
            },
            {
                "heading": "Returns",
                "content": "Returns the number of files (number).\n\nSee LibGetNumSourceFiles in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetRTModelErrorStatus()",
                "content": "Returns the code required to get the model error status."
            },
            {
                "heading": "Syntax",
                "content": "%<LibGetRTModelErrorStatus()>;\n\nSee LibGetRTModelErrorStatus in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetSourceFileAttribute(fileIdx, attrib)",
                "content": "Returns the specified attribute of a file. The table lists the valid attributes.\n\nAttributeName (with file extension)SystemsInFileIsEmptySharedTypeBaseNameRequiredIncludesIndentCodeTemplateTypeUtilityIncludesWrittenToDiskOutputDirectoryCreatorFilterSharedGroup"
            },
            {
                "heading": "Arguments",
                "content": "fileIdx (scope or number) \u00e2\u0080\u0094 File index\n\nattrib (string) \u00e2\u0080\u0094 Name of model attribute\n\nSee LibGetSourceFileAttribute in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetSourceFileFromIdx(fileIdx)",
                "content": "Returns a model file reference based on its index. This reference can be useful for a common operation on all files, for example, to set the leading file banner of all files."
            },
            {
                "heading": "Syntax",
                "content": "%assign fileH = LibGetSourceFileFromIdx(fileIdx)"
            },
            {
                "heading": "Argument",
                "content": "fileIdx (number) \u00e2\u0080\u0094 Index of model file"
            },
            {
                "heading": "Returns",
                "content": "Reference (scope) to the model file.\n\nSee LibGetSourceFileFromIdx in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetSourceFileSection(fileIdx, section)",
                "content": "Returns the contents of a file. See LibSetSourceFileSection(fileH, section, value) for a list of valid sections."
            },
            {
                "heading": "Arguments",
                "content": "fileIdx (scope or number) \u00e2\u0080\u0094 File index\n\nsection (string) \u00e2\u0080\u0094 File section of interest\n\nSee LibGetSourceFileSection in codetemplatelib.tlc."
            },
            {
                "heading": "LibGetSourceFileTag(fileIdx)",
                "content": "Returns fileName_h and fileName_c for header and source files, respectively, where fileName is the name of the model file."
            },
            {
                "heading": "Syntax",
                "content": "%assign tag = LibGetSourceFileTag(fileIdx)"
            },
            {
                "heading": "Argument",
                "content": "fileIndex (number) \u00e2\u0080\u0094 File index"
            },
            {
                "heading": "Returns",
                "content": "Returns the tag (string).\n\nSee LibGetSourceFileTag in codetemplatelib.tlc."
            },
            {
                "heading": "LibMdlRegCustomCode(buffer, location)",
                "content": "Places declaration statements and executable code inside the model_initialize function."
            },
            {
                "heading": "Arguments",
                "content": "buffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing\n\nSee LibMdlRegCustomCode in hookslib.tlc."
            },
            {
                "heading": "LibMdlStartCustomCode(buffer, location)",
                "content": "Places declaration statements and executable code inside the start function. Start code is executed once, during the model initialization phase."
            },
            {
                "heading": "Syntax",
                "content": "LibMdlStartCustomCode(buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "buffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibMdlStartCustomCode places declaration statements and executable code inside the start function. This code is output into the following functions, depending on the current value for the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemodel_initializeEmbedded-C (if not ModelReferenceCoderTarget)mdlStartEmbedded-C (if ModelReferenceCoderTarget)mdlStartS-FunctionMdlStartRealTime\n\nEach call to LibMdlStartCustomCode appends your buffer to the internal cache buffer.\n\nSee LibMdlStartCustomCode in hookslib.tlc."
            },
            {
                "heading": "LibMdlTerminateCustomCode(buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside the terminate function."
            },
            {
                "heading": "Syntax",
                "content": "LibMdlTerminateCustomCode(buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "buffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibMdlTerminateCustomCode places declaration statements and executable code inside the terminate function. This code is output into the following functions, depending on the current value of the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemodel_terminateEmbedded-CmdlTerminateS-FunctionMdlTerminateRealTime\n\nEach call to LibMdlTerminateCustomCode appends your buffer to the internal cache buffer.\n\nNoteDo not use the LibMdlTerminateCustomCode outside of the \"case 'content' \" section of the TLC code of a custom storage class.\n\nSee LibMdlTerminateCustomCode in hookslib.tlc."
            },
            {
                "heading": "LibNotifySymbolExportedFromFile",
                "content": "Notifies the code generation infrastructure that the symbol is being exported from the file.\n\nThis function is recommended for custom user symbols such as variable, type, macro, and function declarations. The function signals the code generation infrastructure to include appropriate headers when the passed symbol is used in auto generated files."
            },
            {
                "heading": "Arguments",
                "content": "symbol \u00e2\u0080\u0094 Macro, variable, type, or function name, specified as a string.\n\nfileNameWithExtension \u00e2\u0080\u0094 File name with language extension, specified as a string. For example, <modelName>.h."
            },
            {
                "heading": "Example",
                "content": "%openfile myFcnDecl extern real_T myCustomFcn(void); %closefile myFcnDecl %<LibCacheFunctionPrototype(myFcnDecl)> %assign modelPrivateFile = \"%<LibGetMdlPrvHdrBaseName()>.h %<LibNotifySymbolExportedFromFile(\"myCustomFcn\",modelPrivateFile)>"
            },
            {
                "heading": "LibNotifySymbolUsedByFile",
                "content": "Notifies the code generation infrastructure that the symbol is being used by the file.\n\nThis function is recommended for custom user symbols such as variable, type, macro, and function declarations. The function signals the code generation infrastructure to include headers for the symbol passed to the function."
            },
            {
                "heading": "Arguments",
                "content": "symbol \u00e2\u0080\u0094 Macro, variable, type, or function name, specified as a string.\n\nfileNameWithExtension \u00e2\u0080\u0094 File name with language extension, specified as a string. For example, <modelName>.h."
            },
            {
                "heading": "Example",
                "content": "%% The following line is expanded and placed in <model>.c %<y> = myCustomFcn(); %assign modelSrcFile = LibGetModelDotCFile() %<LibNotifySymbolUsedByFile(\"myCustomFcn\",modelSrcFile)>"
            },
            {
                "heading": "LibSetRTModelErrorStatus(str)",
                "content": "Returns the code required to set the model error status."
            },
            {
                "heading": "Syntax",
                "content": "LibSetRTModelErrorStatus(\"\\\"Overrun\\\"\")"
            },
            {
                "heading": "Argument",
                "content": "str (string) \u00e2\u0080\u0094 char * to a C string\n\nSee LibSetRTModelErrorStatus in codetemplatelib.tlc."
            },
            {
                "heading": "LibSetSourceFileCodeTemplate(opFile, name)",
                "content": "By default, *.c and *.h files are generated with the code templates specified in the Code Generation > Templates pane of the Configuration Parameters dialog box. LibSetSourceFileCodeTemplate allows you to change the template for a file.\n\nNoteCustom templates are a feature of the Embedded Coder product."
            },
            {
                "heading": "Syntax",
                "content": "%assign tag = LibSetSourceFileCodeTemplate(opFile,name)"
            },
            {
                "heading": "Arguments",
                "content": "opFile (scope) \u00e2\u0080\u0094 Reference to file\n\nname (string) \u00e2\u0080\u0094 Name of the desired template"
            },
            {
                "heading": "Returns",
                "content": "Nothing\n\nSee LibSetSourceFileCodeTemplate in codetemplatelib.tlc."
            },
            {
                "heading": "LibSetSourceFileCustomSection(file, attrib, value)",
                "content": "Adds to the contents of a custom section previously created with LibAddSourceFileCustomSection. Available only with Embedded Coder software."
            },
            {
                "heading": "Arguments",
                "content": "file (scope or number) \u00e2\u0080\u0094 Source file reference or index\n\nattrib (string) \u00e2\u0080\u0094 Name of custom section\n\nvalue (string) \u00e2\u0080\u0094 Value to be appended to section\n\nSee LibSetSourceFileCustomSection in codetemplatelib.tlc."
            },
            {
                "heading": "LibSetSourceFileOutputDirectory(opFile, name)",
                "content": "By default, *.c and *.h files are generated into a build folder at the current location. LibSetSourceFileOutputDirectory allows you to change the folder into which a specified source file is to be generated. Note that the caller is responsible for specifying a valid folder."
            },
            {
                "heading": "Syntax",
                "content": "%assign tag = LibSetSourceFileOutputDirectory(opFile,dirName)"
            },
            {
                "heading": "Arguments",
                "content": "opFile (scope) \u00e2\u0080\u0094 Reference to file\n\ndirName (string) \u00e2\u0080\u0094 Name of the desired output folder"
            },
            {
                "heading": "Returns",
                "content": "Nothing\n\nSee LibSetSourceFileOutputDirectory in codetemplatelib.tlc."
            },
            {
                "heading": "LibSetSourceFileSection(fileH, section, value)",
                "content": "Adds to the contents of a specified section within a specified file. Valid file sections include\n\nFile SectionDescriptionBannerSet the file banner (comment) at the top of the file.IncludesAppend to the #include section.DefinesAppend to the #define section.IntrinsicTypesAppend to the intrinsic typedef section. Intrinsic types are those that depend only on intrinsic C types.PrimitiveTypedefsAppend to the primitive typedef section. Primitive typedefs are those that depend only on intrinsic C types and typedefs previously defined in the IntrinsicTypes section.UserTopAppend to the User Top section.TypedefsAppend to the typedef section. The typedefs can depend on a previously defined type.EnumsAppend to the enumerated types section.DefinitionsAppend to the data definition section.ExternData(Reserved) Code generator extern data.ExternFcns(Reserved) Code generator extern functions.FcnPrototypes(Reserved) Code generator function prototypes.DeclarationsAppend to the data declaration section.FunctionsAppend to the C functions section.CompilerErrorsAppend to the #error section.CompilerWarnings Append to the #warning section.DocumentationAppend to the documentation (comment) section.UserBottomAppend to the User Bottom section.\n\nThe code generator orders the code as listed above."
            },
            {
                "heading": "Syntax",
                "content": "Example (iterating over the files):\n\n%openfile tmpBuf whatever %closefile tmpBuf %foreach fileIdx = LibGetNumSourceFiles() %assign fileH = LibGetSourceFileFromIdx(fileIdx) %<LibSetSourceFileSection(fileH,\"SectionOfInterest\",tmpBuf)> %endforeach %assign fileH = LibCreateSourceFile(\"Header\",\"Custom\",\"foofile\") %<LibSetSourceFileSection(fileH,\"Defines\",\"#define FOO 5.0\\n\")>"
            },
            {
                "heading": "Arguments",
                "content": "fileH (scope or number) \u00e2\u0080\u0094 Reference or index to a file\n\nsection (string) \u00e2\u0080\u0094 File section of interest\n\nvalue (string) \u00e2\u0080\u0094 Value\n\nSee LibSetSourceFileSection in codetemplatelib.tlc."
            },
            {
                "heading": "LibSystemDerivativeCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside a subsystem's derivative function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemDerivativeCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose derivative function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemDerivativeCustomCode places declaration statements and executable code inside the derivative function for the subsystem specified by system. This code is output into the following functions, depending on the current value of the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemdlDerivativesS-Functionmodel_derivativesRealTime\n\nLibSystemDerivativeCustomCode is not relevant when the value of the CodeFormat TLC variable is Embedded-C, because blocks with continuous states cannot be used.\n\nEach call to LibSystemDerivativeCustomCode appends your buffer to the internal cache buffer. An error is generated if you attempt to add code to a subsystem that does not have continuous states.\n\nSee LibSystemDerivativeCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemDerivativeCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibSystemDisableCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside a subsystem's disable function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemDisableCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose disable function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemDisableCustomCode places declaration statements and executable code inside the disable function for the subsystem specified by system. Each call to LibSystemDisableCustomCode appends your buffer to the internal cache buffer.\n\nAn error is generated if you attempt to add code to a subsystem that does not have a disable function.\n\nSee LibSystemDisableCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemDisableCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibSystemEnableCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside a subsystem's enable function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemEnableCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose enable function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemEnableCustomCode places declaration statements and executable code inside the enable function for the subsystem specified by system. Each call to LibSystemEnableCustomCode appends your buffer to the internal cache buffer.\n\nAn error is generated if you attempt to add code to a subsystem that does not have an enable function.\n\nSee LibSystemEnableCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemEnableCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibSystemInitializeCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside a subsystem's initialize function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemInitializeCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose initialize function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemInitializeCustomCode places declaration statements and executable code inside the initialize function for the subsystem specified by system. This code is output into the following functions, depending on the current value of the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemodel_initializeEmbedded-CmdlInitializeConditionsS-FunctionMdlStartRealTime\n\nCode for a subsystem is output into the subsystem's initialization function. Each call to LibSystemInitializeCustomCode appends your buffer to the internal cache buffer.\n\nNoteEnable systems that are not configured to reset on enable are inlined into MdlStart. For this case, the subsystem's custom code is found in MdlStart above and below the enable subsystem's initialization code.\n\nSee LibSystemInitializeCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemInitializeCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibSystemOutputCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places declaration statements and executable code inside a subsystem's output function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemOutputCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose output function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemOutputCustomCode places declaration statements and executable code inside the output function for the subsystem specified by system. This code is output into the following functions, depending on the current value of the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemodel_stepEmbedded-C (CombineOutputUpdateFcns is 1)model_outputEmbedded-C (CombineOutputUpdateFcns is 0)mdlOutputsS-FunctionMdlOutputsRealTime\n\nEach call to LibSystemOutputCustomCode appends your buffer to the internal cache buffer.\n\nSee LibSystemOutputCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemOutputCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibSystemUpdateCustomCode (system, buffer, location)",
                "content": ""
            },
            {
                "heading": "Purpose",
                "content": "Places code inside a subsystem's update function."
            },
            {
                "heading": "Syntax",
                "content": "LibSystemUpdateCustomCode(system, buffer, location)"
            },
            {
                "heading": "Arguments",
                "content": "system \u00e2\u0080\u0094 Reference to the subsystem whose update function is to be modified.\n\nbuffer \u00e2\u0080\u0094 String buffer containing text to append to the internal cache buffer.\n\nlocation \u00e2\u0080\u0094 String specifying where to place the buffer's contents. Possible values are\n\n\"header\" \u00e2\u0080\u0094 Place buffer at top of function\"declaration\" \u00e2\u0080\u0094 Place buffer at top of function\"execution\" \u00e2\u0080\u0094 Place buffer at top of function, but after header\"trailer\" \u00e2\u0080\u0094 Place buffer at bottom of function"
            },
            {
                "heading": "Returns",
                "content": "Nothing"
            },
            {
                "heading": "Description",
                "content": "LibSystemUpdateCustomCode places declaration statements and executable code inside the update function for the subsystem specified by system. This code is output into the following functions, depending on the current value of the CodeFormat TLC variable:\n\nFunction NameValue of CodeFormat TLC variablemodel_stepEmbedded-C (CombineOutputUpdateFcns is 1)model_updateEmbedded-C (CombineOutputUpdateFcns is 0)mdlUpdateS-FunctionMdlUpdateRealTime\n\nEach call to LibSystemUpdateCustomCode appends your buffer to the internal cache buffer.\n\nSee LibSystemUpdateCustomCode in hookslib.tlc.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use LibSystemUpdateCustomCode to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "LibWriteModelData()",
                "content": "Returns data for the model (valid for ERT only).\n\nSee LibWriteModelData in codetemplatelib.tlc."
            },
            {
                "heading": "LibWriteModelInput(tid, rollThreshold)",
                "content": "Returns the code for writing to a specified root input (that is, a model inport block). This function is valid for ERT only, and not valid for referenced models."
            },
            {
                "heading": "Arguments",
                "content": "tid (number) \u00e2\u0080\u0094 Task identifier (0 is fastest rate and n is the slowest)\n\nrollThreshold \u00e2\u0080\u0094 Width of signal before wrapping in a for loop.\n\nSee LibWriteModelInput in codetemplatelib.tlc."
            },
            {
                "heading": "LibWriteModelInputs()",
                "content": "Returns code that writes to all root inputs (that is, the model inport blocks). This function is valid for ERT only, and is not valid for referenced models.\n\nSee LibWriteModelInputs in codetemplatelib.tlc."
            },
            {
                "heading": "LibWriteModelOutput(tid, rollThreshold)",
                "content": "Returns code that writes to a specified root output (that is, a model outport block). This function is valid for ERT only, and not valid for referenced models."
            },
            {
                "heading": "Arguments",
                "content": "tid (number) \u00e2\u0080\u0094 Task identifier (0 is fastest rate and n is the slowest)\n\nrollThreshold \u00e2\u0080\u0094 Width of signal before wrapping in a for loop.\n\nSee LibWriteModelOutput in codetemplatelib.tlc."
            },
            {
                "heading": "LibWriteModelOutputs()",
                "content": "Returns code that writes to all root outputs (that is, the model outport blocks). This function is valid for ERT only, and not valid for referenced models.\n\nSee LibWriteModelOutputs in codetemplatelib.tlc."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/tlc/code-configuration-functions.html#bp6sftd",
        "images": []
    },
    {
        "title": "Signal Types",
        "introduction": "Multiple types of signals can connect the blocks in a model. For example, a model may contain a control signal to initiate the execution of a block and buses to simplify line routing. This table summarizes the types of Simulink\u00c2\u00ae signals.",
        "chunks": [
            {
                "heading": "Control Signals",
                "content": "A control signal is a signal used by a block to initiate the execution of another block. For example, a signal that executes a function-call or action subsystem is a control signal. When you update or simulate a block diagram, Simulink uses a dash-dot pattern to draw lines that represent the control signals."
            },
            {
                "heading": "Composite Signals",
                "content": "You can group multiple signals in a composite signal, route the signal from block to block, and extract the constituent signals where needed. When you have many parallel signals, composite signals can simplify the appearance of a model and clarify generated code. Composite signals can be virtual or nonvirtual.\n\nFor more information on composite signals, see Composite Interface Guidelines."
            },
            {
                "heading": "Virtual and Nonvirtual Signals",
                "content": "A virtual signal is a signal that graphically represents other signals or parts of other signals. Virtual signals do not exist in generated code. Some blocks, such as the Mux block, always generate virtual signals. Others, such as the Bus Creator block, can generate either virtual or nonvirtual signals. A signal is virtual if the block that generates it is virtual.\n\nA nonvirtual signal is a signal that plays an active role in simulation and code generation. Some blocks, such as the Vector Concatenate block, always generate nonvirtual signals. A signal is nonvirtual if the block that generates it is nonvirtual.\n\nFor information on virtual and nonvirtual blocks, see Nonvirtual and Virtual Blocks."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/signal-types.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/working_with_signals45.png"
        ]
    },
    {
        "title": "Troubleshoot Signal Data Logging from Inport in Referenced Model in Test Harness",
        "introduction": "A Simulink\u00c2\u00ae Test\u00e2\u0084\u00a2 test harness is available for a Simulink Real-Time\u00e2\u0084\u00a2 model. The model has a referenced model that contains an inport whose signal are marked for data logging in the Simulation Data Inspector. During testing, this error occurs:",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "It is not possible to stream signal data from the referenced model inport for logging from within the test harness."
            },
            {
                "heading": "Try This Workaround",
                "content": "Mark the input signals to the model block for logging. This model provides an example workaround. For more information, see the Simulink Test documentation."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-inport-ref-mode-test-harness.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/model-example-harness1-workaround.png"
        ]
    },
    {
        "title": "Group Signals or Messages into Virtual Buses",
        "introduction": "To reduce line complexity and clutter in a block diagram and make incrementally changing an interface easier, use virtual buses. A virtual bus is analogous to a bundle of wires held together by tie wraps. For comparison, a nonvirtual bus is analogous to a structure in C code. You can access the bus as a whole or select specific elements from the bus. When you create a virtual bus, group lines based on their functionality. By organizing signals or messages into logical groupings, you reduce the likelihood of significant refactoring. Not all blocks can accept buses, and some blocks implicitly convert buses to vectors. To learn which blocks support which types of buses, see Bus-Capable Blocks. To identify bus conversions, see Identify Automatic Bus Conversions. How you create virtual buses differs based on the location of the signals or messages that you want to group. To focus on fundamental steps, these examples are simple. However, buses are most useful when you have many signals or messages to group. To create buses at the input or output interface of a component using functions, see Programmatically Create Bus Element Ports. Bus Creator | Bus Selector | In Bus Element | Out Bus Element",
        "chunks": [
            {
                "heading": "Group Signal Lines Within Component",
                "content": "Open Live Script\n\nYou can group signals into a virtual bus within a component by using Bus Creator blocks.\n\nOpen the model named VirtualBusCreation, which contains three blocks.\n\nTo create a bus that contains the outputs from multiple blocks, click and drag to select the blocks. For this example, select the Chirp Signal and Sine Wave blocks. In the action bar that appears, click Create Bus.\n\nThe software adds a Bus Creator block and connects the inputs to that block. The output of the Bus Creator block is a virtual bus.\n\nTo make identifying the elements of the bus easier, label the inputs to the Bus Creator block. Double-click the line between the Chirp Signal block and the Bus Creator block. Then, enter Chirp. Double-click the line between the Sine Wave block and the Bus Creator block. Then, enter Sine.\n\nTo create a second bus that contains the first bus and the output of the Step block, click and drag to select the Bus Creator and Step blocks. In the action bar that appears, click Create Bus. Since the Sine and Chirp signals are elements of the input bus, the software creates the same bus regardless of whether your selection includes the Sine Wave and Chirp Signal blocks.\n\nThe software adds another Bus Creator block and connects the inputs to that block. The output of the Bus Creator block is a virtual bus that contains a nested bus.\n\nYou can nest buses to any depth. If one of the inputs to a Bus Creator block is a bus, then its output is a bus hierarchy that contains at least one nested bus.\n\nLabel the inputs to the new Bus Creator block. Double-click the line between the Step block and the Bus Creator block. Then, enter Step. Double-click the line between the Bus Creator blocks. Then, enter NestedBus. Optionally, arrange the blocks to improve the readability of the model.\n\nConnect the output of the second Bus Creator block to a Scope block and label the output TopBus. To visually identify the buses, compile the model by clicking Update Model or Run on the Modeling tab of the Simulink Toolstrip. Compiling the model updates the line styles."
            },
            {
                "heading": "Connect Multiple Output Signals to a Port",
                "content": "Open Live Script\n\nThis example shows how to group the output signals of a subsystem or model into a virtual bus using Out Bus Element blocks.\n\nOpen the model named VirtualBusOutputCreation, which contains three source blocks.\n\nAdd an Out Bus Element block to the model. Then, connect the Chirp Signal block to the Out Bus Element block.\n\nTo make two copies of the block, press Ctrl and drag the Out Bus Element block twice. When copying the block this way, specify whether to create a new port or use the existing port. To create one output bus that contains all the signals, select New Element each time you copy the block.\n\nConnect the Sine Wave and Step blocks to the Out Bus Element blocks.\n\nThe label next to each Out Bus Element block has two parts. The first part of the label describes the port and uses the default name OutBus. The second part of the label describes a bus element and uses the default name signal1.\n\nTo make identifying elements of a port easier, rename the elements. Optionally, create hierarchy by nesting a bus element in other buses. Add a dot after each bus name. For example:\n\nDouble-click signal1. Then, enter NestedBus.Chirp.Double-click signal2. Then, enter NestedBus.Sine.Double-click signal3. Then, enter Step.\n\nTo inspect the bus hierarchy at the port, double-click any of the Out Bus Element blocks. The dialog box displays a top-level bus named OutBus that contains elements named NestedBus and Step. NestedBus is a nested bus that contains elements named Chirp and Sine.\n\nWhile this example connects a signal to each Out Bus Element block, you can connect a bus to an Out Bus Element block.\n\nThe three Out Bus Element blocks create a virtual bus at the output port of the model. To see the virtual bus, reference the model in another model or move the Out Bus Element blocks into a subsystem. The line styles update when you compile the model. To compile the model, in the Simulink Toolstrip, on the Modeling tab, click Update Model or Run."
            },
            {
                "heading": "Specify Multiple Elements of a Port",
                "content": "When a model or subsystem file requires a bus at a port, define the port with an In Bus Element or Out Bus Element block.\n\nTo specify the elements of a bus element port at an interface, you can:\n\nAdd elements to the interface with or without adding blocks to the block diagram.Define the bus hierarchy with a Simulink.Bus object.\n\nNoteTo specify a Simulink.Bus object as the data type of a bus at a bus element port, an In Bus Element or Out Bus Element block must represent the bus or an element of the bus.\n\nThis example shows how to define an input bus element port at an interface with one block and no Simulink.Bus object.\n\nSuppose the port expects a bus that contains a nested bus named NestedBus and a signal named Step. The nested bus contains signals named Chirp and Sine. Your model or subsystem uses only the signal named Step currently.\n\nIn a blank model or subsystem, add an In Bus Element block. This block creates an input port.\n\nTo rename the element that the block represents, in the block label, double-click signal1. Then, replace signal1 with Step.\n\nOpen the Property Inspector. Then, select the In Bus Element block. Alternatively, double-click the block to open a dialog box.\n\nIn the Property Inspector or dialog box, select the top-level bus named InBus. Then, click the button arrow, and select Add element without block.\n\nThe new element is nested under the previously selected element. The block diagram is unchanged.\n\nThe new element name is gray and italicized to indicate that an In Bus Element block does not represent the element directly.\n\nDouble-click the new element name. Then, enter NestedBus.\n\nTo add an element to the nested bus, select NestedBus. Then, click the button arrow, and select Add element without block.\n\nTo add another bus element, select NestedBus. Then, click the button arrow, and select Add element without block.\n\nTo rename the bus elements from signal and signal2 to Chirp and Sine, respectively, double-click each new element name and enter the new name.\n\nBy adding elements without adding blocks, you can define the entire bus hierarchy with only one In Bus Element block and without a Simulink.Bus object.\n\nTipWhen you want to add many elements without blocks, using the Simulink.Bus.addElementToPort function can be quicker than using the dialog box. For an example, see Programmatically Create Bus Element Ports.\n\nTo specify the properties of an element, pause on the element name. Then, click the pencil button that appears.\n\nThe nondefault attributes appear next to the element name. To further edit the attributes, click an attribute summary next to an element name.\n\nDefining the properties of elements at an interface is useful when you create a file for reuse. The interface definition determines the input that a referenced subsystem or model supports. The hierarchy and properties of the input bus must match the definition at the corresponding port.\n\nSuppose you add elements without blocks then decide that you want In Bus Element blocks that select them. To add blocks for input elements, click an element name or hold Ctrl as you click multiple element names. Then, click . For example, add blocks for Chirp and Sine.\n\nCorresponding In Bus Element blocks appear in the block diagram.\n\nIn the block label, each dot indicates a new level of hierarchy.\n\nFor output bus element ports, the way to add blocks for elements differs slightly. To add blocks for output bus element ports, select an element that an existing Out Bus Element block does not represent. Then, add an Out Bus Element block by clicking . To prevent a conflict where multiple Out Bus Element blocks represent the same element, you can add only one Out Bus Element block at a time.\n\nFor more examples and information, see In Bus Element and Out Bus Element."
            },
            {
                "heading": "Access Elements of Buses",
                "content": "You can access the bus as a whole or select specific signals, messages, or nested buses from the bus.\n\nHow you extract elements from a bus depends on the location of the bus.\n\nWithin a component \u00e2\u0080\u0094 Use a Bus Selector block.At a component interface \u00e2\u0080\u0094 Use an In Bus Element block."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/getting-started-with-buses.html#mw_a65d35f1-6b38-4df8-8484-8803c3d0e263",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/CreateAndUseVirtualBusesExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateAndUseVirtualBusesExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateAndUseVirtualBusesExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateAndUseVirtualBusesExample_04.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateAndUseVirtualBusesExample_05.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_04.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_05.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_06.png",
            "https://in.mathworks.com/help/examples/simulink/win64/CreateVirtualBusesAtInterfacesExample_07.png",
            "https://in.mathworks.com/help/simulink/ug/in_bus_element_block_icon.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-rename.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-element-button.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-blockless-element-example.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-added-element.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-nested-bus-named.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-element-button.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-bus-element-1.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-element-button.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-bus-element-2.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-new-hierarchy.png",
            "https://in.mathworks.com/help/simulink/ug/bus-port-pencil-button.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-specify-attributes.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-specification.png",
            "https://in.mathworks.com/help/simulink/ug/bus-port-add-block-button.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-add-blocks-example.png",
            "https://in.mathworks.com/help/simulink/ug/in-bus-element-added-blocks.png",
            "https://in.mathworks.com/help/simulink/ug/bus-port-add-block-button.png"
        ]
    },
    {
        "title": "Execution of Code Generated from a Model",
        "introduction": "The code generator produces algorithmic code as defined by your model. You can include external (for example, custom or legacy) code in a model by using techniques explained in Choose an External Code Integration Workflow. The code generator also provides an interface that executes the generated model code. The interface and model code are compiled together to create an executable program. The next figure shows a high-level object-oriented view of the executable. In general, the conceptual design of the model execution driver does not change between the rapid prototyping and embedded style of generated code. The following sections describe model execution for single-tasking and multitasking environments both for simulation (non-real-time) and for real time. For most model code, the multitasking environment provides the most efficient model execution (that is, fastest sample rate). The following concepts are useful in describing how model code executes.",
        "chunks": [
            {
                "heading": "Program Execution",
                "content": "The code generated from a model executes in the context of a target environment. A real-time program cannot require 100% of a the target system CPU time. This requirement provides the system an opportunity to run background tasks during the time the CPU does not spend on the real-time program. Background tasks include operations such as writing data to a buffer or file, allowing access to program data by third-party data monitoring tools, or updating program parameters. For a program to execute in real time, it is important that the program be able to preempt background tasks to run as required.\n\nThe way that a program manages its tasks depends on capabilities of the target environment in which it runs. In a real-time system, execution of code generated from a model can be done with the aid of a real-time operating system or on bare-metal target hardware, where the generated code runs in the context of an interrupt service routine (ISR). Unlike general-purpose multitasking operating systems, which are unable to guarantee hard real-time performance, real-time operating systems and ISR solutions on bare-metal hardware provide capabilities for handling context switching and task scheduling necessary to avoid missed deadlines.\n\nIn systems where one process can exist at a time, an ISR must save the processor context, execute the model code, collect data, and restore the processor context. Operating systems, such as POSIX-compliant systems, provide automatic context switching and task scheduling. This simplifies the operations performed by the ISR. In this case, the ISR enables execution of the model code as a task, which is normally blocked.\n\nThis figure shows this difference between program execution on a bare-metal system that uses an ISR and program execution that uses a real-time operating system primitive."
            },
            {
                "heading": "Program Timing",
                "content": "Real-time programs require careful timing of the task invocations (either by using an interrupt or a real-time operating system tasking primitive) so that the model code executes to completion before another task invocation occurs. The timing includes time to read and write data to and from external hardware.\n\nConsider these scenarios that demonstrate the significance of the time interval configuration.\n\nIn one scenario, the time interval between consecutive invocations is sufficient for the code to complete the execution.In the other scenario, the time interval between consecutive invocations is insufficient for the code to complete the execution.\n\nThis figure illustrates the interrupt timing scenarios.\n\nTask Timing\n\nThe sample interval must be long enough to allow model code execution between task invocations.\n\nIn the figure above, the time between two adjacent vertical arrows is the sample interval. The empty boxes in the upper diagram show an example of a program that can complete one step within the interval and still allow time for the background task. The gray box in the lower diagram indicates what happens if the sample interval is too short. Another task invocation occurs before the task is complete. Such timing results in an execution error.\n\nIf the real-time program is designed to run forever (that is, the final time is 0 or infinite so that the while loop never exits), then the shutdown code does not execute.\n\nFor more information on how the timing engine works, see Timer Representation and Computation."
            },
            {
                "heading": "External Mode Communication",
                "content": "External mode allows communication between the Simulink\u00c2\u00ae block diagram and the standalone program that is built from the generated code. In this mode, the real-time program functions as an interprocess communication server, responding to requests from the Simulink engine."
            },
            {
                "heading": "Data Logging in Single-Tasking and Multitasking Model Execution",
                "content": "Configure Model for Debugging explains how you can save system states, output, and time to a MAT-file or MDF file at the completion of the model execution. The LogTXY function, which performs data logging, operates differently in single-tasking and multitasking environments.\n\nIf you examine how LogTXY is called in the single-tasking and multitasking environments, notice that for single-tasking LogTXY is called after ModelOutputs. During this ModelOutputs call, blocks that have a hit at time t execute, whereas in multitasking, LogTXY is called after ModelOutputs(tid=0), which executes only the blocks that have a hit at time t and that have a task identifier of 0. This results in differences in the logged values between single-tasking and multitasking logging. Specifically, consider a model with two sample times, the faster sample time having a period of 1.0 second and the slower sample time having a period of 10.0 seconds. At time t = k*10, k=0,1,2... both the fast (tid=0) and slow (tid=1) blocks execute. When executing in multitasking mode, when LogTXY is called, the slow blocks execute, but the previous value is logged, whereas in single-tasking the current value is logged.\n\nAnother difference occurs when logging data in an enabled subsystem. Consider an enabled subsystem that has a slow signal driving the enable port and fast blocks within the enabled subsystem. In this case, the evaluation of the enable signal occurs in a slow task, and the fast blocks see a delay of one sample period; thus the logged values will show these differences.\n\nTo summarize differences in logged data between single-tasking and multitasking, differences will be seen when\n\nA root outport block has a sample time that is slower than the fastest sample timeA block with states has a sample time that is slower than the fastest sample timeA block in an enabled subsystem where the signal driving the enable port is slower than the rate of the blocks in the enabled subsystem\n\nFor the first two cases, even though the logged values are different between single-tasking and multitasking, the model results are not different. The only real difference is where (at what point in time) the logging is done. The third (enabled subsystem) case results in a delay that can be seen in a real-time environment."
            },
            {
                "heading": "Non-Real-Time Single-Tasking Systems",
                "content": "This pseudocode shows the execution of a model for a non-real-time single-tasking system.\n\nmain() { Initialization While (time < final time) ModelOutputs -- Major time step. LogTXY -- Log time, states and root outports. ModelUpdate -- Major time step. Integrate -- Integration in minor time step for -- models with continuous states. ModelDerivatives Do 0 or more ModelOutputs ModelDerivatives EndDo -- Number of iterations depends upon the solver Integrate derivatives to update continuous states. EndIntegrate EndWhile Termination }\n\nThe initialization phase begins first. This consists of initializing model states and setting up the execution engine. The model then executes, one step at a time. First ModelOutputs executes at time t, then the workspace I/O data is logged, and then ModelUpdate updates the discrete states. Next, if your model has continuous states, ModelDerivatives integrates the continuous states' derivatives to generate the states for time tnew=t+h, where h is the step size. Time then moves forward to tnew and the process repeats.\n\nDuring the ModelOutputs and ModelUpdate phases of model execution, only blocks that reach the current point in time execute."
            },
            {
                "heading": "Non-Real-Time Multitasking Systems",
                "content": "This pseudocode shows the execution of a model for a non-real-time multitasking system.\n\nmain() { Initialization While (time < final time) ModelOutputs(tid=0) -- Major time step. LogTXY -- Log time, states, and root -- outports. ModelUpdate(tid=0) -- Major time step. Integrate -- Integration in minor time step for -- models with continuous states. ModelDerivatives Do 0 or more ModelOutputs(tid=0) ModelDerivatives EndDo (Number of iterations depends upon the solver.) Integrate derivatives to update continuous states. EndIntegrate For i=1:NumTids ModelOutputs(tid=i) -- Major time step. ModelUpdate(tid=i) -- Major time step. EndFor EndWhile Termination }\n\nMultitasking operation is more complex than single-tasking execution because the output and update functions are subdivided by the task identifier (tid) that is passed into these functions. This allows for multiple invocations of these functions with different task identifiers using overlapped interrupts, or for multiple tasks when using a real-time operating system. In simulation, multiple tasks are emulated by executing the code in the order that would occur if preemption did not exist in a real-time system.\n\nMultitasking execution assumes that task rates are multiples of the base rate. The Simulink product enforces this when you create a fixed-step multitasking model. The multitasking execution loop is very similar to that of single-tasking, except for the use of the task identifier (tid) argument to ModelOutputs and ModelUpdate.\n\nYou cannot use tid values from code generated by a target file and not by Simulink Coder\u00e2\u0084\u00a2. Simulink Coder tracks the use of tid when generating code for a specific subsystem or function type. When you generate code in a target file, this argument cannot be tracked because the scope does not have subsystem or function type. Therefore, tid becomes an undefined variable and your target file fails to compile."
            },
            {
                "heading": "Real-Time Single-Tasking Systems",
                "content": "This pseudocode shows the execution of a model in a real-time single-tasking system where the model is run at interrupt level.\n\nrtOneStep() { Check for interrupt overflow Enable \"rtOneStep\" interrupt ModelOutputs -- Major time step. LogTXY -- Log time, states and root outports. ModelUpdate -- Major time step. Integrate -- Integration in minor time step for models -- with continuous states. ModelDerivatives Do 0 or more ModelOutputs ModelDerivatives EndDo (Number of iterations depends upon the solver.) Integrate derivatives to update continuous states. EndIntegrate } main() { Initialization (including installation of rtOneStep as an interrupt service routine, ISR, for a real-time clock). While(time < final time) Background task. EndWhile Mask interrupts (Disable rtOneStep from executing.) Complete any background tasks. Shutdown }\n\nReal-time single-tasking execution is very similar to non-real-time single-tasking execution, except that instead of free-running the code, the rt_OneStep function is driven by a periodic timer interrupt.\n\nAt the interval specified by the program's base sample rate, the interrupt service routine (ISR) preempts the background task to execute the model code. The base sample rate is the fastest in the model. If the model has continuous blocks, then the integration step size determines the base sample rate.\n\nFor example, if the model code is a controller operating at 100 Hz, then every 0.01 seconds the background task is interrupted. During this interrupt, the controller reads its inputs from the analog-to-digital converter (ADC), calculates its outputs, writes these outputs to the digital-to-analog converter (DAC), and updates its states. Program control then returns to the background task. These steps must occur before the next interrupt."
            },
            {
                "heading": "Real-Time Multitasking Systems",
                "content": "This pseudocode shows how a model executes in a real-time multitasking system where the model is run at interrupt level.\n\nrtOneStep() { Check for interrupt overflow Enable \"rtOneStep\" interrupt ModelOutputs(tid=0) -- Major time step. LogTXY -- Log time, states and root outports. ModelUpdate(tid=0) -- Major time step. Integrate -- Integration in minor time step for -- models with continuous states. ModelDerivatives Do 0 or more ModelOutputs(tid=0) ModelDerivatives EndDo (Number of iterations depends upon the solver.) Integrate derivatives and update continuous states. EndIntegrate For i=1:NumTasks If (hit in task i) ModelOutputs(tid=i) ModelUpdate(tid=i) EndIf EndFor } main() { Initialization (including installation of rtOneStep as an interrupt service routine, ISR, for a real-time clock). While(time < final time) Background task. EndWhile Mask interrupts (Disable rtOneStep from executing.) Complete any background tasks. Shutdown }\n\nRunning models at interrupt level in a real-time multitasking environment is very similar to the previous single-tasking environment, except that overlapped interrupts are employed for concurrent execution of the tasks.\n\nThe execution of a model in a single-tasking or multitasking environment when using real-time operating system tasking primitives is very similar to the interrupt-level examples discussed above. The pseudocode below is for a single-tasking model using real-time tasking primitives.\n\ntSingleRate() { MainLoop: If clockSem already \"given\", then error out due to overflow. Wait on clockSem ModelOutputs -- Major time step. LogTXY -- Log time, states and root -- outports ModelUpdate -- Major time step Integrate -- Integration in minor time step -- for models with continuous -- states. ModelDeriviatives Do 0 or more ModelOutputs ModelDerivatives EndDo (Number of iterations depends upon the solver.) Integrate derivatives to update continuous states. EndIntegrate EndMainLoop } main() { Initialization Start/spawn task \"tSingleRate\". Start clock that does a \"semGive\" on a clockSem semaphore. Wait on \"model-running\" semaphore. Shutdown }\n\nIn this single-tasking environment, the model executes as real-time operating system tasking primitives. In this environment, create a single task (tSingleRate) to run the model code. This task is invoked when a clock tick occurs. The clock tick gives a clockSem (clock semaphore) to the model task (tSingleRate). The model task waits for the semaphore before executing. The clock ticks occur at the fundamental step size (base rate) for your model."
            },
            {
                "heading": "Multitasking Systems Using Real-Time Tasking Primitives",
                "content": "This pseudocode is for a multitasking model using real-time tasking primitives.\n\ntSubRate(subTaskSem,i) { Loop: Wait on semaphore subTaskSem. ModelOutputs(tid=i) ModelUpdate(tid=i) EndLoop } tBaseRate() { MainLoop: If clockSem already \"given\", then error out due to overflow. Wait on clockSem For i=1:NumTasks If (hit in task i) If task i is currently executing, then error out due to overflow. Do a \"semGive\" on subTaskSem for task i. EndIf EndFor ModelOutputs(tid=0) -- major time step. LogTXY -- Log time, states and root outports. ModelUpdate(tid=0) -- major time step. Loop: -- Integration in minor time step for -- models with continuous states. ModelDeriviatives Do 0 or more ModelOutputs(tid=0) ModelDerivatives EndDo (number of iterations depends upon the solver). Integrate derivatives to update continuous states. EndLoop EndMainLoop } main() { Initialization Start/spawn task \"tSubRate\". Start/spawn task \"tBaseRate\". Start clock that does a \"semGive\" on a clockSem semaphore. Wait on \"model-running\" semaphore. Shutdown }\n\nIn this multitasking environment, the model is executed using real-time operating system tasking primitives. Such environments require several model tasks (tBaseRate and several tSubRate tasks) to run the model code. The base rate task (tBaseRate) has a higher priority than the subrate tasks. The subrate task for tid=1 has a higher priority than the subrate task for tid=2, and so on. The base rate task is invoked when a clock tick occurs. The clock tick gives a clockSem to tBaseRate. The first thing tBaseRate does is give semaphores to the subtasks that have a hit at the current point in time. Because the base rate task has a higher priority, it continues to execute. Next it executes the fastest task (tid=0), consisting of blocks in your model that have the fastest sample time. After this execution, it resumes waiting for the clock semaphore. The clock ticks are configured to occur at the fundamental step size for your model."
            },
            {
                "heading": "Rapid Prototyping and Embedded Model Execution Differences",
                "content": "The rapid prototyping program framework provides a common application programming interface (API) that does not change between model definitions.\n\nThe Embedded Coder\u00c2\u00ae product provides a different framework called the embedded program framework. The embedded program framework provides an optimized API that is tailored to your model. When you use the embedded style of generated code, you are modeling how you would like your code to execute in your embedded system. Therefore, the definitions defined in your model should be specific to your embedded targets. Items such as the model name, parameter, and signal storage class are included as part of the API for the embedded style of code.\n\nOne major difference between the rapid prototyping and embedded style of generated code is that the latter contains fewer entry-point functions. The embedded style of code can be configured to have only one function, model_step.\n\nThus, model execution code eliminates Loop...EndLoop statements and groups ModelOutputs, LogTXY, and ModelUpdate into a single statement, model_step.\n\nFor more information about how generated embedded code executes, see Configure Generated C Function Interface for Model Entry-Point Functions."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/about-model-execution.html#f17854",
        "images": []
    },
    {
        "title": "Write Noninlined S-Function",
        "introduction": "A noninlined S-function is a C or C++ MEX S-function that is treated identically by the Simulink\u00c2\u00ae engine and by the generated code. You implement your algorithm once according to the S-function API. The Simulink engine and generated code call the S-function routines (for example, mdlOutputs) during model execution. Noninlined S-functions are identified by the absence of an sfunction.tlc file for your S-function. The file name varies depending on your platform. For example, on a 64-bit Microsoft\u00c2\u00ae Windows\u00c2\u00ae system, the file name is sfunction.mexw64. In the MATLAB\u00c2\u00ae Command Window, type mexext to see which extension your system uses.",
        "chunks": [
            {
                "heading": "Guidelines for Writing Noninlined S-Functions",
                "content": "The MEX-file cannot call MATLAB functions.If the MEX-file uses functions in the MATLAB External Interface libraries, include the header file cg_sfun.h instead of mex.h or simulink.c. For the header file cg_sfun.h, at the end of your S-function, include these lines:#ifdef MATLAB_MEX_FILE /* Is this file being compiled as a MEX-file? */ #include \"simulink.c\" /* MEX-file interface mechanism */ #else #include \"cg_sfun.h\" /* Code generation registration function */ #endifUse only the MATLAB API function that the code generator supports. The supported API functions are:mxGetDoublesmxGetEpsmxGetInf mxGetMmxGetNmxGetNaNmxGetPr (Not recommended. Use mxGetDoubles instead.)mxGetScalarmxGetStringmxIsEmptymxIsFinitemxIsInfMEX library calls are not supported in generated code. To use such calls in the MEX-file and not in the generated code, add the following condition:#ifdef MATLAB_MEX_FILE #endifUse only full matrices that contain only real data.Do not specify a return value for calls to mxGetString. If you do specify a return value, the MEX-file does not compile. Instead, use the second input argument of the function, which returns a pointer to a character vector.Use the correct #define s-function_name statement. The S-function name that you specify must match the S-function file name.If possible, use the data types real_T and int_T instead of double and int. The data types real_T and int_T are more generic and can be used in multiple environments.Provide the build process with the names of the modules used to build the S-function. Use a template make file, the set_param function, or the S-function modules field of the S-Function block parameters dialog box. For example, suppose that you build your S-function with this command:mex sfun_main.c sfun_module1.c sfun_module2.cYou can then use the following call to set_param to include the required modules:set_param(sfun_block, \"SFunctionModules\",\"sfun_module1 sfun_module2\")When you are ready to generate code, force the code generator to rebuild the top model. For more information, see Control Regeneration of Top Model Code."
            },
            {
                "heading": "Noninlined S-Function Parameter Type Limitations",
                "content": "Parameters to noninlined S-functions can be of the following types only:\n\nDouble precision Characters in scalars, vectors, or 2-D matrices\n\nFor more flexibility in the type of parameters that you can supply to S-functions or the operations in the S-function, inline your S-function and consider using an mdlRTW S-function routine.\n\nUse of other functions from the MATLAB matrix.h API or other MATLAB APIs, such as mex.h and mat.h, are not supported. If you call unsupported APIs from an S-function source file, compiler errors occur. For details on supported MATLAB API functions, see the files matlabroot/rtw/c/src/rt_matrx.h and matlabroot/rtw/c/src/rt_matrx.c\n\nIf you use mxGetPr on an empty matrix, the function does not return NULL. It returns a random value. Therefore, you must protect calls to mxGetPr by using mxIsEmpty."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/write-noninlined-s-function.html",
        "images": []
    },
    {
        "title": "Write Wrapper S-Function and TLC Files",
        "introduction": "Create S-functions that work seamlessly with the Simulink\u00c2\u00ae and code generator products by using the wrapper concept. You can:",
        "chunks": [
            {
                "heading": "MEX S-Function Wrapper",
                "content": "Creating S-functions by using an S-function wrapper enables you to insert C/C++ code algorithms in Simulink models and the generated code with little or no change to your original C/C++ function. A MEX S-function wrapper is an S-function that calls code, which resides in another module.\n\nNoteUse a MEX S-function wrapper only in the MATLAB\u00c2\u00ae version in which you created the wrapper.\n\nSuppose that you have an algorithm (that is, a C function) called my_alg that resides in the file my_alg.c. You can integrate my_alg into a Simulink model by creating a MEX S-function wrapper (for example, wrapsfcn.c). A Simulink model can then call my_alg from an S-Function block. The Simulink S-function contains a set of empty functions that the Simulink engine requires for various API related purposes. For example, although only mdlOutputs calls my_alg, the engine calls mdlTerminate, even though this S-function routine performs no action.\n\nYou can embed the call to my_alg in the generated code by creating a TLC S-function wrapper (for example, wrapsfcn.tlc). You can eliminate the empty function calls. You can avoid the overhead of executing the mdlOutputs function and you can then eliminate the my_alg function.\n\nWrapper S-functions are useful when you are creating algorithms that are procedural or when you are integrating legacy code into a Simulink model. If you want to create code that is:\n\nInterpretive in nature (that is, highly parameterized by operating modes) Heavily optimized (that is, no extra tests to decide what mode the code is operating in)\n\nthen you must create a fully inlined TLC file for your S-function.\n\nThe next figure shows the wrapper S-function concept.\n\nUsing an S-function wrapper to import algorithms into your Simulink model means that the S-function serves as an interface that calls your C/C++ algorithms from mdlOutputs. You can quickly integrate large standalone C/C++ programs into your model without having to change the code.\n\nThis sample model includes an S-function wrapper.\n\nTwo files are associated with the wrapsfcn block: the S-function wrapper and the C/C++ code that contains the algorithm. The first three statements:\n\nDefine the name of the S-function (what you enter in the Simulink S-Function block dialog box).Specify that the S-function is using the level 2 format.Provide access to the SimStruct data structure. SimStruct contains pointers to data used during simulation and code generation and defines macros that store data in and retrieve data from the SimStruct.\n\n#define S_FUNCTION_NAME wrapsfcn #define S_FUNCTION_LEVEL 2 #include \"simstruc.h\" extern real_T my_alg(real_T u); /* Declare my_alg as extern */ /* * mdlInitializeSizes - initialize the sizes array */ static void mdlInitializeSizes(SimStruct *S) { ssSetNumSFcnParams( S, 0); /*number of input arguments*/ if (!ssSetNumInputPorts(S, 1)) return; ssSetInputPortWidth(S, 0, 1); ssSetInputPortDirectFeedThrough(S, 0, 1); if (!ssSetNumOutputPorts(S,1)) return; ssSetOutputPortWidth(S, 0, 1); ssSetNumSampleTimes( S, 1); } /* * mdlInitializeSampleTimes - indicate that this S-function runs \u00c2 *\u00c2 at the rate of the source (driving block) */ static void mdlInitializeSampleTimes(SimStruct *S) { ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME); ssSetOffsetTime(S, 0, 0.0); } /* * mdlOutputs - compute the outputs by calling my_alg, which *\u00c2 resides in another module, my_alg.c */ static void mdlOutputs(SimStruct *S, int_T tid) { InputRealPtrsType uPtrs = ssGetInputPortRealSignalPtrs(S,0); real_T *y = ssGetOutputPortRealSignal(S,0); \u00c2 \u00c2 \u00c2 \u00c2 *y = my_alg(*uPtrs[0]); /* Call my_alg in mdlOutputs */ } /* * mdlTerminate - called when the simulation is terminated. */ static void mdlTerminate(SimStruct *S) { } #ifdef MATLAB_MEX_FILE /* Is this file being compiled as a MEX-file? */ #include \"simulink.c\" /* MEX-file interface mechanism */ #else #include \"cg_sfun.h\" /* Code generation registration function */ #endif\n\nFor more information, see Templates for C S-Functions.\n\nThe S-function routine mdlOutputs contains a function call to my_alg, which is the C function containing the algorithm that the S-function performs. For my_alg.c, the code is:\n\n#ifdef MATLAB_MEX_FILE #include \"tmwtypes.h\" #else #include \"rtwtypes.h\" #endif real_T my_alg(real_T u) { return(u * 2.0); }\n\nFor more information, see Manage Build Process File Dependencies.\n\nThe wrapper S-function wrapsfcn calls my_alg, which computes u * 2.0. To build wrapsfcn.mex, use this command:\n\nmex wrapsfcn.c my_alg.c"
            },
            {
                "heading": "TLC S-Function Wrapper",
                "content": "A TLC S-function wrapper is a TLC file that specifies how the code generator calls your code. For example, you can inline the call to my_alg in the mdlOutputs section of the generated code. In the MEX S-Function Wrapper example, the call to my_alg is embedded in the mdlOutputs section as:\n\n*y = my_alg(*uPtrs[0]);\n\nWhen you are creating a TLC S-function wrapper, the goal is to embed the same type of call in the generated code.\n\nLook at how the code generator executes S-functions that are not inlined. A noninlined S-function is identified by the absence of the file sfunction.tlc and the existence of sfunction.mex. When generating code for a noninlined S-function, the code generator produces a call to mdlOutputs through a function pointer that, in this example, then calls my_alg.\n\nThe wrapper example contains one S-function, wrapsfcn.mex. You must compile and link an additional module, my_alg, with the generated code. At the MATLAB command prompt, enter:\n\nset_param('wrapper/S-Function','SFunctionModules','my_alg')"
            },
            {
                "heading": "Code Overhead for Noninlined S-Functions",
                "content": "The code generated when using grt.tlc as the system target file without wrapsfcn.tlc is:\n\n<Generated code comments for wrapper model with noninlined wrapsfcn S-function> #include <math.h> #include <string.h> #include \"wrapper.h\" #include \"wrapper.prm\" /* Start the model */ void mdlStart(void) { /* (start code not required) */ } /* Compute block outputs */ void mdlOutputs(int_T tid) { /* Sin Block: <Root>/Sin */ rtB.Sin = rtP.Sin.Amplitude * sin(rtP.Sin.Frequency * ssGetT(rtS) + rtP.Sin.Phase); /* Level2 S-Function Block: <Root>/S-Function (wrapsfcn) */ \u00c2 { /* Noninlined S-functions create a SimStruct object and * generate a call to S-function routine mdlOutputs */ SimStruct *rts = ssGetSFunction(rtS, 0); sfcnOutputs(rts, tid); } /* Outport Block: <Root>/Out */ rtY.Out = rtB.S_Function; } /* Perform model update */ void mdlUpdate(int_T tid) { /* (update code not required) */ } /* Terminate function */ void mdlTerminate(void) { /* Level2 S-Function Block: <Root>/S-Function (wrapsfcn) */ \u00c2 \u00c2 { /* Noninlined S-functions require a SimStruct object and * the call to S-function routine mdlTerminate */ SimStruct *rts = ssGetSFunction(rtS, 0); sfcnTerminate(rts); } } #include \"wrapper.reg\" /* [EOF] wrapper.c */\n\nThe wrapper.reg generated file contains the initialization of the SimStruct for the wrapper S-Function block. There is one child SimStruct for each S-Function block in your model. You can significantly reduce this overhead by creating a TLC wrapper for the S-function."
            },
            {
                "heading": "Inline a Wrapper S-Function",
                "content": "The generated code makes the call to your S-function, wrapsfcn.c, in mdlOutputs by using this code:\n\nSimStruct *rts = ssGetSFunction(rtS, 0); sfcnOutputs(rts, tid);\n\nThis call has computational overhead associated with it. The Simulink engine creates a SimStruct data structure for the S-Function block. The code generator constructs a call through a function pointer to execute mdlOutputs, then mdlOutputs calls my_alg. By inlining the call to your C/C++ algorithm, my_alg, you can eliminate both the SimStruct and the extra function call, thereby improving the efficiency and reducing the size of the generated code.\n\nInlining a wrapper S-function requires an sfunction.tlc file for the S-function. The TLC file must contain the function call to my_alg. The figure shows the relationships between the algorithm, the wrapper S-function, and the sfunction.tlc file.\n\nTo inline the call to my_alg, place your function call in an sfunction.tlc file with the same name as the S-function (in this example, wrapsfcn.tlc). The Target Language Compiler overrides the default method of placing calls to your S-function in the generated code.\n\nThis code is the TLC file wrapsfcn.tlc that inlines wrapsfcn.c:\n\n%% File : wrapsfcn.tlc %% Abstract: %% Example inlined tlc file for S-function wrapsfcn.c %% %implements \"wrapsfcn\" \"C\" %% Function: BlockTypeSetup ==================================================== %% Abstract: %% Create function prototype in model.h as: %% \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \"extern real_T my_alg(real_T u);\" %% %function BlockTypeSetup(block, system) void %openfile buffer \u00c2 \u00c2 \u00c2 \u00c2 extern real_T my_alg(real_T u); /* This line is placed in wrapper.h */ %closefile buffer %<LibCacheFunctionPrototype(buffer)> %endfunction %% BlockTypeSetup %% Function: Outputs =========================================================== %% Abstract: %% y = my_alg( u ); %% %function Outputs(block, system) Output /* %<Type> Block: %<Name> */ %assign u = LibBlockInputSignal(0, \"\", \"\", 0) %assign y = LibBlockOutputSignal(0, \"\", \"\", 0) %% PROVIDE THE CALLING STATEMENT FOR \"algorithm\" %% The following line is expanded and placed in mdlOutputs within wrapper.c \u00c2 \u00c2 %<y> = my_alg(%<u>); %endfunction %% Outputs\n\nThe first section of this code inlines the wrapsfcn S-Function block and generates the code in C:\n\n%implements \"wrapsfcn\" \"C\"\n\nThe next task is to inform the code generator that the routine my_alg must be declared as external in the generated wrapper.h file for any wrapsfcn S-Function blocks in the model. Do this declaration once for all wrapsfcn S-Function blocks by using the BlockTypeSetup function. In this function, you direct the Target Language Compiler to create a buffer and cache the my_alg as extern in the wrapper.h generated header file.\n\nThe final step is the inlining of the call to the function my_alg. The Outputs function inlines the call. In this function, you access the block input and output and place a direct call to my_alg. The call is embedded in wrapper.c."
            },
            {
                "heading": "The Inlined Code",
                "content": "The code generated when you inline your wrapper S-function is similar to the default generated code. The mdlTerminate function does not contain a call to an empty function and the mdlOutputs function now directly calls my_alg.\n\nvoid mdlOutputs(int_T tid) { /* Sin Block: <Root>/Sin */ rtB.Sin = rtP.Sin.Amplitude * sin(rtP.Sin.Frequency * ssGetT(rtS) + rtP.Sin.Phase); /* S-Function Block: <Root>/S-Function */ \u00c2 \u00c2 rtB.S_Function = my_alg(rtB.Sin); /* Inlined call to my_alg */ \u00c2 \u00c2 /* Outport Block: <Root>/Out */ rtY.Out = rtB.S_Function; }\n\nwrapper.reg does not create a child SimStruct for the S-function because the generated code is calling my_alg directly, eliminating over 1 KB of memory usage."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/write-wrapper-s-function-and-tlc-files.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/sfunction_wrapper_concept_block_diagram_11a.png",
            "https://in.mathworks.com/help/rtw/ug/ex_mexsfuncwrap_model.png",
            "https://in.mathworks.com/help/rtw/ug/inlining_alg_with_tlc_11a.png"
        ]
    },
    {
        "title": "Vector CANape Limitations",
        "introduction": "For Vector CANape\u00c2\u00ae, the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 software does not support: Event mode data acquisition has the following limitations:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/vector-canape-limitations-and-troubleshooting.html",
        "images": []
    },
    {
        "title": "Import FMUs",
        "introduction": "Use the FMU block to import Functional Mockup Units (FMUs) into Simulink\u00c2\u00ae. The FMU block automatically selects the FMU mode based on the existing FMU you want to import: This block supports FMI versions 1.0, 2.0 and 3.0. For FMI version 2.0 and 3.0, if your FMU contains both Co-Simulation and Model Exchange elements, the block detects this state and prompts you to select the operation mode for the block. You can use your FMU block as you do other Simulink blocks. The FMU block supports normal, rapid accelerator, and accelerator modes. Rapid accelerator mode is unsupported for FMU blocks with FMU logging. This topic assumes that you provide a .fmu file. FMU",
        "chunks": [
            {
                "heading": "FMU XML File Directives",
                "content": "The default parameter values derive from the corresponding parameter start value defined in the FMU ModelDescription.xml file. A block parameter value overwrites the initial value of the corresponding parameter defined in the FMU binary implementation.\n\nSimulink interprets these FMU tags accordingly.\n\nFMU TagSimulinkScalarVariable has attributes set as follows: causality=\"none\" or causality=\"internal\"variability=\"parameter\"start value is defined Interprets ScalarVariable element as block parameterRealInterprets block parameter as edit fieldIntegerInterprets block parameter as edit fieldBooleanInterprets block parameter as check boxEnumerationInterprets block parameter as drop-down listStringInterprets as UTF-8 encoded string\n\nThe FMU block supports the following encoding formats for the model description XML file:\n\nISO-8859\u00e2\u0080\u00931UTF-8UTF-16"
            },
            {
                "heading": "Additional Support and Limitations",
                "content": "CapabilityFMI Version 3.0 SupportFMI Version 2.0 SupportFMI Version 1.0 SupportSave model operating point to base workspace (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true) (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true)\u00c2 Fast restart (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.) (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.)\u00c2 Simulation Stepper (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.) (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.)\u00c2 Solver Jacobian (FMU flags that it supports this feature by setting providesDirectionalDerivatives field in its model description XML to true.) (FMU flags that it supports this feature by setting providesDirectionalDerivatives field in its model description XML to true.)\u00c2 Linearize models (FMU flags that it supports this feature by setting providesDirectionalDerivatives field in its model description XML to true.) (FMU flags that it supports this feature by setting providesDirectionalDerivatives field in its model description XML to true.)\u00c2 Declare parameter as tunable and tune it during simulation (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.) (FMU flags that it supports this feature by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true.)\u00c2 For Each subsystem blocks (Supported only when canBeInstantiatedOnlyOncePerProcess attribute is set to false in modelDescription.xml file) (Supported only when canBeInstantiatedOnlyOncePerProcess attribute is set to false in modelDescription.xml file)\u00c2 Parameters of type string (Array of string type parameters are not supported) Rapid accelerator mode Software-in-the-loop (SIL) and processor-in-the-loop (PIL) modes\u00c2 \u00c2 \u00c2 Code generation Nested FMU export Protected model export Model coverage\u00c2 \u00c2 \u00c2 Simulink Design Verifier\u00e2\u0084\u00a2\u00c2 \u00c2 \u00c2 Model reference in accelerator mode Event Mode \u00c2 \u00c2 Scheduled Execution Mode\u00c2 \u00c2 \u00c2 Enumerated data type for inputs, outputs and parameters \u00c2\n\nSimulink supports stepping back and forth, tuning parameters in between, and saving states for the FMU Import block as long as the FMU itself supports these features. FMU flags that it supports these features by setting canGetAndSetFMUstate and canSerializeFMUstate fields in its model description XML to true."
            },
            {
                "heading": "FMU Import Examples",
                "content": "ExampleDescription Import Co-Simulation FMU into Simulink This model shows how to use the FMU block to load an FMU file that supports Co-Simulation mode. Importing a Model Exchange FMU into Simulink This model shows how to use the FMU block to load an FMU file that supports Model Exchange mode. Simplify Interface for Structured Data with FMU Import Block This model shows how to use buses and structure parameters in an FMU block that supports Model Exchange mode."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/work-with-fmi-in-simulink.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.png"
        ]
    },
    {
        "title": "Internationalization Issues for Simulink Real-Time",
        "introduction": "Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 inherits the internationalization support of the products that it works with: Simulink, Simulink Coder\u00e2\u0084\u00a2, and Embedded Coder\u00c2\u00ae. Signal and parameter names that include Unicode\u00c2\u00ae characters are displayed as expected in Simulink Real-Time Explorer and at the MATLAB\u00c2\u00ae command line. When you use the Simulation Data Inspector to observe signals, the non-ASCII signal names are displayed as expected. For example, assume that the signal with ID 1 appears in an English-language and a Japanese-language version of the same model. In the English-language version, the signal label is input1 and the block path is block1/block2. In the Japanese-language version, the signal label is \u00e5 \u00a5\u00e5\u008a\u009b1 and the block path is \u00e3\u0083\u0096\u00e3\u0083\u00ad\u00e3\u0083\u0083\u00e3\u0082\u00af1/\u00e3\u0083\u0096\u00e3\u0083\u00ad\u00e3\u0083\u0083\u00e3\u0082\u00af2. Third-party code (for example, parsers for vendor configuration files) sometimes does not support cross-locale, cross-platform internationalization. For such code, you must give files and folders locale-specific names. For example, when parsing a configuration file on an English-locale machine, name the file and enclosing folder with English-locale-specific names.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/internationalization-issues-for-simulink-real-time.html",
        "images": []
    },
    {
        "title": "Control Regeneration of Top Model Code",
        "introduction": "When you rebuild a model, by default, the build process performs checks to determine whether changes to the model or relevant settings require regeneration of the top model code. The model build regenerates top model code if any of the following conditions is true: Whether the top model code is regenerated, the build process calls the build process hooks and reruns the makefile. The hooks include the STF_make_rtw_hook functions and the post code generation command. This process recompiles and links the external dependencies. System target file authors can perform actions related to code regeneration in the STF_make_rtw_hook functions that the build process calls. These actions include forcing or reacting to code regeneration. For more information, see Control Code Regeneration Using STF_make_rtw_hook.m. codebuild",
        "chunks": [
            {
                "heading": "Regeneration of Top Model Code",
                "content": "If the checks determine that top model code generation is required, the build process fully regenerates and compiles the model code. An example check is whether previously generated code is not current due to a model update.\n\nThe build process omits regeneration of the top model code when the checks indicate both:\n\nThe top model generated code is current for the model. Model settings do not require full regeneration.\n\nThis omission can significantly reduce model build times.\n\nWith an Embedded Coder\u00c2\u00ae license, if you modify a code generation template (CGT) file then rebuild your model, the code generation process does not force a top model build. In this case, see Force Regeneration of Top Model Code."
            },
            {
                "heading": "Force Regeneration of Top Model Code",
                "content": "If you want to control or override the default top model build behavior, use one of the following command-line options:\n\nTo ignore the checksum and force regeneration of the top model code:slbuild(model,'ForceTopModelBuild',true)slbuild(model,'StandaloneCoderTarget','ForceTopModelBuild',true)To clean the model build area enough to trigger regeneration of the top model code at the next build (slbuild only):slbuild(model,'CleanTopModel')\n\nYou can also force regeneration of the top model code by deleting the slprj folder in the Code generation folder. If you delete the slprj folder, delete the model.slxc file too."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/control-regeneration-of-top-model-code.html",
        "images": []
    },
    {
        "title": "Troubleshoot Overloaded CPU from Executing Real-Time Application",
        "introduction": "Some issue is producing a CPU overload when executing a real-time application. Compile with GCC -ffast-math",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "A CPU overload indicates that the CPU is unable to complete processing a model time step before restarting for the next time step.\n\nWhen this error occurs, the Simulink Real-Time RTOS halts model execution and the Target object property TargetStatus shows an error, for example:\n\nmCPUOverload: Sub-rate exception: Overload limit (0) exceeded in 0.02s rate with 1 overloads\n\nIf you allow the overload, model execution continues until the allowed overload limit is reached. If the model continues to run after a CPU overload, the time step lasts as long as the time required to finish the execution. This behavior delays the next time step.\n\nModel design or Speedgoat\u00c2\u00ae target computer resources cause CPU overloads. Possible reasons are:\n\nThe target computer is too slow or the model sample time is too small.The model is too complex (algorithmic complexity).I/O latency, where each I/O channel used introduces latency into the system. I/O latency can cause the execution time to exceed the model time step.To find latency values for Speedgoat boards, see www.speedgoat.com and select Products & Services > Services."
            },
            {
                "heading": "Try This Workaround",
                "content": "The Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 RTOS usually halts model execution when it encounters a CPU overload. You can configure the Simulink Real-Time model to allow CPU overloads. Use this capability to support long initializations and for overload diagnosis. You also can try to reduce overloads by improving application performance and enabling the Compile with GCC -ffast-math option."
            },
            {
                "heading": "Permit Long Initialization Time",
                "content": "For some real-time applications, normal initialization can extend beyond the first sample time. Use the SLRT Overload Options block to increase the number of startup time steps to ignore overloads. By default, only the first time step ignores overloads.\n\nNoteAllowing the target computer CPU to overload can cause incorrect results, especially for multirate models. Use the SLRT Overload Options block only for diagnosis. When your diagnosis is complete, turn off these options."
            },
            {
                "heading": "Enable Compile with GCC -ffast-math Option",
                "content": "The Compile with GCC -ffast-math option enables the GCC compiler -ffast-math option when compiling real-time application code. This option is disabled by default for Simulink Real-Time models.\n\nBy enabling the Compile with GCC -ffast-math option, you provide the compiler with more flexibility to optimize floating-point math at the expense of deviating from the IEEE-754 floating-point standard.\n\nFor more information about the -ffast-math option, see the Semantics of Floating-Point Math in GCC and gcc.gnu.org/wiki/FloatingPointMath/."
            },
            {
                "heading": "Force Polling Mode",
                "content": "The Force polling mode option enables polling mode \u00e2\u0080\u0094 instead of interrupt-driven mode \u00e2\u0080\u0094 for clocking the real-time application. Enabling this option can help reduce CPU overloads if:\n\nThe target computer has at least four CPU cores.The CPU overload is caused by sporadic TET spikes."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-overloaded-cpu-from-executing-real-time-application.html",
        "images": []
    },
    {
        "title": "Generate Subsystem Code as Separate Function and Files",
        "introduction": "You can configure an atomic subsystem to generate code to a separate function and file. This results in code that is more modular and enables you to unit test code for individual subsystems. The Function packaging Subsystem block parameter has two settings that cause a subsystem to generate code as a separate function. The Reusable function option generates a function that passes I/O, states, and parameters as function arguments. The Nonreusable function option generates a function that passes I/O, states, and parameters as a combination of function arguments and global data structures.",
        "chunks": [
            {
                "heading": "Subsystem Function Dependence",
                "content": "When generating code for a subsystem, the code can reference global data structures of the model, even if the subsystem function code is in a separate file. Each subsystem code file contains include directives and comments describing the dependencies. The code generator checks for cyclic file dependencies and produces warnings about them at build time. For descriptions of how the code generator packages code, see Manage Build Process File Dependencies.\n\nTo generate subsystem function code that is independent of the code generated for the parent model, place the subsystem in a library and configure it as a reusable subsystem, as described in Generate Reusable Code from Library Subsystems Shared Across Models.\n\nIf you have Embedded Coder\u00c2\u00ae, you can generate code for library consisting of reusable subsystems that have different function interfaces. For more information, see:\n\nLibrary-Based Code Generation for Reusable Library Subsystems (Embedded Coder)Function name optionsFile name optionsFunction packagingFile packaging format (Embedded Coder)"
            },
            {
                "heading": "Generate Subsystem as a Reusable Function",
                "content": "Open Live Script\n\n1. Open a model that has a subsystem, such as SubsystemAtomic.\n\nSubsystemAtomic\n\nIf you are using Embedded Coder, from the C Code tab, click View Code to open the Code View editor.\n\n2. Right-click the Subsystem block. From the context menu, select Block Parameters (Subsystem).\n\n3. In the Subsystem Parameters dialog box, verify that Treat as atomic unit is selected. With that parameter selected, on the Code Generation tab, the Function packaging parameter is available.\n\n4. Click the Code Generation tab and select Reusable function from the Function packaging parameter. This enables two parameters:\n\nThe Function name options parameter controls the naming of the generated function.The File name options parameter controls the naming of the generated file.\n\n5. Set the File name options parameter to Use subsystem name.\n\n6. Click Apply and close the dialog box.\n\n7. If you are using Embedded Coder, open the Configuration Parameters dialog box. Verify that the model configuration parameter File packaging format (Embedded Coder) is set to Modular.\n\n8. Generate the code.\n\n#include \"SS1.h\" /* Include model header file for global data */ #include \"SubsystemAtomic.h\" #include \"SubsystemAtomic_private.h\" /* Outputs for atomic system: '<Root>/SS1' */ real_T myfun(DW_myfun_T *localDW) { /* DiscreteIntegrator: '<S1>/Integrator' */ return localDW->Integrator_DSTATE; } /* Update for atomic system: '<Root>/SS1' */ void myfun_Update(real_T rtu_In1, DW_myfun_T *localDW) { /* Update for DiscreteIntegrator: '<S1>/Integrator' */ localDW->Integrator_DSTATE += rtu_In1; }\n\nThe reusable function myfun passes in inputs and states as arguments to the subsystem function.\n\nFor more information, see Generate Reentrant Code from Subsystems and Generate Reusable Code from Library Subsystems Shared Across Models."
            },
            {
                "heading": "Generate Subsystem as a Nonreusable Function",
                "content": "Open Live Script\n\n1. Open a model that has a subsystem, such as SubsystemAtomic.\n\nSubsystemAtomic\n\nIf you are using Embedded Coder, from the C Code tab, click View Code to open the Code View editor.\n\n2. Right-click the Subsystem block. From the context menu, select Block Parameters (Subsystem).\n\n3. In the Subsystem Parameters dialog box, verify that Treat as atomic unit is selected. With that parameter selected, on the Code Generation tab, the Function packaging parameter is available.\n\n4. Click the Code Generation tab and select Nonreusable function from the Function packaging parameter. This enables two parameters:\n\nThe Function name options parameter controls the naming of the generated function.The File name options parameter controls the naming of the generated file.\n\n5. Set the File name options parameter to Use subsystem name.\n\n6. Click Apply and close the dialog box.\n\n7. If you are using Embedded Coder, open the Configuration Parameters dialog box. Verify that the model configuration parameter File packaging format (Embedded Coder) is set to Modular.\n\n8. Generate the code.\n\n#include \"SS1.h\" /* Include model header file for global data */ #include \"SubsystemAtomic.h\" #include \"SubsystemAtomic_private.h\" /* Outputs for atomic system: '<Root>/SS1' */ void myfun(void) { /* Outport: '<Root>/Out1' incorporates: * DiscreteIntegrator: '<S1>/Integrator' */ SubsystemAtomic_Y.Out1 = SubsystemAtomic_DW.Integrator_DSTATE; } /* Update for atomic system: '<Root>/SS1' */ void myfun_Update(void) { /* Update for DiscreteIntegrator: '<S1>/Integrator' */ SubsystemAtomic_DW.Integrator_DSTATE += SubsystemAtomic_B.Sum; }\n\nThe nonreusable function myfun passes in inputs and states through the global data structures SubsystemAtomic_Y and SubsystemAtomic_DW."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/generate-separate-code-and-files-for-subsystems-in-a-model.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/GenerateSubsystemAsAReusableFunctionExample_01.png",
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/GenerateSubsystemAsANonreusableFunctionExample_01.png"
        ]
    },
    {
        "title": "Filter Hierarchical List of Signals and Parameters in Simulink Real-Time Explorer",
        "introduction": "In Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 Explorer, the default view of the signal and parameter lists shows the signals and parameters only at the hierarchy level that you selected. You can display signals and parameters for the current level and below and filter the display to show only the items that you are interested in.",
        "chunks": [
            {
                "heading": "Hierarchical Display",
                "content": "To show signals and parameters from the current level and below, navigate to the hierarchical level that you are interested in. Click Contents of ( on the toolbar).\n\nThe figure shows the contents of the top level of the slrt_ex_sf_car real-time application. To open this example model, in the MATLAB Command Window, type:\n\nopenExample('slrealtime/SlrtCreateUpdateInstPanelForStateflowCarExample'); open_system('slrt_ex_sf_car');"
            },
            {
                "heading": "Filtered Display",
                "content": "To restrict the display to signals or parameters with a particular characteristic, use the Filter text box. You can restrict the scope of the filtered display by selecting a level of the application in the Application Tree panel.\n\nSimulink Real-Time Explorer supports filtering by values in these columns:\n\nSignals \u00e2\u0080\u0094 Block Path and Signal NameParameters \u00e2\u0080\u0094 Block Path and Name\n\nFor example, to restrict the display of signals and parameters to the shift_logic subsystem, select column Signal Name. Type shift_logic into the Filter text box."
            },
            {
                "heading": "Sorted Display",
                "content": "To group signals and parameters by columns, select the column head, hover the cursor near the right border of the column head (displays the Sort by icon), and click the Sort by icon.\n\nExplorer supports grouping by the following columns:\n\nSignals \u00e2\u0080\u0094 Block Path and Signal NameParameters \u00e2\u0080\u0094 Block Path, Name, Value, Type, and Size\n\nFor example, to sort signals by name, right-click the Signal Name column and select the Sort by icon."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/filter-hierarchical-list-of-signals-and-parameters-in-simulink-real-time-explorer.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/gui-icon-current-system-16.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-slrt-explorer-slrt_ex_sf_car-hierarchy.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-slrt-explorer-slrt_ex_sf_car-hierarchy-filter.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-slrt-explorer-slrt_ex_sf_car-hierarchy-sort.png"
        ]
    },
    {
        "title": "Fixed-Point Data in MATLAB and Simulink",
        "introduction": "",
        "chunks": [
            {
                "heading": "Fixed-Point Data in Simulink",
                "content": "You can use the fixdt function in Simulink\u00c2\u00ae to specify a fixed-point data type. The fixdt function creates a Simulink.NumericType object."
            },
            {
                "heading": "Fixed-Point Data Type and Scaling Notation",
                "content": "Simulink data type names must be valid MATLAB\u00c2\u00ae identifiers with less than 128 characters. The data type name provides information about container type, number encoding, and scaling.\n\nThe following table provides a key for various symbols that appear in Simulink products to indicate the data type and scaling of a fixed-point value.\n\nSymbolDescriptionExampleContainer TypeufixUnsigned fixed-point data typeufix8 is an 8-bit unsigned fixed-point data typesfixSigned fixed-point data typesfix128 is a 128-bit signed fixed-point data typefltuScaled double override of an unsigned fixed-point data type (ufix)fltu32 is a scaled doubles override of ufix32fltsScaled double override of a signed fixed-point data type (sfix)flts64 is a scaled doubles override of sfix64Number Encodinge10^125e8 equals 125*(10^(8))nNegativen31 equals -31pDecimal point1p5 equals 1.5p2 equals 0.2Scaling EncodingSSlopeufix16_S5_B7 is a 16-bit unsigned fixed-point data type with Slope of 5 and Bias of 7BBiasufix16_S5_B7 is a 16-bit unsigned fixed-point data type with Slope of 5 and Bias of 7EFixed exponent (2^)A negative fixed exponent describes the fraction lengthsfix32_En31 is a 32-bit signed fixed-point data type with a fraction length of 31FSlope adjustment factorufix16_F1p5_En50 is a 16-bit unsigned fixed-point data type with a SlopeAdjustmentFactor of 1.5 and a FixedExponent of -50C,c,D, or dCompressed encoding for BiasNoteIf you pass this character vector to the slDataTypeAndScale function, it returns a valid fixdt data type.No example available. For backward compatibility only.To identify and replace calls to slDataTypeAndScale, use the Check for calls to slDataTypeAndScale Model Advisor check.T or tCompressed encoding for SlopeNoteIf you pass this character vector to the slDataTypeAndScale, it returns a valid fixdt data type.No example available. For backward compatibility only.To identify and replace calls to slDataTypeAndScale, use the Check for calls to slDataTypeAndScale Model Advisor check."
            },
            {
                "heading": "Fixed-Point Data in MATLAB",
                "content": "To assign a fixed-point data type to a number or variable in MATLAB, use the fi (Fixed-Point Designer) constructor. The resulting fixed-point value is called a fi object. For example, the following creates fi objects a and b with attributes shown in the display, all of which we can specify when the variables are constructed. Note that when the FractionLength property is not specified, it is set automatically to \"best precision\" for the given word length, keeping the most-significant bits of the value. When the WordLength property is not specified it defaults to 16 bits.\n\na = fi(pi)\n\na = 3.1416015625 DataTypeMode: Fixed-point: binary point scaling Signedness: Signed WordLength: 16 FractionLength: 13\n\nb = fi(0.1)\n\nb = 0.0999984741210938 DataTypeMode: Fixed-point: binary point scaling Signedness: Signed WordLength: 16 FractionLength: 18"
            },
            {
                "heading": "Read Fixed-Point Data from the Workspace",
                "content": "Use the From Workspace block to read fixed-point data from the MATLAB workspace into a Simulink model. To do this, the data must be in structure format with a fi object in the values field. In array format, the From Workspace block only accepts real, double-precision data."
            },
            {
                "heading": "Write Fixed-Point Data to the Workspace",
                "content": "You can write fixed-point output from a model to the MATLAB workspace via the\u00c2 To Workspace\u00c2 block in either array or structure format. Fixed-point data written by a To Workspace block to the workspace in structure format can be read back into a Simulink model in structure format by a From Workspace block."
            },
            {
                "heading": "Scaled Doubles",
                "content": "Scaled doubles are a hybrid between floating-point and fixed-point numbers. Fixed-Point Designer\u00e2\u0084\u00a2 stores them as doubles with the scaling, sign, and word length information retained. For example, the storage container for a fixed-point data type sfix16_En14 is int16. The storage container of the equivalent scaled doubles data type, flts16_En14 is floating-point double. Fixed-Point Designer applies the scaling information to the stored floating-point double to obtain the real-world value. Storing the value in a double almost always eliminates overflow and precision issues."
            },
            {
                "heading": "Functions",
                "content": "\u2022 fi (Fixed-Point Designer) | fimath (Fixed-Point Designer) | fixdt | Simulink.NumericType"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/fixed-point-data-in-matlab-and-simulink.html",
        "images": []
    },
    {
        "title": "How Acceleration Modes Work",
        "introduction": "",
        "chunks": [
            {
                "heading": "Overview",
                "content": "The accelerator and rapid accelerator modes use portions of the Simulink\u00c2\u00ae Coder\u00e2\u0084\u00a2 product to create an executable.\n\nThe accelerator and rapid accelerator modes replace the interpreted code normally used in Simulink simulations, shortening model run time.\n\nAlthough the acceleration modes use some Simulink Coder code generation technology, you do not need the Simulink Coder software installed to accelerate your model.\n\nNoteThe code generated by the accelerator and rapid accelerator modes is suitable only for speeding the simulation of your model. Use Simulink Coder to generate code for other purposes."
            },
            {
                "heading": "Normal Mode",
                "content": "In normal mode, the MATLAB\u00c2\u00ae technical computing environment is the foundation on which the Simulink software is built. Simulink controls the solver and model methods used during simulation. Model methods include such things as computation of model outputs. Normal mode runs in one process."
            },
            {
                "heading": "Accelerator Mode",
                "content": "By default, accelerator mode uses Just-in-Time (JIT) acceleration to generate an execution engine in memory instead of generating C code or MEX files. You can also have your model fall back to the classic accelerator mode, in which Simulink generates and links code into a C-MEX S-function.\n\nIn accelerator mode, the model methods are separate from the Simulink software and are part of the acceleration target code, which is used in later simulations.\n\nSimulink checks that the acceleration target code is up to date before reusing it. For more information, see Code Regeneration in Accelerated Models.\n\nThere are two modes of operation in accelerator mode."
            },
            {
                "heading": "Just-In-Time Accelerator Mode",
                "content": "In this default mode, Simulink generates an execution engine in memory for the top-level model only and not for referenced models. As a result, a C compiler is not required during simulation.\n\nBecause the acceleration target code is in memory, it is available for reuse as long as the model is open. Simulink also serializes the acceleration target code so that the model does not need rebuilding when it is opened."
            },
            {
                "heading": "Classic Accelerator Mode",
                "content": "If you want to simulate your model using the classic, C-code generating, accelerator mode, run the following command:\n\nset_param(0,'GlobalUseClassicAccelMode','on');\n\nIn this mode, Simulink generates and links code into a shared library, which communicates with the Simulink software. The target code executes in the same process as MATLAB and Simulink."
            },
            {
                "heading": "Rapid Accelerator Mode",
                "content": "Rapid accelerator mode creates a rapid accelerator standalone executable from your model. This executable includes the solver and model methods, but it resides outside of MATLAB and Simulink. It uses external mode (see External Mode Communication (Simulink Coder)) to communicate with Simulink.\n\nMATLAB and Simulink run in one process, and if a second processing core is available, the standalone executable runs there."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/how-the-acceleration-modes-work.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/rapid_accel_1a.png",
            "https://in.mathworks.com/help/simulink/ug/rapid_accel_2b.png",
            "https://in.mathworks.com/help/simulink/ug/rapid_accel_2a.png",
            "https://in.mathworks.com/help/simulink/ug/rapid_accel_3a.png"
        ]
    },
    {
        "title": "Troubleshoot Parameters Not Accessible by Name",
        "introduction": "Some parameters cannot be observed or tuned in the real-time application.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "Reasons that you cannot observe or tune some parameters in the real-time application are:\n\nSimulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 does not support parameters of multiword data types.During execution, you cannot tune parameters that change the model structure, for example, by adding a port. To change these parameters, you must stop the execution, change the parameter, and rebuild the real-time application."
            },
            {
                "heading": "Try This Workaround",
                "content": "Check the parameters for the issues described in What This Issue Means."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-parameters-not-accessible-by-name.html#mw_72c31b18-6244-491b-9212-ef3a816c316b",
        "images": []
    },
    {
        "title": "Troubleshoot Vector CANape Operation",
        "introduction": "A third-party calibration tool (Vector CANape\u00c2\u00ae) is not working with the real-time application.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "You can use the Vector CANape tool to view signals and tune parameters in the real-time application. For more information, see the steps in Prepare ASAP2 Data Description File. In addition to the limitations listed in Vector CANape Limitations, there are various issues that can prevent the operation of this tool."
            },
            {
                "heading": "Try This Workaround",
                "content": "For Vector CANape tool issues, try these workarounds."
            },
            {
                "heading": "Simulation Data Inspector in Use",
                "content": "Simulation Data Inspector and the third-party calibration tools (Vector CANape and ETAS\u00c2\u00ae Inca) are mutually exclusive. If you use the Simulation Data Inspector to view signal data, you cannot use the calibration tools. If you use the calibration tools, you cannot use the Simulation Data Inspector to view signal data."
            },
            {
                "heading": "Client Cannot Connect",
                "content": "Check the IP address of the Speedgoat\u00c2\u00ae target computer associated with the model and compare it to the address stored in the ASAP2 file."
            },
            {
                "heading": "ASAP2 File Out of Date",
                "content": "When you rebuild a Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 application, update the ASAP2 file loaded in the calibration tool with the new version of the file. The ASAP2 file is valid only until the next time that you build the application."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/vector-canape-troubleshooting.html",
        "images": []
    },
    {
        "title": "Find Simulink Real-Time Support",
        "introduction": "For support with Speedgoat\u00c2\u00ae target machines or the Speedgoat I/O Blockset, contact Speedgoat support: www.speedgoat.com/knowledge-center For support on general MATLAB\u00c2\u00ae or Simulink\u00c2\u00ae issues, see MathWorks\u00c2\u00ae Help: www.mathworks.com/help For support on Simulink Real-Time\u00e2\u0084\u00a2 issues, see: After searching these resources, if you still cannot solve your issue:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/find-simulink-real-time-support.html",
        "images": []
    },
    {
        "title": "Implicit and Explicit Partitioning of Models",
        "introduction": "When implementing multicore programming for your application in Simulink\u00c2\u00ae, there are two ways to partition your model for running on individual processing nodes. If you are new to multicore programming in Simulink, use the default (implicit partitioning) for your first iteration of implementing multicore programming. The automated way of creating tasks and mapping them to your processing nodes is called implicit partitioning. Simulink partitions your model based on the sample time of blocks at the root level. Each sample time in your model corresponds to a partition, and all blocks of a single rate or sample time belong to the same partition. Simulink maps these partitions to tasks that run on your processor. Implicit partitioning assumes your architecture to be a single multicore CPU. The CPU task scheduler handles all the partitioned tasks. If you want to specify how to partition your model, use explicit partitioning. In explicit partitioning, you create partitions in the root-level model by using referenced models, MATLAB\u00c2\u00ae system blocks, MATLAB Function blocks, Stateflow\u00c2\u00ae charts, and Simulink subsystems. For example, if your model has data acquisition and a controller, partition your model by putting these components in two referenced models at the model root-level. Each sample time of the blocks in the model corresponds to a partition. You can add tasks to run on processing nodes in the Concurrent Execution dialog box and assign your partitions to these tasks. If some partitions are left unassigned, Simulink automatically assigns them to tasks. In explicit partitioning, you can specify your own architecture. The default architecture is a multicore CPU, the same as the assumed architecture in implicit partitioning. Explicit partitioning has more restrictions on your root-level model than implicit partitioning. For more information, see Limitations with Multicore Programming in Simulink.",
        "chunks": [
            {
                "heading": "Partitioning Guidelines",
                "content": "There are multiple ways to partition your model for concurrent execution in Simulink. Rate-based and model-based approaches give you primarily graphical means to represent concurrency for systems that are represented using Simulink and Stateflow blocks. You can partition MATLAB code using the MATLAB System block and the MATLAB Function block. You can also partition models of physical systems using multisolver methods.\n\nEach method has additional considerations to help you decide which to use.\n\nGoalValid Partitioning MethodsConsiderationsIncrease the performance of a simulation on the host computer.No partitioning methodSimulink tries to optimize the host computer performance regardless of the modeling method you use. For more information on the ways that Simulink helps you to improve performance, see Optimize Performance.Increase the performance of a plant simulation in a multicore HIL (hardware-in-the-loop) system.You can use any of the partitioning methods and their combinations.The processing characteristics of the HIL system and the embedded processing system can vary greatly. Consider partitioning your system into more units of work than there are number of processing elements in the HIL or embedded system. This convention allows flexibility in the mapping process.Create a valid model of a multirate concurrent system to take advantage of a multicore processing system.You can use any of the partitioning methods and their combinations.Partitioning can introduce signal delays to represent the data transfer requirements for concurrent execution. For more information, see Configure Data Transfer Settings Between Concurrent Tasks.Create a valid model of a heterogeneous system to take advantage of multicore and FPGA processing. Multicore processing: Use any of the partitioning methods.FPGA processing: Partition your model using Model blocks. Consider partitioning for FPGA processing where your computations have bottlenecks that could be reduced using fine-grained hardware parallelism."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/implicit-and-explicit-partitioning-of-models.html",
        "images": []
    },
    {
        "title": "Approaches for Building Code Generated from Simulink Models",
        "introduction": "Use one of these approaches for building (compiling and linking) code that you generate from Simulink\u00c2\u00ae models: Each build approach supports: For information about customizing a build approach, see Code Compilation Customization. slbuild | codebuild",
        "chunks": [],
        "link": "https://in.mathworks.com/help/ecoder/ug/approaches-for-building-generated-code.html",
        "images": []
    },
    {
        "title": "Partition Your Model Using Explicit Partitioning",
        "introduction": "When you have a model that is configured for concurrent execution, you can add tasks, create partitions, and map individual tasks to partitions using explicit partitioning. This enables you to execute different parts of your model to different parts of your architecture. For more information, see Implicit and Explicit Partitioning of Models.",
        "chunks": [
            {
                "heading": "Prerequisites for Explicit Partitioning",
                "content": "To use explicit partitioning, you must meet the following prerequisites:\n\nSet up your model for concurrent execution. For more information, see Configure Your Model for Concurrent Execution. Convert all blocks at the root level of your model into one of the following types of blocks. Models that are referenced using Model blocksSubsystem blocksMATLAB\u00c2\u00ae System blocksMATLAB Function blocksStateflow\u00c2\u00ae charts For more information, see Implicit and Explicit Partitioning of Models. NoteWhen using referenced models, replicate the model configuration parameters of the top model to the referenced models. Consider using a single configuration reference to use for all of your referenced models. For more information, see Model Configuration Sets. Select the target architecture on which to deploy your model. For more information, see Specify a Target Architecture."
            },
            {
                "heading": "Add Periodic Triggers and Tasks",
                "content": "Add periodic tasks for components in your model that you want to execute periodically. To add aperiodic tasks whose execution is trigger based, see Add Aperiodic Triggers and Tasks.\n\nIf you want to explore the effects of increasing the concurrency on your model execution, you can create additional periodic tasks in your model.\n\nIn the Concurrent Execution dialog box, right-click the Periodic node and select Add task.A task node appears in the Configuration Execution hierarchy.Select the task node and enter a name and period for the task, then click Apply.The task node is renamed to the name you enter.Optionally, specify a color for the task. The color illustrates the block-to-task mapping. If you do not assign a color, Simulink\u00c2\u00ae chooses a default color. If you enable sample time colors for your model, the software honors the setting.Click Apply as necessary.\n\nTo create more periodic triggers, click the Add periodic trigger symbol. You can also create multiple periodic triggers with their own trigger sources.\n\nNotePeriodic triggers let you represent multiple periodic interrupt sources such as multiple timers. The periodicity of the trigger is either the base rate of the tasks that the trigger schedules, or the period of the trigger. Data transfers between triggers can only be Ensure Data Integrity Only types. With blocks mapped to periodic triggers, you can only generate code for ert.tlc and grt.tlc system target files.\n\nTo delete tasks and triggers, right-click them in the pane and select Delete.\n\nWhen the periodic tasks and trigger configurations are complete, configure the aperiodic (interrupt) tasks as necessary. If you do not need aperiodic tasks, continue to Map Blocks to Tasks, Triggers, and Nodes."
            },
            {
                "heading": "Add Aperiodic Triggers and Tasks",
                "content": "Add aperiodic tasks for components in your model whose execution is interrupt-based. To add periodic tasks whose execution is periodic, see Add Periodic Triggers and Tasks.\n\nTo create an aperiodic trigger, in the Concurrent Execution dialog box, right-click the Concurrent Execution node and click the Add aperiodic trigger symbol.A node named InterruptN appears in the configuration tree hierarchy, where N is an integer.Select Interrupt.This node represents an aperiodic trigger for your system. Specify the name of the trigger and configure the aperiodic trigger source. Depending on your deployment target, choose either Posix Signal (Linux/VxWorks 6.x) or Event (Windows). For POSIX\u00c2\u00ae signals, specify the signal number to use for delivering the aperiodic event. For Windows\u00c2\u00ae events, specify the name of the event. Click Apply.\n\nThe software services aperiodic triggers as soon as possible. If you want to process the trigger response using a task:\n\nRight-click the Interrupt node and select Add task.A new task node appears under the Interrupt node. Specify the name of the new task node.Optionally, specify a color for the task. The color illustrates the block-to-task mapping. If you do not assign a color, Simulink chooses a default color.Click Apply.\n\nTo delete tasks and triggers, right-click them in the pane and select Delete.\n\nOnce you have created your tasks and triggers, map your execution components to these tasks. For more information, see Map Blocks to Tasks, Triggers, and Nodes.\n\nTipTo set up your model for aperiodic tasks, connect the function call ports of the Model blocks to Asynchronous Task Specification (Simulink Coder) blocks. Then map the Asynchronous Task Specification (Simulink Coder) blocks to aperiodic triggers. For more information regarding mapping interrupts, see Map Blocks to Tasks, Triggers, and Nodes."
            },
            {
                "heading": "Map Blocks to Tasks, Triggers, and Nodes",
                "content": "After you create the tasks and triggers, you can explicitly assign partitions to these execution elements.\n\nIn the Concurrent Execution dialog box, click the Tasks and Mapping node.The Tasks and Mapping pane appears. If you add a Model block to your model, the new block appears in the table with a select task entry under it.If you want to add a task to a block, in the Name column, right-click a task under the block and select Add new entry.To assign a task for the entry, click the box in the Name column and select an entry from the list. For example, periodic tasks and an aperiodic trigger are mapped to specific blocks.The block-to-task mapping symbol appears on the top-left corner of the Model block for periodic tasks or triggers and the top-left corner of the Inport block for aperiodic tasks or triggers.If you assign a Model block to multiple tasks, multiple task symbols are displayed in the top-left corner.To display the Concurrent Execution dialog box from the block, click the block-to-task mapping symbol.Click Apply.\n\nNoteSystem tasks allow you to perform mapping incrementally. If only one periodic trigger is present, Simulink assigns any Model blocks, subsystem blocks, or MATLAB System blocks that you have not explicitly mapped to a task, trigger, or hardware node to a task created by the system. Simulink creates at most one system task for each rate in the model. If multiple periodic triggers are created, explicitly map the Model block partitions, subsystems, or MATLAB System blocks to a task, trigger, or hardware node.Map Model block partitions that contain continuous blocks to the same periodic trigger.You can map only Model blocks to hardware nodes. Also, if you map the Model block to a hardware node and the Model block contains multiple periodic sample times, clear the Allow tasks to execute concurrently on target check box in the Solver pane of the Configuration Parameters dialog box.\n\nWhen the mapping is complete, simulate the model again."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/setup-partitions-in-explicit-partitioning.html#bs38d7j-1",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/mds-aperiodic-trigger.png",
            "https://in.mathworks.com/help/simulink/ug/mds-tasks-and-mapping.png",
            "https://in.mathworks.com/help/simulink/ug/mds_block_to_task_mapping_icon.png"
        ]
    },
    {
        "title": "Deploy Generated Component Software to Application Target Platforms",
        "introduction": "The code generator supports integration of generated code with operating systems and processors. For details, see Embedded Coder Supported Hardware.",
        "chunks": [
            {
                "heading": "Interface to an Example Real-Time Multitasking System",
                "content": "Open Live Script\n\nThis example shows how to simulate and generate code for asynchronous events on a real-time multitasking system.\n\nThe operating system integration techniques that the example demonstrates use one or more blocks in the vxlib1 library. These blocks provide starting point examples to help you develop custom blocks for your target environment.\n\nExample ModelOpen the OSIntegration model.model = 'OSIntegration'; open_system(model);Model DescriptionThe example model contains two asynchronously executed subsystems, Count and Algorithm. Count executes at interrupt level. Algorithm executes in an asynchronous task. The generated code for these blocks is tailored for the VxWorks\u00c2\u00ae operating system. However, you can modify the Async Interrupt and Task Sync blocks to generate code for your run-time environment whether you are using an operating system or not.Data Transfer AssumptionsThis example assumes the following about the target platform environment:Data transitions occur between a single task that reads data and a single task that writes data.A read or write of a byte-sized variable is atomic.When two tasks interact during a data transfer, only one of the tasks can preempt the other task.For periodic tasks, the task that executes at the faster rate has a higher priority than the tasks that executes at the slower rate. The task executing at the faster rate preempts the tasks executing at the slower rate.Tasks run on a single processor. Time slicing is not allowed.Processes do not crash and restart during a data transfers.Related InformationAsync InterruptTask SyncGenerate Interrupt Service RoutinesTimers in Asynchronous TasksCreate a Customized Asynchronous LibraryImport Asynchronous Event Data for SimulationLoad Data to Root-Level Input PortsAsynchronous EventsRate Transitions and Asynchronous BlocksAsynchronous Support Limitations"
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/operating-system-integration.html",
        "images": []
    },
    {
        "title": "Target Computer Settings",
        "introduction": "To run a Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 model on a Speedgoat\u00c2\u00ae target computer, configure the target settings to match the capabilities of the target computer. Repeat this procedure as required for each target computer. Simulink Real-Time Explorer",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/target-computer-settings.html",
        "images": []
    },
    {
        "title": "Install Development Computer Software",
        "introduction": "You install the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 software only on the MATLAB\u00c2\u00ae development computer. The development computer downloads the real-time application to the target computer at run time. The Simulink Real-Time software is distributed on a DVD or as a file that you download from the Internet. Simulink Real-Time supports development workflows and test engineering workflows: For information about installing target computer software, see Speedgoat Target Computers and Speedgoat Support. slbuild",
        "chunks": [
            {
                "heading": "License Requirements",
                "content": "Before you install the Simulink Real-Time product, you must have a valid File Installation Key and License file. The File Installation Key identifies the products that you purchased from MathWorks\u00c2\u00ae. The License file activates the installation.\n\nIf you have not received either of these items, go to the License Center at the MathWorks website. For a list of required products, go to Product Requirements & Platform Availability for Simulink Real-Time.\n\nAfter you install Simulink Real-Time, if you are setting up a development installation, you must install the Simulink Real-Time Target Support package. During support package installation, you accept the license terms for the BlackBerry\u00c2\u00ae QNX\u00c2\u00ae Neutrino\u00c2\u00ae development tools and run-time components as part of the target computer. These tools generate a real-time application that runs on the target computer.\n\nUsing Simulink Real-Time and BlackBerry QNX Neutrino, you can develop Simulink Real-Time applications that you run on a Speedgoat\u00c2\u00ae target machine (target computer). You can run these real-time applications by using the target computer in connected mode. In connected mode, the development and target computers are connected via Simulink Real-Time software and an Ethernet cable. You also can run these real-time applications by using the target computer in standalone mode. In standalone mode, the development and target computers are not connected via Simulink Real-Time software.\n\nFor more information about the connected mode and the standalone mode, see Real-Time Application and Target Computer Modes."
            },
            {
                "heading": "Location of Files on Development Computer",
                "content": "Select a working folder outside the MATLAB root. Simulink Real-Time generates files and folders in this location:\n\nMATLAB working folder \u00e2\u0080\u0094 Simulink cache files (.slxc), dynamic link libraries (for example, .mex64 ), and Simulink Real-Time applications (.mldatx).Simulink Coder Build folder \u00e2\u0080\u0094 The Simulink Coder C code files (.c, .cpp, .h, .hpp) are in a subfolder called modelname_slrealtime_rtw."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/gs/install-development-computer-software.html",
        "images": []
    },
    {
        "title": "Define Interfaces of Model Components",
        "introduction": "Defining the interface of a model component, such as a Simulink\u00c2\u00ae subsystem, subsystem reference, or model reference, is a key first step before others can use it. Changing a component interface is much easier if the components are stored under configuration management. You can track configurations of compatible component versions to prevent incompatible combinations of components.",
        "chunks": [
            {
                "heading": "Identify Component Boundaries",
                "content": "Base the boundaries of the components upon the boundaries of the corresponding real systems. This guideline is especially useful when the model contains:\n\nBoth physical (plant and environment) and control systemsAlgorithms that run at different ratesA system that you want to reuse multiple times\n\nIf you intend to add sensors or other components as you elaborate your model, create components to represent them. You can configure these components to pass signals straight through or perform a unit delay or name conversion."
            },
            {
                "heading": "Author Component Interfaces",
                "content": "To view and author component interfaces and trace the usage of the elements of the interfaces, use the Component Interface View. In the Simulink Toolstrip, on the Modeling tab, in the Design gallery, select Interface View.\n\nFor more information, see Trace Connections and Author Ports Using Component Interface View."
            },
            {
                "heading": "Simplify Component Interfaces with Buses",
                "content": "To simplify interfaces, group signals and messages into buses. Buses simplify subsystem and model interfaces by letting you associate multiple signals or messages with one port. They reduce line complexity and clutter in a block diagram and make it easier to change the interface incrementally. For example, if you must add or remove elements from a component interface, modifying a bus can be simpler than adding or removing ports. To logically group or define the properties of a portion of the interface, use multiple bus ports.\n\nBuses are well suited for components that have many input and output signals and use a subset of the available signals. Buses pass only the required data to each component from the inputs and outputs. If you define the bus at the interface with a Simulink.Bus object, the interface requires data for the entire bus.\n\nTo access an element from an input bus, use an In Bus Element block. To create an output bus, use Out Bus Element blocks. For more information, see Simplify Subsystem and Model Interfaces with Bus Element Ports.\n\nHow you implement buses at an interface depends on your requirements.\n\nRequirementBus ImplementationProvide name-based matching among elements at the interface and simplify line routingUse buses. Virtual buses meet most modeling requirements. For more information, see Composite Interface Guidelines.Enable robust component integration with defined interfacesUse In Bus Element blocks and Out Bus Element blocks to define the properties of the buses at the interface. Use a rigorous naming convention for the buses and bus elements.Optionally, use Simulink.Bus objects. To place the bus objects under revision control, save them in a data dictionary, function, script, or MAT file.Replicate structure type in generated codeUse nonvirtual buses to describe a structured data type for an element in the interface.Package signals or parameters into structures that correspond to a struct type definition that your external C code definesImport the type as a bus object and use the object as a data type for buses and MATLAB\u00c2\u00ae structures. To create the object, use the Simulink.importExternalCTypes function."
            },
            {
                "heading": "Partition Interface Data for Components",
                "content": "Explicitly control the scope of data for your components with global and nonglobal parameters.\n\nGlobal parameters \u00e2\u0080\u0094 A common approach in the automotive world is to completely separate parameter storage from model storage. The parameters for a model come from a database of calibration data, and the specific calibration file used becomes part of the configuration. The calibration data is treated as global data, and resides in the base MATLAB workspace. You can migrate base workspace data to a data dictionary for more control.Nonglobal parameters \u00e2\u0080\u0094 Combining components that store their own parameter data has the risk of parameter name collisions. If you do not use a naming convention for parameters or a list of unique parameter names and definitions, then two components may use a parameter with the same name but with different meanings.\n\nTo store local parameter data:\n\nPartition data into reference dictionaries for each component.For referenced models, you can use model workspaces.Use parameter files (.m or .mat) and callbacks of the individual Simulink models (for example, the preload function).You can also automatically load required data using project shortcuts.Use mask workspaces with or without the use of mask initialization functions.For subsystems, you can control the scope of data for a subsystem using the Permit hierarchical resolution parameter of the Subsystem block."
            },
            {
                "heading": "Configure Data Interfaces",
                "content": "Explicitly configure design attributes of the interface, such as data type and numeric complexity, to prevent modeling errors and make component integration easier. You can configure the interface of a component before you develop the internal algorithm, in which case the component contains unconnected blocks.\n\nAfter you create the blocks that correspond to the component interface:\n\nTo configure the design attributes of the blocks, use the Model Data Editor.To specify a reusable set of design attributes at component interfaces instead of individually specifying each attribute, use the Type Editor.\n\nTo open the Model Data Editor, in the Simulink Toolstrip, on the Modeling tab, in the Design gallery, click Model Data Editor.\n\nOn the Inports/Outports tab of the Model Data Editor, each row corresponds to an input or output block and the columns correspond to attributes that you can set for the blocks.By default, the Change view list of the Model Data Editor is set to Design, which configures the columns to correspond to design attributes. Use the columns to explicitly configure the design attributes of the interface. For example, specify minimum and maximum values for each block with the Min and Max columns.To display the input and output blocks of the subsystems, select the Change Scope button . Alternatively, view only the input and output blocks at the root level of the model by excluding the blocks inside the subsystems.\n\nTo open the Type Editor, in the Simulink Toolstrip, on the Modeling tab, in the Design gallery, click Type Editor.\n\nTo assign or validate the properties of a signal based on application-specific value types such as wind velocity, tire pressure, or water temperature, use a Simulink.ValueType object.To assign or validate the properties of each element of a bus, use a Simulink.Bus object."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/interface-design.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/mde_change_scope.png"
        ]
    },
    {
        "title": "Concurrent Execution on Simulink Real-Time - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Open, Build, and Download the Model",
                "content": "The explicit partitioning in the top-level model occurs in subsystem1.\n\nopen_system('slrt_ex_mds_subsystem1');\n\nThe explicit partitioning in the top-level model occurs in subsystem2.\n\nopen_system('slrt_ex_mds_subsystem2');\n\nOpen the model slrt_ex_mds_and_tasks. The model is mapped to seven threads: Model1_R1, Model1_R2, Model1_R3, Model1_R4, Model2_R1, Model2_R3, and Model2_R4.\n\nThese threads run at sample rates of Ts, 2*Ts, 3*Ts, 4*Ts, Ts, 3*Ts, and 4*Ts.\n\nmodel = 'slrt_ex_mds_and_tasks'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off'); set_param('slrt_ex_mds_subsystem1',\"SystemTargetFile\",modelSTF); set_param('slrt_ex_mds_subsystem2',\"SystemTargetFile\",modelSTF);\n\nTo apply explicit partitioning, in the Simulink Editor, on the Real-Time tab, click Hardware Settings, and then select Solver > Configure Tasks. Select the Tasks and Mapping node.\n\nBuild, download, and run the model.\n\nevalc('slbuild(model)'); load(tg,model);\n\nOpen TET Monitor\n\nslrtTETMonitor;\n\nStart profiler on the target computer\n\nstartProfiler(tg); start(tg); pause(2); stop(tg);"
            },
            {
                "heading": "Display Profiling Data",
                "content": "The profiling data shows the execution time of each thread on a multi-core target computer.\n\nprofData = tg.getProfilerData; profData.plot;\n\nProcessing data on target computer ... Transferring data from target computer ... Processing data on host computer ..."
            },
            {
                "heading": "View TET Information in TET monitor",
                "content": ""
            },
            {
                "heading": "View TET Information in the Simulation Data Inspector",
                "content": ""
            },
            {
                "heading": "See Also",
                "content": "For more information, see:\n\nGenerate Subsystem Code as Separate Function and Files Generate Code and Executables for Individual Subsystems Generate Inlined Subsystem Code Generate Subsystem Code as Separate Function and Files Generate Reusable Code from Library Subsystems Shared Across Models"
            },
            {
                "heading": "Close the Model",
                "content": "bdclose('slrt_ex_mds_subsystem1'); bdclose('slrt_ex_mds_subsystem2'); bdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/concurrent-execution-on-simulink-real-time.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtConcurrentExecutionExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtConcurrentExecutionExample_02.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtConcurrentExecutionExample_03.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxconcurrent_execution_partitioning.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-slrtexplorer-tet-monitor.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-sdi-task-execution-plot.png"
        ]
    },
    {
        "title": "Define Model Reference Interfaces",
        "introduction": "The ports on a Model block correspond to blocks at the top level, or root level, of the referenced model. The ports can be input, output, or control ports. For example, in the sldemo_mdlref_basic model, each Model block references the sldemo_mdlref_counter model and has: The sldemo_mdlref_counter referenced model has: When you connect a signal to a Model block port, you connect the signal to the corresponding port of the referenced model. The output of a Model block can differ despite the referenced model being the same. For example, in sldemo_mdlref_basic, each Model block input port receives a signal from a unique Pulse Generator block. Because the input signal from each Pulse Generator block uses a different sample time, the output signal from each Model block differs despite the referenced model being the same. To view how the output signal for each Model block differs, you can use the Simulation Data Inspector. Model | Inport | Outport | In Bus Element | Out Bus Element",
        "chunks": [
            {
                "heading": "Add Ports to Model Reference Interface",
                "content": "A model reference interface supports multiple types of ports and port blocks.\n\nThis table describes the type of ports and corresponding port blocks that a model reference interface supports.\n\nType of PortCorresponding Port BlockSignal port, inputInport blockSignal port, outputOutport blockBus element port, inputIn Bus Element blockBus element port, outputOut Bus Element blockControl port, enabledEnable blockControl port, triggeredTrigger blockControl port, function-callTrigger block with Trigger type set to function-callFunction port, clientFunction Element Call blockFunction port, serverFunction Element block\n\nTo add ports to a model reference interface, perform either of these actions:\n\nIn the top level of the referenced model, add blocks that correspond with ports.In the parent model, add ports to a Model block that references the model.\n\nNoteIf the maximum port number in the model exceeds the number of ports in the model, you cannot add ports to the model reference interface. For example, if there are five port blocks in the model, and you change the port number parameter of one of them to 10, you cannot add ports to the model reference interface.\n\nTo open a referenced model, open the model file or double-click the Model block. Then, add the port blocks to the referenced model.\n\nTo add ports to a Model block, pause on any of the four edges of the block. When your pointer turns into a cross, click. A new port, highlighted in blue, appears on the edge you click.\n\nPause your pointer on the new port. In the action menu that expands, select the type of port you want to create. For example, you can create signal and bus element ports.\n\nYou can also add ports to a Model block by dragging a signal line from the model element you want to connect to an edge of the Model block.\n\nDragging from a port block creates a new port of the same type. Dragging from a Subsystem or Model block port that represents a port block also creates a new port of the same type as the port block.\n\nThe input signals for the Model block must be valid for the corresponding input blocks of the referenced model. The output signals for the Model block are the signals that connect to the corresponding output blocks.\n\nTo delete an existing port, select the port and press Delete. To delete multiple ports, press Shift, select the ports, and then press Delete.\n\nFor more information about referenced models with control ports, see Conditionally Execute Referenced Models.\n\nTipYou can use the same approach to add ports to and delete ports from Reference Component (System Composer) blocks and Component (AUTOSAR Blockset) blocks that are linked to models."
            },
            {
                "heading": "Refresh Model Blocks",
                "content": "Refreshing a Model block updates it to reflect changes to the interface of the referenced model. For example, when the referenced model gains or loses a port, refreshing the Model block updates its ports.\n\nBy default, when a referenced model is loaded, the Model blocks that reference it automatically refresh. When a referenced model is not loaded, the corresponding Model blocks refresh when you perform actions such as:\n\nOpening the parent modelSelecting a Model blockSimulating the model hierarchyGenerating code for the model hierarchy\n\nTo be notified when Simulink\u00c2\u00ae detects Model blocks that might not match their referenced models, change the default setting for these diagnostic configuration parameters:\n\nModel block version mismatchPort and parameter mismatch\n\nWhen these configuration parameters are set to error for a model, the Model blocks in that model do not automatically refresh. To refresh a Model block when these configuration parameters are set to error, perform either of these actions:\n\nSelect the Model block. On the Model Block tab, click Refresh .Use the Simulink.ModelReference.refresh function.\n\nWhen these configuration parameters are set to warning or none for a model, you can manually refresh all Model blocks in the model hierarchy. To do so, perform either of these actions:\n\nOn the Model Block tab, click the Update Model button arrow. Then, select Refresh Blocks.Use the Simulink.BlockDiagram.refreshBlocks function."
            },
            {
                "heading": "Define Signal Attributes",
                "content": "Signal attributes in a referenced model are independent from the context of the Model block. For example, signal dimensions and data types do not propagate across the Model block boundary.\n\nTo define the attributes of input to a referenced model, use the parameters of the root-level Inport and In Bus Element blocks. An In Bus Element block can fully specify the hierarchy and attributes of an input bus without a Simulink.Bus object.\n\nIn Bus Element and Out Bus Element blocks support multirate virtual buses and do not require Simulink.Bus objects at model interfaces, unlike Inport and Outport blocks.\n\nFor signals that connect to Outport blocks to propagate out of a referenced model to the parent model, the signal names must explicitly appear on the signal lines.\n\nA referenced model can only provide input or get output for user-defined data types that are fixed point or that Simulink.DataType or Simulink.Bus objects define."
            },
            {
                "heading": "Use Buses at Model Interfaces",
                "content": "Bus input for a Model block must be consistent with the bus expected by the referenced model.\n\nIf you use a bus as an input to or an output from a referenced model:\n\nOnly a nonvirtual bus can contain variable-size signal elements.For code generation, you can configure the I/O arguments step method style of the C++ class interface for the referenced model only when using a nonvirtual bus or when using the Default style of the C++ class interface.For code generation, you can configure function prototype control for the referenced model only when using a nonvirtual bus.\n\nFor cleaner bus interfaces, use:\n\nIn Bus Element blocks instead of Inport blocks connected to Bus Selector blocksOut Bus Element blocks instead of Bus Creator blocks connected to Outport blocks\n\nFor more information, see Simplify Subsystem and Model Interfaces with Bus Element Ports.\n\nFor an example of a model hierarchy that uses buses with Inport blocks, see Interface Specification Using Bus Objects."
            },
            {
                "heading": "Log Signals in Referenced Models",
                "content": "In a referenced model, you can log any signal configured for signal logging. Use the Signal Logging Selector to select a subset or all the signals configured for signal logging in a model hierarchy. For details, see Override Signal Logging Settings.\n\nYou can use the Simulation Data Inspector to view and analyze signals logged in referenced models. You can view signals on multiple plots, zoom, and use data cursors to understand and evaluate the data. Also, you can compare signal data from multiple simulations. For an example of viewing signals with referenced models, see Viewing Signals in Model Reference Instances."
            },
            {
                "heading": "Configure Sample Times",
                "content": "The first nonvirtual block that connects to a root-level input or output block of a referenced model must have the same sample time as the related port. If the sample times are different, use Rate Transition blocks to match input and output sample times, as shown in this block diagram."
            },
            {
                "heading": "Share Data Among Referenced Model Instances",
                "content": "By default, each Model block instance reads from and writes to a separate copy of the signals and block states in the model. Therefore, the instances do not interact with each other through shared signal or state data.\n\nTo share a piece of data between all of the instances (for example, an accumulator or a fault indicator), model the data as a data store.\n\nTo restrict access to data so that only the blocks in the referenced model can read from and write to it, use a Data Store Memory block in the model and select the Share across model instances parameter. For an example, see Share Data Among Multiple Instances of a Reusable Algorithm.To allow access to data outside the referenced model, use a global data store, which is a Simulink.Signal object in the base workspace or a data dictionary. Data outside the referenced model can be in the parent model or in other referenced models.\n\nFor more information about data stores, see Model Global Data by Creating Data Stores."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/define-referenced-model-inputs-and-outputs-1.html#btmmqdp",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/model_reference_parent.png",
            "https://in.mathworks.com/help/simulink/ug/submodel.png",
            "https://in.mathworks.com/help/simulink/ug/mdlref_sdi.png",
            "https://in.mathworks.com/help/simulink/ug/add-port-to-model-block-by-clicking-edge.gif",
            "https://in.mathworks.com/help/simulink/ug/add-port-to-model-block-by-dragging-signal-line.gif",
            "https://in.mathworks.com/help/simulink/ug/refresh-model-block-icon.png",
            "https://in.mathworks.com/help/simulink/ug/mod_ref_match_i_o_rate.png"
        ]
    },
    {
        "title": "Model Fault-Tolerant Fuel Control System - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Analysis and Physics",
                "content": "Physical and empirical relationships form the basis for the throttle and intake manifold dynamics of this model. The model computes air-fuel ratio by dividing the air mass flow rate pumped from the intake manifold by the fuel mass flow rate injected at the valves. The stoichiometric mixture ratio provides a good compromise between power, fuel economy, and emissions. The target air-fuel ratio for this system is 14.6. Typically, a sensor determines the amount of residual oxygen present in the exhaust gas (EGO). This measurement gives a good indication of the mixture ratio and provides a feedback measurement for closed-loop control. If the sensor indicates a high oxygen level, the control law increases the fuel rate. When the sensor detects a fuel-rich mixture, the controller decreases the fuel rate."
            },
            {
                "heading": "Modeling",
                "content": "Open the model. To run the simulation, in the Simulink Toolstrip, on the Simulation tab, click Run.\n\nThe model uses a callback function to load the data required for the simulation into the model workspace from the sldemo_fuelsys_data file. Loading initial conditions into the model workspace keeps simulation data isolated from data in any other open models and helps avoid cluttering MATLAB\u00c2\u00ae workspace cluttering. To view the contents of the model workspace, in the Simulink Editor, on the Modeling tab, in the Design section, expand the gallery and click Model Explorer. In the Model Explorer window, in the Model Hierarchy list on the left, expand sldemo_fuelsys and select Model Workspace. For more information about how to use callbacks to load simulation data, see Automatically Initialize Variables and Load Data.\n\nThe model logs relevant data to MATLAB workspace in a data structure called sldemo_fuelsys_output and streams the data to the Simulation Data Inspector. Logged signals are marked with a blue badge. To learn more about data logging, see Save Signal Data Using Signal Logging.\n\nNote that units are visible on the model and subsystem icons and signal lines. Units are specified on the ports and on the bus object.\n\nThe Dashboard subsystem allows you to interact with the model during simulation. Fault Injection switches from the Normal to Fail position to simulate sensor failures. Toggle the Engine Speed selector switch to change the engine speed. You can visualize the fuel and air-fuel ratio signals using gauges and scopes. The blocks in the Dashboard subsystem are from the Dashboard library. To learn about dashboard blocks, see Control Simulations with Interactive Displays.\n\nThe fuel_rate_control subsystem uses signals from the system sensors to determine the fuel rate which gives a stoichiometric mixture. The fuel rate combines with the actual air flow in the engine gas dynamics model to determine the resulting mixture ratio as sensed at the exhaust.\n\nYou can simulate the failure of any of the throttle angle, speed, EGO, or manifold absolute pressure (MAP) sensors by switching off the corresponding slider switch in the dashboard subsystem. To access the switches, double-click the subsystem block named Dashboard. To flip a switch, click where you want the handle of the switch to move. If you stop the simulation, select the Slider Switch block, and then click where you want the handle to move. Each slider switch connects to the value parameter of a Constant block. When you switch off the slider switch, you change the value of the Constant block.\n\nSimilarly, you can induce the failure condition of a high engine speed by toggling the engine speed switch on the dashboard subsystem. A Repeating Table block provides the throttle angle input and periodically repeats the sequence of data specified in the mask.\n\nThe fuel_rate_control subsystem uses the sensor input and feedback signals to adjust the fuel rate to give a stoichiometric ratio. The model uses three subsystems to implement this strategy: one for control logic, one for airflow calculation, and one for fuel calculation. Under normal operation, the model estimates the airflow rate and multiplies the estimate by the reciprocal of the desired ratio to give the fuel rate. Feedback from the oxygen sensor provides a closed-loop adjustment of the rate estimation to maintain the ideal mixture ratio."
            },
            {
                "heading": "Control Logic",
                "content": "A single Stateflow chart, consisting of a set of six parallel states, implements the control logic in its entirety. The four parallel states shown at the top of the chart correspond to the four individual sensors. The remaining two parallel states consider the status of the four sensors simultaneously and determine the overall system operating mode. The model synchronously calls the entire Stateflow diagram at a regular sample time interval of 0.01 sec. This interval allows timely testing of the conditions for transitions to the correct mode.\n\nIf you enable animation in the Stateflow debugger, the state transitions are highlighted in the Stateflow diagram as the various states are activated. The sequence of activation is indicated by changing colors. This closely coupled synergy between Stateflow and Simulink fosters the modeling and development of complete control systems.\n\nTo open the control_logic Stateflow chart, double-click the chart in the fuel_rate_control subsystem.\n\nWhen execution begins, all states start in normal mode with the exception of the oxygen sensor (EGO). The initial O2_warmup state persists until the warmup period is complete. The system detects throttle and pressure sensor failures when their measured values fall outside their nominal ranges. A manifold vacuum in the absence of a speed signal indicates a speed sensor failure. The oxygen sensor also has a nominal range for failure conditions. However, because zero is both the minimum signal level and the bottom of the range, the system can detect failure only when the sensor exceeds the upper limit.\n\nRegardless of which sensor fails, the model always generates the directed event broadcast Fail.INC. In this way, the triggering of the universal sensor failure logic is independent of the sensor. The model also uses a corresponding sensor recovery event, Fail.DEC. The Fail state keeps track of the number of failed sensors. The counter increments on each Fail.INC event and decrements on each Fail.DEC event. The model uses a superstate, Multi, to group all cases where more than one sensor has failed.\n\nThe bottom parallel state represents the fueling mode of the engine. If a single sensor fails, operation continues, but the air-fuel mixture is richer to allow smoother running at the cost of higher emissions. If more than one sensor fails, the air-fuel ratio cannot be controlled reliably, so the engine shuts down as a safety measure.\n\nDuring the oxygen sensor warm-up, the model maintains the mixture at normal levels. You can change the design by moving the warm-up state to within the Rich_Mixture superstate. If a sensor failure occurs during the warm-up period, the Single_Failure state is entered after the warm-up time elapses. Otherwise, the Normal state is activated at this time.\n\nA protective overspeed feature is added to the model by creating a new state in the Fuel_Disabled superstate. Through the use of history junctions, the model ensures that the chart returns to the appropriate state when the model exits the overspeed state. With this approach, you can add additional shutdown states to the Fuel_Disabled superstate if you want to specify additional safety requirements."
            },
            {
                "heading": "Sensor Correction",
                "content": "When a sensor fails, the model computes an estimate of the sensor. For example,open the pressure sensor calculation. Under normal sensor operation, the model uses the value of the pressure sensor. Otherwise, the model estimates the value.\n\nThe model computes an estimate of manifold pressure as a function of the engine speed and throttle position. To compute the value, the model uses a Simulink function in Stateflow."
            },
            {
                "heading": "Airflow Calculation",
                "content": "The airflow_calc subsystem is the location for the central control laws. This block is inside the fuel_rate_control subsystem. The subsystem estimates the intake air flow to determine the fuel rate that gives the appropriate air-fuel ratio. Closed-loop control adjusts the estimation according to the residual oxygen feedback in order to maintain the mixture ratio precisely. Even when a sensor failure mandates open-loop operation, the most recent closed-loop adjustment is retained to best meet the control objectives.\n\nEquation 1\n\nYou can formulate the engine intake air flow as the product of the engine speed, the manifold pressure, and a time-varying scale factor.\n\nCpump is computed by a lookup table and multiplied by the speed and pressure to form the initial flow estimate. During transients, the throttle rate, with the derivative approximated by a high-pass filter, corrects the air flow for filling dynamics. The control algorithm provides additional correction according to Equation 2.\n\nEquation 2\n\nThe nonlinear oxygen sensor is modeled using the MATLAB Function block named EGO Sensor. To view the block, from the top level of the model, enter the Engine Gas Dynamics subsystem. Then, enter the Mixing & Combustion subsystem.\n\nThe EGO sensor is modeled as a hyperbolic tangent function and provides a meaningful signal when in the vicinity of 0.5 volt. The raw error in the feedback loop is thus detected with a switching threshold, as indicated in Equation 2. If the air-fuel ratio is low (the mixture is lean), the original air estimate is too small and needs to be increased. Conversely, when the oxygen sensor output is high, the air estimate is too large and needs to be decreased. Integral control is utilized so that the correction term achieves a level that brings about zero steady-state error in the mixture ratio.\n\nThe normal closed-loop operation mode, low, adjusts the integrator dynamically to minimize the error. The integration is performed in discrete time, with updates every 10 milliseconds. When operating in an open loop however, in the rich or O2 failure modes, the feedback error is ignored and the integrator is held. These actions gives the best correction based on the most recent valid feedback."
            },
            {
                "heading": "Fuel Calculation",
                "content": "The fuel_rate_control subsystem contains a subsystem named fuel_calc. The fuel_calc subsystem sets the injector signal to match the given airflow calculation and fault status. The first input to the subsystem is the computed airflow estimation. This value is multiplied with the target fuel-air ratio to get the commanded fuel rate. Normally, the target is stoichiometric, which is to say that the target equals the optimal air to fuel ratio of 14.6. When a sensor fault occurs, the Stateflow control logic sets the mode input to a value of 2 or 3 (rich or disabled) so that the mixture is either slightly rich of stoichiometric or is shut down completely.\n\nThe fuel_calc subsystem employs adjustable compensation to achieve different purposes in different modes. In normal operation, phase lead compensation of the feedback correction signal adds to the closed-loop stability margin. In rich mode and during EGO sensor failure (open-loop operation), however, the composite fuel signal is low-pass filtered to attenuate noise introduced in the estimation process. The end result is a signal representing the fuel flow rate that would be translated to injector pulse times in an actual system."
            },
            {
                "heading": "Results and Conclusions",
                "content": "The simulation runs with a throttle input that ramps from 10 to 20 degrees over a period of two seconds, then goes back to 10 degrees over the next two seconds. This cycle repeats continuously while the engine is held at a constant speed so that you can experiment with different fault conditions and failure modes.\n\nClick a sensor fault switch in the dashboard subsystem to simulate the failure of the associated sensor. Repeat this operation to slide the switch back for normal operation.\n\nNow, run the simulation with different sensors turned off. Plot the fuel flow rate and air-fuel ratio for these scenarios:\n\nAll sensors function properlyThrottle sensor failedSpeed sensor failedEGO sensor failedMAP sensor failed\n\nExamine the fuel flow rate plots. In the baseline case, the fuel rate is regulated tightly, exhibiting a small ripple due to the switching nature of the input circuitry of the EGO sensor. In the other four cases, the system operates in an open loop. The control strategy effectively in maintains the correct fuel profile in the single-failure mode. In each of the fault conditions, the fuel rate is essentially 125% of the baseline flow, fulfilling the design objective of the fuel being 80% rich.\n\nIn each case, note the nonlinear relationship between fuel flow and the triangular throttle command.\n\nExamine the air-fuel ratio plots. The baseline plot shows the effects of closed-loop operation. The mixture ratio is regulated very tightly to the stoichiometric objective of 14.6. The rich mixture ratio is shown in the bottom four plots. Although the ratios are not tightly regulated, as in the closed-loop case, they approximate the desired air-fuel ratio: 0.8*14.6=11.7.\n\nExamine the transient behavior of the system. With a constant throttle angle of 12 degrees and the system in steady-state, a throttle failure is introduced at t = 2 and corrected at t = 5. At the onset of the failure, the fuel rate increases immediately. You can see the effects at the exhaust as the rich ratio propagates through the system. The steady-state condition then quickly recovers when closed-loop operation is restored."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/slref/modeling-a-fault-tolerant-fuel-control-system.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_01.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_02.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_03.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_04.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_05.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_06.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_07.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq15575161665943273147.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq05975901767288486394.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq16878846180620141966.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq16942725528250293537.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq03412664294994448635.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq17474218729891534850.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq14565368796057392341.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq06328725544744261668.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq01304949250726831002.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq03672570216166004773.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq05409445070299115703.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_eq05755431812184294609.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_08.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_09.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_10.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_11.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_12.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_13.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_14.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_15.png",
            "https://in.mathworks.com/help/examples/simulink_automotive/win64/ModelingAFaultTolerantFuelControlSystemExample_16.png"
        ]
    },
    {
        "title": "Compile Source Code for Functional Mock-up Units - MATLAB &amp; Simulink\n",
        "introduction": "FMU | slrealtime.fmu.compileFMUSources",
        "chunks": [
            {
                "heading": "Implement the FMU Block in Model",
                "content": "To implement the vanDerPol block in the Simulink model by using the FMU, specify the FMU name for the block. Open the model slrt_ex_vanderpol, double-click the FMU block vanDerPol, and select the vanDerPol.fmu file for the FMU name block parameter.\n\nBuild the model, load the real-time application on the target computer, and run the real-time application."
            },
            {
                "heading": "Compile FMU File That Contains Source Code",
                "content": "The slrealtime.fmu.compileFMUSources function compiles an FMU file that contains source code. The process outputs an FMU file and Simulink Real-Time binary file in the same folder as the input FMU file and appends an _slrt suffix to the output file name. This example selects an FMU file to compile and overwrites previous compiler output.\n\nCopy an example file to the current working folder.\n\nmkdir tempdir myFmuDir; cd tempdir; cd myFmuDir; copyfile ../../slrt_ex_fmu_work;\n\nWarning: Directory already exists.\n\nCreate variable to provide path and file name.\n\nmy_file = 'vanDerPol.fmu';\n\nCompile the FMU file and overwrite previous output.\n\nevalc('slrealtime.fmu.compileFMUSources(my_file,''overwriteBinary'',true)');"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/build-considerations-for-functional-mockup-units.html",
        "images": []
    },
    {
        "title": "Specify Bus Properties with Bus Objects",
        "introduction": "Each bus object provides a reusable specification for a bus that the software can use to validate the properties of the bus and its elements. Multiple blocks, objects, and model components can specify the same bus object. A Simulink.Bus object specifies only the architectural properties of a bus, as distinct from the values of the signals it contains. For example, a bus object can specify the number of elements in a bus, the order of those elements, whether and how elements are nested, and the data types of constituent signals; but not the signal values. A bus object is analogous to a structure definition in C: it defines the members of the bus, but does not create the bus. A bus object is also like a cable connector. The connector defines the pins and their configuration and controls what types of wires can connect to it. Similarly, a bus object defines the configuration and properties of the signals that the associated bus must have. Bus objects are optional for virtual buses but required for nonvirtual buses. For more information about virtual and nonvirtual buses, see Composite Interface Guidelines.",
        "chunks": [
            {
                "heading": "Determine Whether to Use Bus Objects",
                "content": "You can specify bus properties individually or with a bus object. Depending on your modeling requirement, the way you define the bus properties can differ.\n\nModeling RequirementSpecification SourceAssign or validate the hierarchy and properties of an input bus at a subsystem or model interface.Use an In Bus Element block or Simulink.Bus object.Assign or validate the hierarchy and properties of an output bus at a subsystem or model interface.Use an Out Bus Element block or Simulink.Bus object.Assign or validate the hierarchy and properties of a bus across multiple blocks or model components.Use a Simulink.Bus object.Trace the correspondence between the model and generated code for a bus.Use a nonvirtual bus defined by a Simulink.Bus object.The generated code for a nonvirtual bus produces a structure. Nonvirtual buses can result in multiple copies of some buses.Design rigid interface specifications for Simscape\u00e2\u0084\u00a2 conserving connections and lock down connection names and types.Use a Simulink.ConnectionBus object.For information about Simulink.ConnectionBus objects, see Design Rigid Interface Specifications for Conserving Connections (Simscape).\n\nWhen the ports of model components directly connect to each other, specify the same or an equivalent bus object for the blocks that represent those ports. By specifying a bus object with the same hierarchy and properties at both sides of the interface, you enforce consistency at the interface between the two components. For more information about interface design, see Define Interfaces of Model Components.\n\nYou must use Simulink.Bus objects for these modeling configurations:\n\nNonvirtual busesStateflow\u00c2\u00ae charts with bus input or outputS-functions or Legacy Code Tool interfaces with external codeBlocks that require a bus object to define bus input or output. For more information, see Bus-Capable Blocks.\n\nTo enforce strong data typing when you create a bus with a Bus Creator block:\n\nSet the Output data type block parameter to a Simulink.Bus object.Clear the Use names from inputs instead of from bus object block parameter.Set the Element name mismatch configuration parameter to error. This configuration parameter checks that input element names match the corresponding names in the bus object.\n\nWhen you specify a bus object as the data type of a block or object, the properties specified by the bus object typically override the properties specified by the block or object.\n\nFor example, suppose a Signal Specification block has these settings:\n\nUnit set to ft/sData type set to a Simulink.Bus object with elements that specify a unit of m/s\n\nThe Signal Specification block uses m/s as the unit for the bus elements.\n\nBus objects appear in the generated code only when they define nonvirtual buses. For bus objects that define virtual buses, the properties that the bus objects specify appear in the generated code instead of the bus object."
            },
            {
                "heading": "Create Simulink Bus Objects",
                "content": "To create or edit Simulink.Bus objects interactively, use the Type Editor or Model Explorer. The Type Editor displays the bus hierarchy, provides capabilities such as import and export, and lets you update other types, such as Simulink.ValueType objects. The Model Explorer lets you update data objects such as Simulink.Parameter objects. Bus objects created with either tool are initially stored in the base workspace or a data dictionary.\n\nFor an example that creates a bus object using the Type Editor, see Define Multilevel Bus Hierarchy Using Type Editor.\n\nTo create or edit bus objects programmatically, see Programmatically Create Simulink Bus Objects. Bus objects created programmatically are initially stored in the base workspace, a data dictionary, or a function."
            },
            {
                "heading": "Specify Simulink Bus Objects",
                "content": "After you create a Simulink.Bus object and specify its attributes, you can associate it with a block or object that needs the bus definition.\n\nUse a Simulink.Bus object to specify bus properties for these blocks and objects:\n\nBus Creator blockConstant blockData Store Memory blockIn Bus Element blockInport blockOut Bus Element blockOutport blockSignal Specification blockSimulink.BusElement objectSimulink.Parameter objectSimulink.Signal object\n\nTo associate a block or object with a bus object, set the data type of the block or object to Bus: <object name> and replace <object name> with the Simulink.Bus object name. When you set the data type of a Simulink.BusElement object to a Simulink.Bus object, the Bus: prefix is optional.\n\nYou can specify the bus object as the data type either before or after defining the bus object. However, before you simulate the model, you must define and load the Simulink.Bus object.\n\nDuring model development, you can modify buses to match bus objects or modify bus objects to match buses. If you do not want to change the bus object, you can:\n\nCreate a bus object that matches the changes to the bus and use the new bus object for the blocks that the changed bus connects to.Revert the bus changes so that the bus continues to match the associated bus object."
            },
            {
                "heading": "Save Simulink Bus Objects",
                "content": "You can save Simulink.Bus objects to these locations:\n\nData dictionaryFunctionMAT-fileDatabase or other external files\n\nIf you do not save bus objects, then when you reopen a model that uses the bus objects, you need to recreate the bus objects.\n\nChoose where to store bus objects based on your modeling requirements.\n\nModeling RequirementLocationStore data for large models and model hierarchies.Use a data dictionary.When you save to a data dictionary from the base workspace, you get all the variables used by the model, not just the Simulink.Bus objects.To save changes to a data dictionary, use the Type Editor or Model Explorer.To update a model to use a data dictionary, see Migrate Models to Use Simulink Data Dictionary.Use MATLAB\u00c2\u00ae for traceability and model differencing.Use a script or function.To create a script or function that defines one or more Simulink.Bus objects, use the Type Editor, Model Explorer, or Simulink.Bus.save function.Save and load bus objects faster.Use a MAT file.To create a MAT file that contains Simulink.Bus objects from the base workspace, use the Type Editor, Model Explorer, or save function.Compare bus interface information with design documents stored in an external data sourceUse a database or other external files.Use the Simulink.importExternalCTypes function, scripts, or Database Toolbox\u00e2\u0084\u00a2 functionality on C code structure (struct) definitions. In preparation for integrating existing algorithmic C code for simulation, for example, by using the Legacy Code Tool, you can package signal or parameter data in the definitions according to structure type.\n\nTo save bus objects stored in the base workspace, you can use any MATLAB technique that saves the contents of the base workspace. However, the resulting file contains everything in the base workspace, not just bus objects.\n\nWhen you modify bus objects, you must resave them to keep the changes."
            },
            {
                "heading": "Map Simulink Bus Objects to Models",
                "content": "Before you simulate a model, all the Simulink.Bus objects it uses must be loaded into the base workspace or a data dictionary used by the model. For automation and consistency across models, mapping bus objects to models is important.\n\nBy identifying all of the bus objects that a model requires, you can ensure that those objects are loaded before model execution.By identifying all models that use a bus object, you can ensure that changes to a bus object do not cause unexpected changes in any of the models that use the bus object.\n\nTo ensure the necessary bus objects load before model execution, consider these approaches:\n\nProjects \u00e2\u0080\u0094 Automatically load or run files that define bus objects by configuring the files to run when you open a project. For details, see Project Management.Data dictionaries \u00e2\u0080\u0094 Store bus objects with variables and other objects for one or more models.To share a bus object among models, you can link each model to a dictionary and create a common referenced dictionary to store the object. For an example, see Partition Dictionary Data Using Referenced Dictionaries.Databases \u00e2\u0080\u0094 Capture mapping information in an external data source, such as a database.Model callbacks \u00e2\u0080\u0094 Load or run files that define bus objects by using a model callback, such as PreLoadFcn. For more information, see Model Callbacks.If a model uses only a few bus objects, consider copying the bus object code directly into the callback, instead of loading a file.\n\nTo find where a bus object is used in an open model, see Finding Blocks That Use a Specific Variable.\n\nTipUsing a rigorous and standard naming convention is very helpful for mapping bus object usage. For example, consider the model and data required for an actuator control function. Naming the model Actuator and the input and output ports Actuator_bus_in and Actuator_bus_out, respectively, makes the connection between the bus objects and the model clear.Note that this approach can cause issues if the output from one model is fed directly to another model. In this case, the naming mismatch results in an error."
            },
            {
                "heading": "Tools",
                "content": "\u2022 Type Editor"
            },
            {
                "heading": "Objects",
                "content": "\u2022 Simulink.Bus | Simulink.BusElement\n\n\u2022 Control Data Types of Signals\n\u2022 About Data Types in Simulink\n\u2022 Data Types Supported by Simulink\n\u2022 Programmatically Create Simulink Bus Objects\n\u2022 Modify Sample Times for Nonvirtual Buses"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/when-to-use-bus-objects.html",
        "images": []
    },
    {
        "title": "Post-Process Real-time Signals Streamed to the Simulation Data Inspector - MATLAB &amp; Simulink\n",
        "introduction": "slrtTETMonitor | SLRT Overload Options",
        "chunks": [
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Open, Build, and Download Model",
                "content": "Open the model slrt_suspn_3dof. This model simulates vehicle dynamics based on the interaction between road and suspension for different road profiles. The model captures vehicle dynamics in three degrees of freedom: vertical displacement, roll, and pitch. The Signal Editor block stores measured road profile data for the left and right tires as different test groups. The Road-Suspension Interaction subsystem calculates the suspension forces on the vehicle at the four tire locations based on the road data and the current vehicle state. The Body Dynamics subsystem uses these forces and the resulting pitch and roll moments to calculate the vehicle motion in each of the three degrees of freedom.\n\nOpen the model.\n\nmodel = 'slrt_suspn_3dof'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off');\n\nBuild the model:\n\nevalc('slbuild(model)');\n\nClose the model it is open.\n\nbdclose(model);"
            },
            {
                "heading": "Run Model to Calculate the Vertical Vehicle Displacement",
                "content": "Using the Target object, tg, load the real-time application, modify application parameters, and start the application.\n\nload(tg,model); setparam(tg,'','Cf',125); start(tg); while ~strcmp(tg.status,'stopped') pause(5); end stop(tg);"
            },
            {
                "heading": "Update Parameters and Re-calculate the Vertical Vehicle Displacement",
                "content": "Using the Target object, tg, load the real-time application, modify application parameters, and start the application.\n\nload(tg,model); setparam(tg,'','Cf',2375); start(tg); while ~strcmp(tg.status,'stopped') pause(5); end stop(tg);"
            },
            {
                "heading": "Display Signals in Simulation Data Inspector",
                "content": "To view the plotted signal data, open the Simulation Data Inspector.\n\nSimulink.sdi.view"
            },
            {
                "heading": "Retrieve and Plot Signal Data from Simulation Data Inspector",
                "content": "You can also retrieve the signal data from the Simulation Data Inspector and plot (post-process) the data by using these commands.\n\nGet all the runsGet the run informationGet the signalGet the signal objectsPlot the signals\n\nThe result shows the effect on vehicle dynamics from the interaction between road and suspension for different road profiles.\n\nrunIds = Simulink.sdi.getAllRunIDs(); for i = 1:length(runIds) run = Simulink.sdi.getRun(runIds(i)); signalID = run.getSignalIDsByName('vertical_disp'); if ~isempty(signalID) signalObj = Simulink.sdi.getSignal(signalID); signalArray(:,i) = signalObj.Values(:,1).Data; timeValues = signalObj.Values(:,1).Time; plot(timeValues,signalArray); drawnow; end end grid on; title('Response of a 3-DoF Suspension Model'); xlabel('Time (s)'); ylabel('Vehicle vertical displacement (m)');"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/inspect-signals-in-external-mode-using-simulation-data-inspector.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtDataLoggingWithSimulationDataInspectorSDIExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtDataLoggingWithSimulationDataInspectorSDIExample_02.png"
        ]
    },
    {
        "title": "Display Signal Attributes",
        "introduction": "A signal line in a model has attributes such as data type, dimensions, and numeric complexity. When you display these attributes on the block diagram, you can: Additionally, to inspect and specify these attributes in a searchable, sortable table, you can use the Model Data Editor.",
        "chunks": [
            {
                "heading": "Ports & Signals Menu",
                "content": "In the Simulink\u00c2\u00ae Editor, on the Debug tab, the Information Overlays menu offers the following options for displaying signal properties on the block diagram:\n\nLinearization IndicatorsPort Data Types (See Port Data Types)Design Ranges (See Design Ranges)Signal Dimensions (See Signal Dimensions)Storage ClassTestpoint/Logging IndicatorsSignal Resolution Indicators (See Signal to Object Resolution Indicator)Viewer IndicatorsWide Nonscalar Lines (See Wide Nonscalar Lines)\n\nIn addition, you can display sample time information. In the Simulink Editor, on the Debug tab, the Information Overlays menu provides the choices of Colors and Text. The Colors option allows the block diagram signal lines and blocks to be color-coded based on the sample time types and relative rates. The Text option provides black codes on the signal lines which indicate the type of sample time. If you select both Colors and Text, then both the colors and the annotations display. All of these options cause a Sample Time Legend to appear. The legend contains a description of the type of sample time and the sample time rate. If Colors is enabled, color codes also appear in the legend. The same is true if Text is enabled."
            },
            {
                "heading": "Port Data Types",
                "content": "Displays the data type that each signal uses for simulation and code generation. The data type appears next to the output port that emits the signal.\n\nThe notation (c) indicates that the signal is numerically complex (i).\n\nIf you use data type aliases (such as a Simulink.AliasType objects in the base workspace or a data dictionary) to set output data types in your model, by default, the diagram displays the aliases.\n\nIf you create a chain of aliases (for example, by using one Simulink.AliasType object as the base type of another Simulink.AliasType object), the diagram displays only the alias that you use to set the output data type of each signal. The diagram does not display the underlying aliases in the chain.\n\nTo display the lowest underlying base data type (such as int8, single, or s16En14) as well as the alias, in the Debug tab, open the Information Overlays drop-down. Under Ports click Base Data Types and Alias Data Types.\n\nAlternatively, you can display the base type and not the alias by selecting Base Data Types.\n\nWhen you use a fixed-point data type, the diagram displays the base type by using a standard notation that indicates the characteristics of the type (such as signedness and binary fraction length). To interpret this notation, see Fixed-Point Data Type and Scaling Notation (Fixed-Point Designer).\n\nWhen you save a model with Base Data Types enabled, the next time you load the model, it displays the data type and complexity signal attributes."
            },
            {
                "heading": "Design Ranges",
                "content": "Displays the compiled design range of a signal next to the output port that emits the signal. The ranges are computed during an update diagram.\n\nRanges are displayed in the format [min..max]. In the above example, the design range at the output port of the Mux block is displayed as [-10..mixed], because the two signals the Mux block combines have the same design minimum but different design maximums.\n\nYou can also use command-line parameters CompiledPortDesignMin and CompiledPortDesignMax to access the design minimum and maximum of port signals, respectively, at compile time. For more information, see Common Block Properties."
            },
            {
                "heading": "Signal Dimensions",
                "content": "Display the dimensions of nonscalar signals next to the line that carries the signal.\n\nThe format of the display depends on whether the line represents a single signal or a bus. If the line represents a single vector signal, Simulink displays the width of the signal. If the line represents a single matrix signal, Simulink displays its dimensions as [N1xN2] where Ni is the size of the ith dimension of the signal. If the line represents a bus carrying signals of the same data type, Simulink displays N{M} where N is the number of signals carried by the bus and M is the total number of signal elements carried by the bus. If the bus carries signals of different data types, Simulink displays only the total number of signal elements {M}.\n\nTo display signal dimensions, in the Debug tab, open Information Overlays drop-down. Under Signals click Signal Dimensions.\n\nWhen you save a model with this option enabled, update (Ctrl+D) or simulate (Ctrl+T) the model next time you load it to view the signal dimensions.\n\nNoteFor versions R2024a or later, a scalar signal characterized by a matrix of size 1-by-1 is displayed as [1x1]."
            },
            {
                "heading": "Signal to Object Resolution Indicator",
                "content": "The Simulink Editor by default graphically indicates signals that must resolve to signal objects. For any labeled signal whose Signal name must resolve to signal object property is enabled, a signal resolution icon appears to the left of the signal name. The icon looks like this:\n\nA signal resolution icon indicates only that the Signal name must resolve to signal object property for a signal is enabled. The icon does not indicate whether the signal is actually resolved, and does not appear on a signal that is implicitly resolved without its Signal name must resolve to signal object property being enabled.\n\nWhere multiple labels exist, each label displays a signal resolution icon. No icon appears on an unlabeled branch. In the next figure, signal x2 must resolve to a signal object, so a signal resolution icon appears to the left of the signal name in each label:\n\nTo suppress the display of signal resolution icons, in the model window, on the Debug tab, select Information Overlays > Signal Resolves to Object to disable. This option is enabled default. To restore signal resolution icons, enable Signal Resolves to Object . Individual signals cannot be set to show or hide signal resolution indicators independently of the setting for the whole model. For additional information, see:\n\nSymbol Resolution Initialize Signals and Discrete States Simulink.Signal"
            },
            {
                "heading": "Wide Nonscalar Lines",
                "content": "Draws lines that carry vector or matrix signals wider than lines that carry scalar signals.\n\nFor more information on vector and matrix signals, see Signal Types."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/displaying-signal-properties.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/display_port_data_type.png",
            "https://in.mathworks.com/help/simulink/ug/display_port_data_type_alias.png",
            "https://in.mathworks.com/help/simulink/ug/display_port_data_type_alias_base.png",
            "https://in.mathworks.com/help/simulink/ug/display_design_range.png",
            "https://in.mathworks.com/help/simulink/ug/display_signal_dimensions.png",
            "https://in.mathworks.com/help/simulink/ug/signal_res_icon.gif",
            "https://in.mathworks.com/help/simulink/ug/signal_res_icon_model.png",
            "https://in.mathworks.com/help/simulink/ug/display_wide_lines.png"
        ]
    },
    {
        "title": "Build Process Workflow for Real-Time Systems",
        "introduction": "The building process includes generating code in C or C++ from a model and building an executable program from the generated code. This example can use a generic real-time (GRT) or an embedded real-time (ERT) system target file (STF) for code generation. The resulting standalone program runs on your development computer, independent of external timing and events.",
        "chunks": [
            {
                "heading": "Working Folder",
                "content": "This example uses a local copy of the slexAircraftExample model, stored in its own folder, aircraftexample. Set up your working folder as follows:\n\nIn the MATLAB\u00c2\u00ae Current Folder browser, navigate to a folder to which you have write access.To create the working folder, enter the following MATLAB command:mkdir aircraftexampleMake aircraftexample your working folder:cd aircraftexampleOpen the slexAircraftExample model:openExample('slexAircraftExample')The model appears in the Simulink\u00c2\u00ae Editor model window.In the model window, choose File > Save As. Navigate to your working folder, aircraftexample. Save a copy of the slexAircraftExample model as myAircraftExample."
            },
            {
                "heading": "Build Folder and Code Generation Folders",
                "content": "While producing code, the code generator creates a build folder within your working folder. The build folder name is model_target_rtw, derived from the name of the source model and the chosen system target file. The build folder stores generated source code and other files created during the build process. Examine the build folder contents at the end of this example.\n\nWhen a model contains Model blocks (references to other models), the model build creates special subfolders in your Code generation folder to organize code for the referenced models. These code generation folders exist alongside product build folders and are named slprj. For more information, see Generate Code for Model Reference Hierarchy.\n\nUnder the slprj folder, a subfolder named _sharedutils contains generated code that can be shared between models."
            },
            {
                "heading": "Set Model Parameters for Code Generation",
                "content": "To generate code from your model, you must change some of the model configuration parameters. In particular, the generic real-time (GRT) system target file and most other system target files require that the model specifies a fixed-step solver.\n\nNoteFor models that specify variable-step solvers, the code generator produces code only if the models also specify rapid simulation (rsim) or S-function system target files.\n\nOpen the myAircraftExample model if it is not already open.In the Configuration Parameters dialog box, specify configuration parameter values for the solver:Start time: 0.0Stop time: 60Type: Fixed-stepSolver: ode5 (Dormand-Prince)Fixed step size (fundamental sample time): 0.1Treat each discrete rate as a separate task: OffClick Apply.Save the model."
            },
            {
                "heading": "Configure Build Process",
                "content": "To configure the build process for your model, choose a system target file, a toolchain or template makefile, and a make command.\n\nIn these examples and in most applications, you do not need to specify these parameters individually. The examples use the ready-to-run generic real-time target (GRT) configuration. The GRT system target file builds a standalone executable program that runs on your desktop computer.\n\nTo select the GRT system target file:\n\nOpen the myAircraftExample model if it is not already open.In the Configuration Parameters dialog box, in the System target file field, enter grt.tlc. Then click Apply. You see selections for Toolchain (Automatically locate an installed toolchain), and Build Configuration (Faster Builds).Save the model.\n\nNoteIf you click Browse, a System Target File Browser opens and displays the system target files on the MATLAB path. Some system target files require additional products. For example, ert.tlc requires Embedded Coder\u00c2\u00ae."
            },
            {
                "heading": "Set Code Generation Parameters",
                "content": "Open the myAircraftExample model if it is not already open.In the Configuration Parameters dialog box, specify settings: Use the default settings for the Code Generation advanced parameters, which control build verbosity and debugging:Verbose build (RTWVerbose)Retain .rtw file (RetainRTWFile)Profile TLC (ProfileTLC)Start TLC debugger when generating code (TLCDebug)Start TLC coverage when generating code (TLCCoverage)Enable TLC assertion (TLCAssert)Use the default Code Generation > Comments settings.The Code Generation > Identifiers options control the look and feel of generated code. Use the default settings.Select Code Generation > Interface. From the Shared code placement list, select Shared location. The build process places generated code for utilities in a subfolder within your Code generation folder.Under the Advanced parameters, select the Single output/update function check box. In Code Generation > Report, select Create code generation report and Open report automatically. This action enables the software to create and display a code generation report for the myAircraftExample model. Click Apply and save the model."
            },
            {
                "heading": "Build and Run a Program",
                "content": "The build process generates C code from the model. It then compiles and links the generated program to create an executable image. To build and run the program:\n\nWith the myAircraftExample model open, perform one of these actions:On the Apps tab, open the Simulink Coder app. In the C Code tab, click Build.Press Ctrl+B.Run the slbuild command from the MATLAB command line.You see code generation and compilation messages in the Command Window. The initial message is:### Starting build procedure for model: myAircraftExampleThe contents of many of the succeeding messages depends on your compiler and operating system. The final messages include:### Created executable myAircraftExample.exe ### Successful completion of build procedure for model: myAircraftExample ### Creating HTML report file index.htmlThe code generation folder now contains an executable, myAircraftExample.exe (Microsoft\u00c2\u00ae Windows\u00c2\u00ae platforms) or myAircraftExample (UNIX\u00c2\u00ae platforms). In addition, the build process has created an slprj folder and a myAircraftExample_grt_rtw folder in your Code generation folder.NoteAfter generating the code for the myAircraftExample model, the build process displays a code generation report. See Report Generation for more information about how to create and use a code generation report.To see the contents of the working folder after the build, enter the dir or ls command:>> dir . myAircraftExample.slx slprj .. myAircraftExample.slx.autosave myAircraftExample.exe myAircraftExample_grt_rtwTo run the executable from the Command Window, type !myAircraftExample. The ! character passes the command that follows it to the operating system, which runs the standalone myAircraftExample program.>> !myAircraftExample ** starting the model ** ** created myAircraftExample.mat **To see the files created in the build folder, use the dir or ls command again. The exact list of files produced varies among MATLAB platforms and versions. Here is a sample list from a Windows platform:>> dir myAircraftExample_grt_rtw . rt_main.obj myAircraftExample_data.c .. rtmodel.h myAircraftExample_data.obj buildInfo.mat rtw_proj.tmw myAircraftExample_private.h codeInfo.mat myAircraftExample.bat myAircraftExample_ref.rsp myAircraftExample.c myAircraftExample_types.h html myAircraftExample.h myAircraftExample.mk rt_logging.obj myAircraftExample.obj"
            },
            {
                "heading": "Contents of the Build Folder",
                "content": "The build process creates a build folder and names it model_target_rtw, where model is the name of the source model and target is the system target file selected for the model. In this example, the build folder is named myAircraftExample_grt_rtw.\n\nThe build folder includes the following generated files.\n\nFileDescriptionmyAircraftExample.cStandalone C code that implements the modelmyAircraftExample.hAn include header file containing definitions of parameters and state variablesmyAircraftExample_private.hHeader file containing common include definitionsmyAircraftExample_types.hForward declarations of data types used in the codertmodel.h Header file for including generated code in the static main program (its name does not change, and it simply includes myAircraftExample.h)\n\nThe code generation report that you created for the myAircraftExample model displays a link for each of these files. You can click the link explore the file contents.\n\nThe build folder contains other files used in the build process. They include:\n\nmyAircraftExample.mk \u00e2\u0080\u0094 Makefile for building executable using the specified Toolchain.Object (.obj) filesmyAircraftExample.bat \u00e2\u0080\u0094 Batch control filertw_proj.tmw \u00e2\u0080\u0094 Marker filebuildInfo.mat \u00e2\u0080\u0094 Build information for relocating generated code to another development environmentmyAircraftExample_ref.rsp \u00e2\u0080\u0094 Data to include as command-line arguments to mex (Windows systems only)\n\nThe build folder also contains a subfolder, html, which contains the files that make up the code generation report. For more information, see Reports for Code Generation."
            },
            {
                "heading": "Customized Makefile Generation",
                "content": "After producing code, the code generator produces a customized makefile, model.mk. The generated makefile instructs the make system utility to compile and link source code generated from the model, any required harness program, libraries, or user-provided modules. The code generator produces the file model.mk regardless of the approach that you use for build process control:\n\nIf you use the toolchain approach, the code generator creates model.mk based on the model Toolchain settings. You can modify generation of the makefile through the rtwmakecfg.m API.If you use the template makefile approach, the code generator creates model.mk from a system template file, system.tmf (where system stands for the selected system target file name). The system template makefile is designed for your system target file. You can modify the template makefile to specify compilers, compiler options, and additional information for the creation of the executable.\n\nFor more information, see Configure Toolchain (ToolchainInfo) or Template Makefile Build Process."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/build-process-workflow-for-real-time-systems.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/me_cp_rtw_general_f14rtw.png"
        ]
    },
    {
        "title": "Viewers and Generators Manager",
        "introduction": "Using the Viewers and Generators Manager, you can manage viewers and generators from a central point. Viewers and generators are not blocks. Blocks are dragged from the Library Browser and managed with block dialog boxes. Viewers and generators are mechanisms that create or visualize signals, but are added and managed through the Viewers and Generators Manager. Symbols identify a viewer attached to a signal line, and signal names identify generators. Floating Scope | Scope | Scope Viewer",
        "chunks": [
            {
                "heading": "Open the Viewers and Generators Manager",
                "content": "From the Simulation tab, open the Prepare gallery and select Viewers Manager. The Viewers and Generators Manager panel opens to the side of the Simulink editor.\n\nYou can also access the Viewers and Generators Manager by right-clicking a signal or block input and selecting Viewers and Generators Manager."
            },
            {
                "heading": "Change Parameters",
                "content": "Open the Viewers and Generators Manager.In the list of Generators or Viewers, select the viewer or generator you want to modify.Select the button.For a generator, the parameters dialog box opens for that generator type.For a viewer, either a parameter dialog opens or the viewer itself opens. If the viewer opens, you can access parameters from the button.Review and change parameters."
            },
            {
                "heading": "Connect Viewers and Generators",
                "content": "Connect signals to a new viewer or generator using the Viewers and Generators Manager.\n\nOpen the Viewers and Generators Manager panel.Select either the Viewers or Generators tab.Click .From the list of viewers or generators, select the viewer or generator you just added. Select the button. The canvas grays, indicating you are now in connect mode. For generators, click the block you want to connect the generator to and in the pop-up, select the check box for the input port you want to attach to.For viewers, click the signal or signals you want to visualize and in the pop-up, select the check box next to the signals you want to connect. If you have multiple displays or specific inputs, select the display you want to connect to from the drop down before selecting the check box.Close connect mode by clicking the X in the upper right corner of the canvas."
            },
            {
                "heading": "View Test Point Data",
                "content": "Use a Scope viewer available from the Viewers and Generators Manager to view any signal that is defined as a test point in a referenced model. A test point is a signal that you can always see when using a Scope viewer in a model.\n\nNoteWith some viewers (for example, To Video Display, Matrix Viewer), you cannot use the Signal Selector to select signals with test points in referenced models.\n\nFor more information, see Configure Signals as Test Points."
            },
            {
                "heading": "Customize Viewers and Generators Manager",
                "content": "You can add custom signal viewers or generators so that they appear in the Viewers and Generators Manager. This procedure adds a custom viewer named newviewer to the Viewers and Generators Manager:\n\nCreate a new Simulink\u00c2\u00ae library by selecting Simulation > New > Library.Save the library as newlib.In the MATLAB\u00c2\u00ae Command Window, set the library type to a viewer library:set_param('newlib','LibraryType','SSMgrViewerLibrary')To set the library type for generators, use the type 'SSMgrGenLibrary'. For example:set_param('newlib','LibraryType','SSMgrGenLibrary')Set the display name of the library:set_param('newlib','SSMgrDisplayString','My Custom Library')Add your custom viewer or generator to the library by dragging and dropping into the Simulink canvas.NoteIf the viewer is a compound viewer, such as a subsystem with multiple blocks, make the top-level subsystem an atomic one.Set the iotype of the viewer. For example:set_param('newlib/newviewer','iotype','viewer')Save the library newlib.Using the MATLAB editor, create a file named sl_customization.m. In this file, enter a directive to incorporate the new library as a viewer library. For example, to save newlib as a viewer library, add these lines:function sl_customization(cm) cm.addSigScopeMgrViewerLibrary('newlib') %end functionTo add a library as a generator library, use this syntax instead:cm.addSigScopeMgrGeneratorLibrary('newlib')Add a corresponding cm.addSigScope line for each viewer or generator library you want to add.Save the sl_customization.m file on your MATLAB path. Edit this file to add new viewer or generator libraries.To see the new custom libraries, restart MATLAB and start the Viewers and Generators Manager."
            },
            {
                "heading": "Limitations",
                "content": "Viewers and Generators Manager workflows do not support library models, subsystem references, and System Composer\u00e2\u0084\u00a2."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/signal-and-scope-manager.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/description_pix1.png",
            "https://in.mathworks.com/help/simulink/ug/sasm_scope_param_icon.png",
            "https://in.mathworks.com/help/simulink/ug/icon_propertiesea4aa85b1eab3790251ae3c1b15bdaad.png",
            "https://in.mathworks.com/help/simulink/ug/icon_add.png",
            "https://in.mathworks.com/help/simulink/ug/sasm_icon_signal_selector.png"
        ]
    },
    {
        "title": "Execute Real-Time Application in Simulink External Mode by Using Step-by-Step Commands",
        "introduction": "Control of the real-time application with Simulink\u00c2\u00ae is limited to connecting a Simulink model to a real-time application through external mode, and then starting the real-time application. Using Simulink external mode is one method to tune parameters. The model connects to the target computer that you have selected in the Simulink Editor on the Real-Time tab. After you build and download a real-time application to the target computer, you can run the real-time application. This procedure uses the Simulink model slrt_ex_osc_rt. To open the model, in the MATLAB\u00c2\u00ae Command Window, type: For more information about building applications, see Build and Download Real-Time Application by Using Run on Target. You must already have specified the required target computer environment. Specifically, in the Simulink Editor, from the target computers list on the Real-Time tab, you must select the target computer to which you want to connect. When the real-time application is deployed to the target computer, the step-by-step commands provide additional workflow options. Target | Mux | load",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/execute-real-time-application-in-external-mode-with-step-by-step.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-disconnect-target-computer.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-connect-target-computer.png",
            "https://in.mathworks.com/help/slrealtime/gs/window-step-by-step-build-connect-load-run-pulldown.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-build-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-deploy-real-time-application-mldatx-to-target-computer.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-connect-model-to-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-start-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/window-external-mode-scope.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-stop-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-connect-model-to-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-disconnect-model-from-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-start-real-time-application-mldatx.png",
            "https://in.mathworks.com/help/slrealtime/gs/gui-icon-button-restart-real-time-application-mldatx.png"
        ]
    },
    {
        "title": "Signal Label Propagation",
        "introduction": "You can give names to signals and configure the signals to propagate the signal names in a Simulink\u00c2\u00ae model to track a signal through one block or many blocks. For a list of supported blocks, see Blocks That Support Signal Label Propagation. When you name a signal and enable the display of signal label propagation for output signals of allowed blocks: Simulink does not propagate signal labels for commented out blocks. For example, in the following model, the output signal from the Subsystem block is configured for signal label propagation. The propagated signal label (<const>) is based on the name of the upstream output signal of the Constant block (const). For more information on how Simulink creates propagated signal labels, see How Simulink Propagates Signal Labels. Signal Properties",
        "chunks": [
            {
                "heading": "Blocks That Support Signal Label Propagation",
                "content": "You can propagate signal labels at the output of these blocks:\n\nBus Selector \u00e2\u0080\u0094 The propagated names come from the inputs to the corresponding Bus Creator block, the inputs to the corresponding Out Bus Element block, the elements of the corresponding Simulink.Bus object, or similar.EnableFrom \u00e2\u0080\u0094 The propagated name comes from the input to the corresponding Goto block.Function-Call SplitIn Bus Element \u00e2\u0080\u0094 The propagated name depends on what the In Bus Element block selects.When the In Bus Element block selects the entire input from a subsystem port, the block propagates the upstream name from the parent. To support this type of signal label propagation, the In Bus Element block must be in a subsystem, not a model.When the In Bus Element block selects an element from a subsystem or model port, the block propagates the element name. (since R2024b)Inport \u00e2\u0080\u0094 The propagated name comes from the corresponding input to the parent subsystem. To support signal label propagation, the Inport block must be in a subsystem, not a model.Model \u00e2\u0080\u0094 When specified, the propagated names come from the Output name parameter of the corresponding Out Bus Element blocks (since R2023a) or the Signal name parameter of the corresponding Outport blocks. Otherwise, the propagated names come from the inputs to the corresponding Outport or Out Bus Element blocks.Signal SpecificationSubsystem \u00e2\u0080\u0094 The propagated names come from the inputs to the corresponding Outport or Out Bus Element blocks.Trigger\n\nThe Signal Properties dialog box for a signal indicates whether that signal supports signal label propagation. The Show propagated signals parameter is available only for blocks that support signal label propagation. For details, see Display Propagated Signal Labels."
            },
            {
                "heading": "How Simulink Propagates Signal Labels",
                "content": "In general, Simulink performs signal label propagation consistently:\n\nFor different modeling constructs (for example, nonbus signals and buses, virtual and nonvirtual buses, subsystem and model variants, model references, and libraries)In models with or without hidden blocks, which Simulink inserts in certain cases to enable simulationAt model load, edit, update, and simulation times\n\nFor information about some special cases, see:\n\nProcessing for Referenced Models Processing for Variants and Configurable Subsystems"
            },
            {
                "heading": "General Signal Label Propagation Processing",
                "content": "In general, when you enable signal label propagation for an output signal of a block (for example, BlockA), Simulink performs the following processing to find the source signal name to propagate:\n\nChecks the block whose output signal connects to BlockA, and if necessary, continues checking upstream blocks, working backward from the closest block to the farthest block.Stops when it encounters a block that either:Supports signal label propagation and has a signal nameDoes not support signal label propagationObtains the signal name, if any, of the output signal for the block at which Simulink stops.Uses that signal name for the propagated signal label of any output signals of downstream blocks for which you enable signal label propagation.\n\nFor example, in the following model, suppose that you enable signal label propagation for the output signal for the Subsystem block (that is, the signal connected to the Out1 port).\n\nSimulink checks inside the subsystem, checks upstream from the From and GoTo blocks (which support signal label propagation and do not have a name), and then checks further upstream, to the Constant block, which does not support signal label propagation.\n\nSimulink uses the signal name of the Constant block output signal, const. The propagated signal label for the Subsystem block output signal is <const>.\n\nIf the output signal from the Constant block did not have a signal name, then the propagated signal label would be an empty set of angle brackets (<>).\n\nSuppose that in the Subsystem block you enable signal label propagation for the output signal from the In1 block, and you use the Signal Properties dialog box to specify the signal name const-from for the output signal of the From block, as shown below.\n\nThe propagated signal label for the Subsystem block output signal changes to <const-from>, because that is the first named signal that Simulink encounters in its signal label propagation processing.\n\nIn the following model, the signal label propagation for the output signal of the Subsystem block uses the signal name bus1, which is the name of the output bus of the Bus Creator block. The propagated signal label does not include the names of the bus element signals (a and b)."
            },
            {
                "heading": "Display Propagated Signal Labels",
                "content": "You can display propagated signal labels for individual signals, or display the propagated signal labels for all signals in a model. To display the labels for all signals, in the Simulink Editor, on the Debug tab, select Information Overlays > Propagated Signal Labels.\n\nTo display a propagated signal label for an individual signal:\n\nRight-click the signal for which you want to display a propagated signal label and select Properties.In the Signal Properties dialog box, select Show propagated signals.The Show propagated signals parameter is available only for output signals from blocks that support signal label propagation.\n\nTo configure a signal to display its propagated name programmatically, use the set_param function to specify the value of the ShowPropagatedSignals property for the port handle that corresponds to the block output port that produces the signal. For example, to enable signal label propagation for the output signal on the first output port of Subsystem block Subsystem in the model MyModel:\n\nUse the get_param function to get the port handles for the block.portHandles = get_param(\"MyModel/Subsystem\",\"PortHandles\");Access the handle for the first output port by index. The block port handles are returned as a structure that contains a field for each type of port the block might have.outport1 = portHandles.Outport(1);Use the set_param function to specify the value for the ShowPropagatedSignals parameter for the output port as on.set_param(outport1,ShowPropagatedSignals=\"on\")\n\nIf a signal already has a label, then an alternative approach for displaying a propagated signal label is:\n\nIn the model diagram, click the signal label.Remove the label text.In the signal label text box, enter an angle bracket (<).Click outside the signal label. Simulink displays the propagated signal label."
            },
            {
                "heading": "Special Cases of Signal Propagation",
                "content": ""
            },
            {
                "heading": "Processing for Referenced Models",
                "content": "To enable signal label propagation for referenced models, in addition to the steps described in Display Propagated Signal Labels, use the default setting for the Model Configuration Parameters > Model Referencing > Propagate all signal labels out of the model parameter. In other words, make sure the parameter is enabled.\n\nIf you make a change inside a referenced model that affects signal label propagation, the propagated signal labels outside of the referenced model do not reflect those changes until after you update the diagram or simulate the model.\n\nFor example, the model ex_signal_label_prop_model_ref has a referenced model that includes an output signal from the In1 block that has a signal name of input_1.\n\nIf you enable signal label propagation for the signal from the Out1 port of the Model block, that signal does not reflect the name input_1 until after you update the diagram or simulate the model."
            },
            {
                "heading": "Processing for Variants and Configurable Subsystems",
                "content": "Simulink updates the propagated signal label (if enabled) for the output signal of the Subsystem or Model block, when both of these conditions occur:\n\nThe output signals for variant models have different signal names.You change the active variant model or variant subsystem.\n\nFor Subsystem blocks, the signal label updates at edit time. For Model blocks, the update occurs when you update diagram or simulate the model."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/signal-label-propagation.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_const_label.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_simple_no_prop.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_simple_no_prop_subsys.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_const_label.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_simple_no_name.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_simple_rename_subsys.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_rename.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_bus.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_propagation_dialog.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_model_ref.png",
            "https://in.mathworks.com/help/simulink/ug/signal_label_prop_ref_model.png"
        ]
    },
    {
        "title": "Variable-Size Signal Basics",
        "introduction": "A Simulink\u00c2\u00ae signal can be a scalar, vector (1-D), matrix (2-D), or N-D. A Simulink variable-size signal is a signal whose size (the number of elements in a dimension), in addition to its values, can change during a model simulation. However, during a simulation, the number of dimensions cannot change. This capability allows you to model systems with varying resources, constraints, and environments. You can create variable-size signals in your Simulink model by using:",
        "chunks": [
            {
                "heading": "How Variable-Size Signals Propagate",
                "content": "In the Simulink environment, variable-size signals can change their size during model execution in one of two ways:\n\nAt every step of model execution Various blocks in the model modify the sizes of the signals during execution of the output method.Only during initialization of conditionally executed subsystemsSize changes occur during distinct mode-switching events in subsystems such as action, enable, and function-call subsystems.\n\nYou can see the key difference by considering a Discrete 2-Tap Filter block with states.\n\nDiscrete 2-Tap Filter\n\nAssume that the input signal dimension to this filter changes from 4 to 1 during simulation. It is ambiguous when and how the states of the Unit Delay blocks should adapt from 4 to 1 to continue processing the input. To ensure consistency, both Unit Delay blocks must change their state behavior synchronously. To prevent ambiguity, Simulink generally disallows blocks whose number of states depends on input signal sizes in contexts where signal sizes change at any point during execution.\n\nIn contrast, consider the same Discrete 2-Tap Filter block in a function-call subsystem. Assume that this subsystem is using the second way to propagate variable-size signals. In this case, the size of the input signal changes from 4 to 1 only at the initialization of the subsystem. At initialization, the subsystem resets all of its states (including the states of the two Unit Delay blocks) to their initial values. Resetting the subsystem ensures no ambiguity on the assignment of states to the input signal of the filter.\n\nMode-Dependent Variable-Size Signals shows how you can use the two ways of propagating variable-size signals in a complementary fashion to model complex systems."
            },
            {
                "heading": "Determine Whether Signal Line Has Variable Size",
                "content": "The following example demonstrates how to use commands at the command prompt or in a script to determine whether a signal line has a variable size. In a large model or hierarchy of subsystems or referenced models, use this technique to determine whether a signal has a variable size due to an upstream block.\n\nThe example model sldemo_varsize_basic contains a signal a that is downstream of a Switch block.\n\nOpen the example model.Select the Sum block whose output signal is labeled a.Type the following at the command window to set the model to a compiled state (similar to a diagram update). sldemo_varsize_basic([],[],[],'compile') Get a handle to the block output port. portHandles = get_param(gcb,'portHandles'); outPortHandle = portHandles.Outport; Query the programmatic parameter CompiledPortDimensionsMode of the output port. varSize = get_param(outPortHandle,'CompiledPortDimensionsMode') varSize = 1 The value of the variable varSize is 1, which indicates that the signal a has variable size.The value 0 indicates that a signal does not have variable size.Terminate the model compilation. sldemo_varsize_basic([],[],[],'term')"
            },
            {
                "heading": "Empty Signals",
                "content": "An empty signal is a signal with a length of 0. For example, signals with size [0], [0x3], [2x0], and [2x0x3] are all empty signals. Simulink allows empty signals with variable-size signals and supports most element-wise operations. However, Simulink does not support empty signals for blocks that modify signal dimensions. Unsupported blocks include Reshape, Permute, and Sum along a specified dimension."
            },
            {
                "heading": "Simulink Block Support for Variable-Size Signals",
                "content": "The Simulink Block Data Type Support table includes a complete list of blocks that support variable-size signals.\n\nTo view the table:\n\nOpen a Simulink model.In the MATLAB\u00c2\u00ae command line, enter showblockdatatypetable.A separate window with the Simulink Block Data Type Support table opens.\n\nAn X in the Variable-Size Support column indicates support for that block.\n\nTipYou can also view the table by entering showblockdatatypetable at the command prompt."
            },
            {
                "heading": "Subsystem Initialization of Variable-Size Signals",
                "content": "The initial signal size from an Outport block in a conditionally executed subsystem varies depending on the parameters you select.\n\nIf you set the Propagate sizes of variable-size signals parameter in the parent subsystem to During execution, the Initial output parameter for the Output block must not exceed the maximum size of the input port. If the Initial output parameter value is:\n\nInitial output parameterInitial output signal sizeA nonscalar matrixThe initial output signal size is the size of the Initial output parameter.A scalarThe initial output signal size is a scalar.The default []The initial output size is an empty signal (dimensions are all zeros).\n\nIf you set the Propagate sizes of variable-size signals parameter in the parent subsystem to Only when enabling, the Initial output parameter for the Output block must be a scalar value.\n\nWhen size is repropagated for the input of the Outport block, the initial output value is set using scalar expansion from the scalar parameter value.If the Initial output parameter is the default value [], Simulink treats the initial output as a grounded value. If the model does not activate the parent subsystem at start time (t = 0), the current size of the subsystem output corresponding to the Outport block is set to maximum size.When its parent subsystem repropagates signal sizes, the values of the subsystem variable-size output signals are also reset to their initial output parameter values."
            },
            {
                "heading": "Conditionally Executed Subsystem Blocks",
                "content": "Control port blocks are in conditionally executed subsystems. You can set the Propagate sizes of variable-size signals parameter for these blocks to During execution, Only when execution is resumed (Action Port), and Only when enabling (Enable and Trigger or Function-Call).\n\nAction PortEnableTrigger \u00e2\u0080\u0094 Trigger type set to function-call"
            },
            {
                "heading": "Switching Blocks",
                "content": "Switching blocks support variable-size signals by allowing input signals with different sizes and propagating the size of the input signal to the output signal. You can set the Allow different data input sizes parameter for these blocks on the Signal Attributes pane to either on or off.\n\nSwitchMultiport SwitchManual Switch"
            },
            {
                "heading": "Variable-Size Signal Limitations",
                "content": "The following table describes variable-size signal limitations.\n\nLimitationWorkaroundArray format logging does not support variable-size signals.Use a Structure, Structure With Time, or Dataset format for logging variable-size signals.Variable-size signals must have a discrete sample time.\u00e2\u0080\u0094Embedded Coder\u00c2\u00ae does not support variable-size signals with ERT S-functions, custom storage classes, function prototype control, the AUTOSAR model interface, the C++ interface, and the ERT reusable code interface.\u00e2\u0080\u0094Simulink does not support variable-size parameter or DWork vectors.\u00e2\u0080\u0094Rapid accelerator mode does not support models having root-level input ports with variable-size signals.\u00e2\u0080\u0094Virtual buses that you use as inputs to or outputs from a referenced model (Model block) do not support variable-size signals.Configure the bus as nonvirtual. For more information about using buses as inputs to or outputs from a referenced model, see Use Buses at Model Interfaces. For more information about controlling bus virtuality, see Composite Interface Guidelines.Referenced models configured to use a local solver do not support variable-size signals on the model interface.\u00e2\u0080\u0094Variable-size signals are not supported for blocks that specify an initial condition as a MATLAB structure.\u00e2\u0080\u0094Variable-size signals are supported for arrays of buses only in normal simulation mode.\u00e2\u0080\u0094Some simulation modes do not support signal logging for arrays of buses with variable-size signals.Simulate the model in normal mode to log arrays of buses with variable-size signals using signal logging. (since R2023a)MATLAB Function block and Stateflow\u00c2\u00ae chart do not support array of buses with bounded variable-size signals. Bounded variable-size signals indicate variable-size signals with known upper bounds.\u00e2\u0080\u0094Some simulation modes do not support signal logging for nonvirtual buses with variable-size signals.Simulate the model in normal mode or accelerator mode to log: Nonvirtual buses that contain variable-size signals directly or in nested busesBuses with nested nonvirtual buses that contain variable-size signals (since R2023a)Signal logging is not supported for virtual buses with variable-size signals that are not contained within a nested nonvirtual bus.\u00e2\u0080\u0094You cannot apply a storage class to a root-level Outport block (see C Data Code Interface Configuration for Model Interface Elements (Simulink Coder)) if the signal that enters the block has a variable size.Apply the storage class to the signal line instead of the Outport block."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/variable-size-signal-basics.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/discrete_2tap_filter.png",
            "https://in.mathworks.com/help/simulink/ug/supported_blocks_enable_dialog.png",
            "https://in.mathworks.com/help/simulink/ug/supported_blocks_switch_dialog.png"
        ]
    },
    {
        "title": "Troubleshoot Signal Data Logging from Inport in Referenced Model",
        "introduction": "A model contains referenced models. The referenced models have root-inport signals that would be helpful to log and stream to the Simulation Data Inspector for visualization. When these signals are marked in the model for logging, a warning occurs in the diagnostic viewer when building the model:",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "The warning message reports that the root-inport signals of referenced models are not available for streaming. Within top model A, the referenced model root inports that generate this warning message appear in referenced model A/B and referenced model A/B/C.\n\nTop Model A\n\nReferenced Model A/B\n\nReferenced Model A/B/C"
            },
            {
                "heading": "Try This Workaround",
                "content": "To instrument a root-inport signal in a referenced model and stream the signal to the Simulation Data Inspector, you can connect the signal to a Signal Conversion block that you configure as a Signal Copy block. Mark the output of the Signal Copy block for logging to the Simulation Data Inspector."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-inport-ref-model.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/model-troubleshooting-sdi-a.png",
            "https://in.mathworks.com/help/slrealtime/ug/model-troubleshooting-sdi-a-b.png",
            "https://in.mathworks.com/help/slrealtime/ug/model-troubleshooting-sdi-a-b-c.png"
        ]
    },
    {
        "title": "Troubleshoot Signals for Streaming or File Logging",
        "introduction": "There are signals selected for streaming or connected to File Log blocks in a model that generate an error that includes the text: Unable stream signal signal_name.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "This error message for signals selected for streaming or connected to File Log blocks could indicate that the signal has one or more of these issues:\n\nThe signal is not available in application.The signal does not use globally accessible memory in application.The signal connects to a Send/MessageSend block.The signal has inherited sample time.The signal is discontiguous."
            },
            {
                "heading": "Try These Workarounds",
                "content": "The workarounds for these issues vary. Try these."
            },
            {
                "heading": "Workaround for Signal Not Available",
                "content": "Make sure that these signal types are not being logged or streamed by name in the real-time application:\n\nVirtual or bus signals (including signals from bus creator blocks and virtual blocks)Signals that Simulink optimizes awaySignals of complex or multiword data typesBlocks without alphanumeric names"
            },
            {
                "heading": "Workaround for Signal Not Global Available or Discontiguous Signal",
                "content": "To resolve, try inserting a Signal Copy block (a Signal Conversion block in Signal Copy mode) into the signals that you want to stream. Log the copied signal output instead. If you use a Dashboard block, connect it to the output signal of the Signal Copy block."
            },
            {
                "heading": "Workaround for Signal Connected to Message Block",
                "content": "To resolve, try streaming or file logging the input signal to the Send/MessageSend block. The output of the block (a message) cannot be streamed or logged."
            },
            {
                "heading": "Workaround for Signal Has Inherited Sample Time",
                "content": "To resolve, change the signal sample time from inherited to a value. Signals with inherited sample time cannot be streamed or logged."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signals-for-streaming-or-file-log-logging.html",
        "images": []
    },
    {
        "title": "Troubleshoot Missing Real-Time Tab",
        "introduction": "Where is the Real-Time tab? This tab is not visible in the Simulink\u00c2\u00ae editor.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "From the model configuration, the Simulink editor determines which tabs to display. The editor displays the Real-Time tab for models that are configured for Simulink Real-Time\u00e2\u0084\u00a2."
            },
            {
                "heading": "Try This Workaround",
                "content": "To configure your model for Simulink Real-Time, in Simulink Editor, from the Apps tab, click Simulink Real-Time.\n\nThis operation changes the code generation target for the model to a Simulink Real-Time system target file (STF) and applies other configuration parameter changes for compatibility. After changing the configuration, the Simulink editor displays the Real-Time tab for the model."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-missing-real-time-tab.html",
        "images": []
    },
    {
        "title": "Real-Time File Logging and Streaming Workflow",
        "introduction": "You can get signal data into the Simulation Data Inspector through logging by using a File Log block or through streaming by marking a signal for logging in the model or selecting a signal for streaming in the Simulink Real-Time Explorer. Signal logging through a File Log block provides options that let you control: You can configure these options by using the option for the real-time application start(tg) function or by using the Run in Real-Time selection in the Simulink Real-Time Explorer or the Simulink Editor. The File Logging and Streaming Workflow figure shows how these options configure operation of the real-time application start(tg) function. Where startRecording and stopRecording appear in the figure, you can use either these functions or the corresponding Start Recording and Stop Recording buttons on the Real-Time tab in the Simulink Editor or in the Simulink Real-Time Explorer. While the real-time application is running, you can control file logging from File Log blocks: You can stop file logging: After file logging stops, the setting of the AutoImportFileLog name-value argument determines whether file log data is automatically imported into the Simulation Data Inspector or whether you use the import(tg.FileLog) function to import the data. Automatic import of the file log is handled differently by the workflows in the Recording Workflow figure: File Log | Enable File Log | import | start | stop | startRecording | stopRecording",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/real-time-file-logging-and-streaming-workflow.html",
        "images": []
    },
    {
        "title": "Inspect Generated Code for Nonvirtual Buses - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Blocks",
                "content": "\u2022 Bus Creator"
            },
            {
                "heading": "Objects",
                "content": "\u2022 Simulink.Bus\n\n\u2022 Composite Interface Guidelines\n\u2022 Specify Bus Properties with Bus Objects"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/inspect-generated-code-for-nonvirtual-buses.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/InspectGeneratedCodeForNonvirtualBusesExample_01.png"
        ]
    },
    {
        "title": "About RTOS Tasks and Priorities",
        "introduction": "Real-time application execution tasks come from an number of model features, including: The RTOS task scheduler automates scheduling of tasks for all sample rates in the model. You can configure your model to influence task priority of some rate-related tasks. For more information, see Concurrent Execution on Simulink Real-Time. Thread Trigger",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/io_ref/about-rtos-interrupt-priorities-and-tasks.html",
        "images": []
    },
    {
        "title": "Troubleshoot ETAS Inca Operation",
        "introduction": "Investigate issues that can occur when ETAS\u00c2\u00ae Inca controls a real-time application. A third-party calibration tool (ETAS Inca) is not working with the real-time application.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "You can use the ETAS Inca tool to view signals and tune parameters in the real-time application. For more information, see the steps in Prepare ASAP2 Data Description File. In addition to the limitations listed in ETAS Inca Limitations, there are various issues that can prevent the operation of this tool."
            },
            {
                "heading": "Try This Workaround",
                "content": "For ETAS Inca tool issues, try these workarounds."
            },
            {
                "heading": "Simulation Data Inspector in Use",
                "content": "Simulation Data Inspector and the third-party calibration tools (Vector CANape\u00c2\u00ae and ETAS Inca) are mutually exclusive. If you use the Simulation Data Inspector to view signal data, you cannot use the calibration tools. If you use the calibration tools, you cannot use the Simulation Data Inspector to view signal data."
            },
            {
                "heading": "Client Cannot Connect",
                "content": "Check the IP address of the Speedgoat\u00c2\u00ae target computer associated with the model and compare it to the address stored in the ASAP2 file."
            },
            {
                "heading": "ASAP2 File Out of Date",
                "content": "When you rebuild a Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 application, update the ASAP2 file loaded in the calibration tool with the new version of the file. The ASAP2 file is valid only until the next time that you build the application."
            },
            {
                "heading": "Cannot Disable Freeze Mode",
                "content": "Remove the dataset file from the target file system and reset the parameters to the original values specified in your model. The dataset file is named flashdata_model_name.dat."
            },
            {
                "heading": "Transport Layer Failure",
                "content": "When a transport layer failure occurs, ETAS Inca can display this message:\n\nERROR: Transport Layer Failure, Inconsistent MsgCounter\n\nThis error appears in ETAS Inca when the incorrect setting is used for 'Counter Consistency Mode'. Make sure that the 'Counter Consistency Mode' is set to 'one counter for all CTOs+DTOs' in the hardware settings for your experiment."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/etas-inca-troubleshooting.html",
        "images": []
    },
    {
        "title": "Target Computer Command-Line Interface",
        "introduction": "You can load, run, stop, and check the status of a real-time application by using the Speedgoat\u00c2\u00ae target computer command-line interface commands. By default, the target computer displays the session 1 screen with the target computer status monitor. For information about switching to the session 2 screen with the command-line interface, see Target Computer Status Monitor. To read the target computer console log, view the log in the slrtLogViewer.",
        "chunks": [
            {
                "heading": "Target Object Commands",
                "content": "When you are using the target computer command-line interface, target object functions support loading, starting, stopping, and checking the status of the real-time application.\n\nFor a description of how to use these commands, see Control Real-Time Application at Target Computer Command Line.\n\nNoteTo run user commands, log in as user slrt by using password slrt. To run the system commands (for example, date, ntpdate, ntpd, rtc, or setting the time zone), login as user root by using password root.\n\nThese commands are Target object commands that you can use through the command-line interface on the target computer. Each command appears with its equivalent MATLAB\u00c2\u00ae syntax. In the descriptions, Target is the target object name, and app_name is the real-time application MLDATX file name.\n\nTarget: slrealtime listApplicationsMATLAB: getInstalledApplications(Target)When run from the development computer in the MATLAB Command Window, the getInstalledApplications command returns a list of the real-time application that are installed on the target computer.Target: slrealtime load --AppName app_nameMATLAB: load(Target,'app_name')When run from the development computer in the MATLAB Command Window, the load command deploys the real-time application to the target computer and loads the application. When run from the target computer command interface, the load command loads the application.Target: slrealtime startMATLAB: start(Target)The start command runs the real-time application that is loaded on the target computer. Target: slrealtime stopMATLAB: stop(Target)The stop command stops the real-time application that is running on the target computer.Target: slrealtime install --AppName app_nameThe slrealtime install command installs the real-time application MLDATX file for standalone operation on the target computer. The MLDATX file should have been previously downloaded to the target computer and be either in the current directory or specified by using absolute path.MATLAB: install(Target,'app_name')The install command installs the real-time application for standalone operation on the target computer. The command uses the MATLAB path to find the real-time application MLDATX file to install.Target: slrealtime saveParamSet --FileName filenameTarget: slrealtime saveParamSet -F filenameMATLAB: saveParamSet(Target,filename)The saveParamSet command saves the parameter set from the loaded real-time application on the target computer to the specified filename.Target: slrealtime loadParamSet --FileName filenameTarget: slrealtime loadParamSet -F filenameMATLAB: loadParamSet(Target,filename)The loadParamSet command loads the parameter set into the real-time application on the target computer from the specified filename.Target: shutdown -S rebootMATLAB: reboot(Target)The reboot command reboots the target computer.If you prefer to safely shutdown the RTOS before turning off power to the target computer, you can use the command: shutdown -S system"
            },
            {
                "heading": "Target Computer RTOS System Commands",
                "content": "The target computer uses the QNX Neutrino Real-Time Operating System (RTOS). You can run system commands on the target computer from the development computer by using an SSH utility, such as PuTTY. Or, you can run system commands on the target computer from its keyboard (console). Target computer RTOS system command information is available in the Utilities Reference in the QNX Momentics IDE 7.1 User\u00e2\u0080\u0099s Guide. All commands that this reference identifies as Runs on: QNX Neutrino are supported on the target computer.\n\nSome RTOS commands are required for configuring the target computer. These commands include:\n\ndate \u00e2\u0080\u0094 set date and timentpdate \u00e2\u0080\u0094 set the local date and time from NTP serverntpd \u00e2\u0080\u0094 start NTP daemonrtc \u00e2\u0080\u0094 set date from hardware clock\n\nNoteTo run user commands, log in as user slrt by using password slrt. To run the system commands (for example, date, ntpdate, ntpd, rtc, or setting the time zone), login as user root by using password root.\n\nFor a description of how to use these commands, see Execute Target Computer RTOS Commands at Target Computer Command Line."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ref/target-computer-command-line-interface.html#mw_da374454-5c9f-4aff-8084-d43d9541976e",
        "images": []
    },
    {
        "title": "Customize Post-Code-Generation Build Processing",
        "introduction": "The code generator provides a set of tools, including a build information object, you can use to customize build processing that occurs after code generation. You can use such customizations for target development or the integration of third-party tools into your application development environment. RTW.BuildInfo",
        "chunks": [
            {
                "heading": "Workflow for Setting Up Customizations",
                "content": "The following figure and the steps that follow show the general workflow for setting up post-code-generation customizations.\n\nProgram the post code generation command.Define the post code generation command.Suppress makefile generation, if applicable.Build the model.Modify the command and rebuild the model until the build results are acceptable."
            },
            {
                "heading": "Build Information Object",
                "content": "At the start of a model build, the build process logs the following build option and dependency information to a temporary build information object:\n\nCompiler optionsPreprocessor identifier definitionsLinker optionsSource files and pathsInclude files and pathsPrecompiled external libraries\n\nYou can retrieve information from and add information to this object by using an extensive set of functions. For a list of available functions and detailed function descriptions, see Code Compilation Customization. Program a Post Code Generation Command explains how to use the functions to control post code generation build processing."
            },
            {
                "heading": "Program a Post Code Generation Command",
                "content": "For certain applications, you could want to control aspects of the build process after the code generation. For example, you can use this approach if you develop your own target, or you want to apply an analysis tool to the generated code before continuing with the build process. You can apply this level of control to the build process by programming and then defining a post code generation command.\n\nA post code generation command is a MATLAB\u00c2\u00ae language file that typically calls functions that get data from or add data to the build information object of the model. You can program the command as a script or function.\n\nIf you program the command as a:Then the:ScriptScript can gain access to the model name and the build information directlyFunctionFunction can pass the model name and the build information as arguments\n\nIf your post code generation command calls user-defined functions, make sure that the functions are on the MATLAB path. If the build process cannot find a function you use in your command, the build process errors out.\n\nYou can then call a combination of build information functions, as listed in Code Compilation Customization, to customize the post code generation build processing of the model.\n\nThe following example shows a fragment of a post code generation command that gets the file names and paths of the source and include files generated for a model for analysis.\n\nfunction analyzegencode(buildInfo) % Get the names and paths of source and include files % generated for the model and then analyze them. % buildInfo - build information for my model. % Define cell array to hold data. MyBuildInfo={}; % Get source file information. MyBuildInfo.srcfiles=getSourceFiles(buildInfo, true, true); MyBuildInfo.srcpaths=getSourcePaths(buildInfo, true); % Get include (header) file information. MyBuildInfo.incfiles=getIncludeFiles(buildInfo, true, true); MyBuildInfo.incpaths=getIncludePaths(buildInfo, true); % Analyze generated code. . . ."
            },
            {
                "heading": "Define a Post Code Generation Command",
                "content": "After you program a post code generation command, inform the build process that the command exists and to add it to the build processing of the model. Define the command with the PostCodeGenCommand model configuration parameter. When you define a post code generation command, the build process evaluates the command after generating and writing the generated code to disk and before generating a makefile.\n\nAs the following syntax lines show, the arguments that you specify when setting the configuration parameter varies depending on whether you program the command as a script, function, or set of functions.\n\nNoteWhen defining the command as a function, you can specify an arbitrary number of input arguments. To pass the name and build information of the model to the function, specify identifiers modelName and buildInfo as arguments.\n\nScript\n\nset_param(model, 'PostCodeGenCommand',... 'pcgScriptName');\n\nFunction\n\nset_param(model, 'PostCodeGenCommand',... 'pcgFunctionName(modelName)');\n\nMultiple Functions\n\npcgFunctions=... 'pcgFunction1Name(modelName);... pcgFunction2Name(buildInfo)'; set_param(model, 'PostCodeGenCommand',... pcgFunctions);\n\nThe following call to set_param defines PostCodGenCommand to evaluate the function analyzegencode.\n\nset_param(model, 'PostCodeGenCommand',... 'analyzegencode(buildInfo)');"
            },
            {
                "heading": "Customize Build Process with PostCodeGenCommand and Relocate Generated Code to an External Environment",
                "content": "Open Script\n\nThis example shows how to use the build information programming interface and the model configuration parameter Post code generation command (PostCodeGenCommand) to customize the build process. For this example, Post code generation command is set to BuildInfoModel_data. The build process invokes that function after code generation.\n\nThe example also shows how to use build configuration function rtwmakecfg.m.\n\nOpen Example ModelOpen the example model BuildInfoModel.open_system('BuildInfoModel'); Generate Code from ModelGenerate code. The code generator produces the file BuildInfo.html, which documents the build information object.Examine the Build Process Customizations and OutputExamine the build process customizations and the post code generation query of the build information object. In a Web browser, open the file BuildInfo.html. The file provides hyperlinks that you can use to examine the code produced for the model. Alternatively, in the MATLAB Command Window:To view the function configured to execute during the post code generation stage of the build process, enter: get_param('BuildInfoModel','PostCodeGenCommand'); To study the programming interface for the build information object, enter: BuildInfoModel_data(buildInfo); To study how the example uses the rtwmakecfg function, enter: edit rtwmakecfg.m; To view the build information object data that the build process saves in the buildInfo.mat file, open the file BuildInfoModel_grt_rtw\\buildInfo.mat.To view the contents of the post code generation function BuildInfoModel_data.m, enter: edit BuildInfoModel_data.m; At the end of the file, the function calls packNGo to package the source and object files that the build information object identifies for relocation.Related Topics Code Compilation Customization Customize Post-Code-Generation Build Processing Use rtwmakecfg.m API to Customize Generated Makefiles Relocate or Share Generated Code"
            },
            {
                "heading": "Suppress Makefile Generation",
                "content": "The code generator lets you suppress makefile generation during the build process. For example, you can use this support when you integrate tools into the build process that do not use makefiles.\n\nTo instruct the code generator not to produce a makefile, do one of the following:\n\nClear the Generate makefile option on the Code Generation pane of the Configuration Parameters dialog box.Set the value of the configuration parameter GenerateMakefile to off.\n\nWhen you suppress makefile generation,\n\nYou cannot explicitly specify a make command or template makefile. Specify your own instructions for a post code generation processing, including compilation and linking, in a post code generation command as explained in Program a Post Code Generation Command and Define a Post Code Generation Command."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/customizing-post-code-generation-build-processing.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/customize_pcg_build_workflow.png",
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/RelocateCodeAndCustomizePostCodeGenBuildExample_01.png"
        ]
    },
    {
        "title": "Use makecfg to Customize Generated Makefiles for S-Functions",
        "introduction": "With the toolchain or template makefile approach for building code, you can customize generated makefiles for S-functions. Through the customization, you can specify additional items for the S-function build process: To customize the generated makefile: After code generation, in the S-function MEX file folder, the code generator searches for makecfg.m and specificSFunction_makecfg.m files. If the files are present, the code generator uses these files to customize the generated makefile, model.mk. For example, consider a folder that contains signalConvert.mexa64 (S-function binary file) and signalConvert.tlc (inlined S-function implementation) after the TLC phase of the build process. The S-function requires an additional source code file, filterV1.c, which is located in anotherFolder. You can create a file, signalConvert_makecfg.m, that uses RTW.BuildInfo functions to specify filterV1.c for the build process.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/ecoder/ug/use-makecfg-to-customize-generated-makefiles-for-s-functions.html",
        "images": []
    },
    {
        "title": "Manage Build Process Files",
        "introduction": "To apply generated code source and header files from the build process, it is helpful to understand the files that the build process generates and the conditions that control file generation. This information provides access to generated code resources, such as: The code generator creates model.* files during the code generation and build process. You can customize the filenames for generated header, source, and data files. For more information, see Customize Generated File Names (Embedded Coder). The code generator creates additional folders and dependency files to support shared utilities and model references. For more information about the folders that the build process creates, see Manage Build Process Folders. For an example that shows how to use a project to manage build process folders, see Generate Code and Simulate Models in a Project. Depending on model architectures and code generation options, the build process for a GRT-based system target file can produce files that the build process does not generate for an ERT-based system target file. Also, for ERT-based system target files, the build process packages generated files differently than for GRT-based system target files. See Manage File Packaging of Generated Code Modules (Embedded Coder). The table describes the principal generated files. Within the generated filenames shown in the table, the model represents the name of the model for which you are generating code. The subsystem represents the name of a subsystem within the model. When you select the Create code generation report parameter, the code generator produces a set of HTML files. There is one HTML file for each source file plus a model_contents.html index file in the html subfolder within your build folder. The source and header files in the table have dependency relationships. For descriptions of other file dependencies, see Manage Build Process File Dependencies and Add Build Process Dependencies.",
        "chunks": [
            {
                "heading": "model.bat",
                "content": "This file contains Windows batch file commands that set the compiler environment and invoke the make utility.\n\nIf you are using the toolchain approach for the build process, you also can use this batch file to extract information from the generated makefile, model.mk. The information includes macro definitions and values that appear in the makefile, such as CFLAGS (C compiler flags) and CPP_FLAGS (C++ compiler flags). With the folder containing model.bat selected as the current working folder, in the Command Window, type:\n\n>> system('model.bat info')\n\nOn UNIX and Macintosh platforms, the code generator does not create the model.bat file. To extract information for toolchain approach builds from the generated makefile on these systems, in the Command Window, type:\n\n>> system('gmake -f model.mk info')"
            },
            {
                "heading": "model.h",
                "content": "The header file model.h declares model data structures and a public interface to the model entry points and data structures. This header file also provides an interface to the real-time model data structure (model_M) by using access macros. If your code interfaces to model functions or model data structures, include model.h:\n\nExported global signalsextern int32_T INPUT; /* '<Root>/In' */Global structure definitions/* Block parameters (auto storage) */ extern Parameters_mymodel mymodel_P;Real-time model (RTM) macro definitions#ifndef rtmGetSampleTime # define rtmGetSampleTime(rtm, idx) ((rtm)->Timing.sampleTimes[idx]) #endifModel entry-point functions (ERT example)extern void mymodel_initialize(void); extern void mymodel_step(void); extern void mymodel_terminate(void);\n\nTo generate model entry-point functions in files other than model.h and model.c, use a function customization template in the Embedded Coder Dictionary. For more information, see Configure Default C Code Generation for Categories of Data Elements and Functions (Embedded Coder).\n\nThe main.c (or .cpp) file includes model.h. If the model build generates the main.c (or .cpp) file from a TLC script, the TLC source can include model.h.\n\n#include \"%<CompiledModel.Name>.h\"\n\nIf main.c is a static source file, you can use the fixed header filename rtmodel.h. This file includes the model.h header file:\n\n#include \"model.h\" /* If main.c is generated */\n\nor\n\n#include \"rtmodel.h\" /* If static main.c is used */\n\nOther external source files can require to include model.h to interface to model data, for example exported global parameters or signals. The model.h file itself can have additional header dependencies due to requirements of generated code. See System Header Files and Code Generator Header Files.\n\nTo reduce dependencies and reduce the number of included header files, see Manage Build Process File Dependencies."
            },
            {
                "heading": "rtwtypes.h",
                "content": "When the configuration parameter Data type replacement is set to Use coder typedefs, the generated code includes rtwtypes.h. The header file rtwtypes.h defines data types, structures, and macros required by the generated code.\n\nOften, the generated code requires that integer operations overflow or underflow at specific values. For example, when the code expects a 16-bit integer, the code does not accept an 8-bit or a 32-bit integer type. The C language does not set a standard for the number of bits in types such as char and int.\n\nNoteBefore the creation of the C99 language standard, there was no universally accepted data type for sized integers. The C99 standard provides the header files stdint.h and stdbool.h. The stdint.h file contains sized-integer implementations that were previously unavailable.\n\nTo accommodate this feature of the C language, the generated code uses sized integer types, such as int8_T and uint32_T, which are not standard C types. In rtwtypes.h, the generated code maps these sized-integer types to the corresponding C keyword base type using information in the Hardware Implementation pane of the Configuration Parameters dialog box.\n\nThe code generator produces an optimized version of rtwtypes.h for ERT-based system target files when the model does not contain noninlined S-functions. The optimized rtwtypes.h file contains definitions that are specific to the hardware configuration of the model.\n\nThe location of rtwtypes.h depends on whether the build process uses the shared utilities location. If it uses a shared location, the code generator places rtwtypes.h in slprj/target/_sharedutils. Otherwise, it places rtwtypes.h in the build folder (model_target_rtw). See Specify Generated Code Interfaces and Control Placement of rtwtypes.h for Shared Utility Code (Embedded Coder).\n\nSource files include the rtwtypes.h header file when the source files use code generator type names or other code generator definitions. For example, files that declare variables by using a code generator data type:\n\nuint32_T myvar\n\nIn some cases, an S-function, custom source file is compiled, first, by the mex command, and second, by the code generation build. During mex compilation, rtwtypes.h is typically unavailable. To obtain the definitions normally supplied by rtwtypes.h, the custom source file can conditionally (through the MATLAB_MEX_FILE macro definition) include tmwtypes.h:\n\n#ifdef MATLAB_MEX_FILE #include \"tmwtypes.h\" #else #include \"rtwtypes.h\" #endif\n\nA source file for the code generator main.c (or .cpp) file includes rtwtypes.h without preprocessor checks.\n\n#include \"rtwtypes.h\"\n\nCustom source files that the Target Language Compiler generates can also emit the include statements into their generated file.\n\nIf the Data type replacement configuration parameter is set to Use C data types with fixed-width integers, the code generator does not create rtwtypes.h because the generated code does not require definitions from rtwtypes.h. If the generated code uses static files under matlabroot that require Simulink Coder data type definitions, the software generates a simplified version of rtwtypes.h. If you have custom code that includes rtwtypes.h, you can force the generation of the simplified version of rtwtypes.h by selecting the Coder typedefs compatibility check box.\n\n\u00c2 Simplified rtwtypes.h\n\n/* * File: rtwtypes.h * * This version of rtwtypes.h is generated for * compatibility with custom source code or static * source files that are located under matlabroot. * Automatically generated code does not have to * include this file. */ #ifndef RTWTYPES_H #define RTWTYPES_H #include <stdint.h> #include <stdbool.h> typedef int8_t int8_T; typedef uint8_t uint8_T; typedef int16_t int16_T; typedef uint16_t uint16_T; typedef int32_t int32_T; typedef uint32_t uint32_T; typedef bool boolean_T; typedef char char_T; typedef char byte_T; typedef int int_T; typedef unsigned char uchar_T; typedef unsigned int uint_T; typedef unsigned long ulong_T; #define MIN_int8_T INT8_MIN #define MAX_int8_T INT8_MAX #define MAX_uint8_T UINT8_MAX #define MIN_int16_T INT16_MIN #define MAX_int16_T INT16_MAX #define MAX_uint16_T UINT16_MAX #define MIN_int32_T INT32_MIN #define MAX_int32_T INT32_MAX #define MAX_uint32_T UINT32_MAX #endif /* RTWTYPES_H */"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/build-process-files.html",
        "images": [
            "https://in.mathworks.com/help/includes/product/images/doc_center/arrow_right.gif"
        ]
    },
    {
        "title": "Use rtwmakecfg.m API to Customize Generated Makefiles",
        "introduction": "Both the toolchain approach and the template makefile approach for builds let you add the following items to generated makefiles:",
        "chunks": [
            {
                "heading": "About the rtwmakecfg Function",
                "content": "Using an rtwmakecfg function, you add this information to the makefile during the build operation for S-functions. The rtwmakecfg function is useful when specifying added sources and libraries to build a model that contains one or more of your S-function blocks.\n\nTo add information pertaining to an S-function to the makefile:\n\nCreate the MATLAB\u00c2\u00ae language rtwmakecfg function in the rtwmakecfg.m file. The code generator associates this file with your S-function based on its folder location. Create the rtwmakecfg Function describes the requirements for the rtwmakecfg function and the data it returns.If you are using the template makefile approach, modify the TMF of your target such that it supports macro expansion for the information that the rtwmakecfg function returns. Modify the Template Makefile for rtwmakecfg describes the required modifications. If you are using the toolchain approach, the information that the rtwmakecfg function returns is used by the generated makefile; no further configuration is required.\n\nAfter the TLC phase of the build process, when generating a makefile, the code generator searches for an rtwmakecfg.m file in the folder that contains the S-function MEX file. If it finds the file, the build process calls the rtwmakecfg function."
            },
            {
                "heading": "Create the rtwmakecfg Function",
                "content": "Create the rtwmakecfg.m file containing the rtwmakecfg function in the same folder as your S-function component (a MEX-file with a platform-dependent extension, such as .mexext on Microsoft\u00c2\u00ae Windows\u00c2\u00ae systems). The function must return a structured array that contains these fields.\n\nFieldDescriptionmakeInfo.includePathA cell array that specifies additional include folder names, organized as a row vector. The build process expands the folder names into include instructions in the generated makefile.makeInfo.sourcePathA cell array that specifies additional source folder names, organized as a row vector. Include the folder names of files entered into the S-function modules field on the S-Function Block Parameters dialog box or into the SFunctionModules parameter of the block if they are not in the same folder as the S-function. The build process expands the folder names into make rules in the generated makefile.makeInfo.sourcesA cell array that specifies additional source file names (C or C++), organized as a row vector. Do not include the name of the S-function or files entered into the S-function modules field on the S-Function Block Parameters dialog box or into the SFunctionModules parameter of the block. The build process expands the file names into make variables that contain the source files. Specify only file names (with extension). Specify path information with the sourcePath field.makeInfo.linkLibsObjsA cell array that specifies additional, fully qualified paths to object or library files against which the generated code links. The build process does not compile the specified objects and libraries. However, it includes them when linking the final executable. This inclusion can be useful for incorporating libraries that you do not want the build process to recompile or for which the source files are not available. You can also use this element to integrate source files from languages other than C and C++. This integration is possible if you first create a C compatible object file or library outside of the build process.makeInfo.precompileA Boolean flag that indicates whether the libraries specified in the rtwmakecfg.m file exist in a specified location (precompile==1) or if you must create the libraries in the build folder during the build process (precompile==0).makeInfo.libraryA structure array that specifies additional run-time libraries and module objects, organized as a row vector. The build process expands the information into make rules in the generated makefile. For a list of the library fields, see the next table.\n\nThe makeInfo.library field consists of the following elements.\n\nElementDescriptionmakeInfo.library(n).NameA character array that specifies the name of the library (without an extension). makeInfo.library(n).LocationA character array that specifies the folder in which the library is located when precompiled. For more information, see the description of makeInfo.precompile in the preceding table. A target can use the TargetPreCompLibLocation parameter to override this value. See Specify the Location of Precompiled Libraries.makeInfo.library(n).ModulesA cell array that specifies the C or C++ source file base names (without an extension) that comprise the library. Do not include the file extension. The makefile appends the object extension.\n\nNoteThe makeInfo.library field must fully specify each library and how to build it. The modules list in the makeInfo.library(n).Modules element cannot be empty. To specify a link-only library, use the makeInfo.linkLibsObjs field instead.\n\nExample:\n\ndisp(['Running rtwmakecfg from folder: ',pwd]); makeInfo.includePath = { fullfile(pwd, 'somedir2') }; makeInfo.sourcePath = {fullfile(pwd, 'somedir2'), fullfile(pwd, 'somedir3')}; makeInfo.sources = { 'src1.c', 'src2.cpp'}; makeInfo.linkLibsObjs = { fullfile(pwd, 'somedir3', 'src3.object'),... fullfile(pwd, 'somedir4', 'mylib.library')}; makeInfo.precompile = 1; makeInfo.library(1).Name = 'myprecompiledlib'; makeInfo.library(1).Location = fullfile(pwd,'somdir2','lib'); makeInfo.library(1).Modules = {'srcfile1' 'srcfile2' 'srcfile3' };\n\nNoteIf a path that you specify in the rtwmakecfg.m API contains spaces, the build process does not convert the path to its nonspace equivalent. If the build environments you intend to support do not support spaces in paths, refer to Build Process Support for File and Folder Names."
            },
            {
                "heading": "Modify the Template Makefile for rtwmakecfg",
                "content": "To expand the information that an rtwmakecfg function generates, modify the following sections in the TMF of your target:\n\nInclude PathC Flags and/or Additional LibrariesRules\n\nIt is possible that these TMF code examples do not apply to your make utility. For additional examples, see the GRT or ERT TMFs located in matlabroot/toolbox/coder/compile/tmf."
            },
            {
                "heading": "Add Folder Names to the Makefile Include Path",
                "content": "The following TMF code example adds folder names to the include path in the generated makefile:\n\nADD_INCLUDES = \\ |>START_EXPAND_INCLUDES<| -I|>EXPAND_DIR_NAME<| \\ |>END_EXPAND_INCLUDES<|\n\nAlso, the ADD_INCLUDES macro must be added to the INCLUDES line.\n\nINCLUDES = -I. -I.. $(ADD_INCLUDES) $(USER_INCLUDES)"
            },
            {
                "heading": "Add Library Names to the Makefile",
                "content": "The following TMF code example adds library names to the generated makefile.\n\nLIBS = |>START_PRECOMP_LIBRARIES<| LIBS += |>EXPAND_LIBRARY_NAME<|.a |>END_PRECOMP_LIBRARIES<| |>START_EXPAND_LIBRARIES<| LIBS += |>EXPAND_LIBRARY_NAME<|.a |>END_EXPAND_LIBRARIES<|\n\nFor more information, see Control Library Location and Naming During Build."
            },
            {
                "heading": "Add Rules to the Makefile",
                "content": "The TMF code example adds rules to the generated makefile.\n\n|>START_EXPAND_RULES<| $(BLD)/%.o: |>EXPAND_DIR_NAME<|/%.c $(SRC)/$(MAKEFILE) rtw_proj.tmw @$(BLANK) @echo ### \"|>EXPAND_DIR_NAME<|\\$*.c\" $(CC) $(CFLAGS) $(APP_CFLAGS) -o $(BLD)$(DIRCHAR)$*.o \\ |>EXPAND_DIR_NAME<|$(DIRCHAR)$*.c > $(BLD)$(DIRCHAR)$*.lst |>END_EXPAND_RULES<| |>START_EXPAND_LIBRARIES<|MODULES_|>EXPAND_LIBRARY_NAME<| = \\ |>START_EXPAND_MODULES<| |>EXPAND_MODULE_NAME<|.o \\ |>END_EXPAND_MODULES<| |>EXPAND_LIBRARY_NAME<|.a : $(MAKEFILE) rtw_proj.tmw $(MODULES_|>EXPAND_LIBRARY_NAME<|:%.o=$(BLD)/%.o) @$(BLANK) @echo ### Creating $@ $(AR) -r $@ $(MODULES_|>EXPAND_LIBRARY_NAME<|:%.o=$(BLD)/%.o) |>END_EXPAND_LIBRARIES<| |>START_PRECOMP_LIBRARIES<|MODULES_|>EXPAND_LIBRARY_NAME<| = \\ |>START_EXPAND_MODULES<| |>EXPAND_MODULE_NAME<|.o \\ |>END_EXPAND_MODULES<| |>EXPAND_LIBRARY_NAME<|.a : $(MAKEFILE) rtw_proj.tmw $(MODULES_|>EXPAND_LIBRARY_NAME<|:%.o=$(BLD)/%.o) @$(BLANK) @echo ### Creating $@ $(AR) -r $@ $(MODULES_|>EXPAND_LIBRARY_NAME<|:%.o=$(BLD)/%.o) |>END_PRECOMP_LIBRARIES<|"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/use-rtwmakecfg-m-api-to-customize-generated-makefiles.html",
        "images": []
    },
    {
        "title": "Code Regeneration in Accelerated Models",
        "introduction": "Changing the structure of your model causes rapid accelerator mode to regenerate the standalone executable, and for the accelerator mode to regenerate the target code and update (overwrite) the existing MEX-file. Changing the value of a tunable parameter does not trigger a rebuild.",
        "chunks": [
            {
                "heading": "Determine Whether Change Requires Rebuild",
                "content": "The accelerator and rapid accelerator modes use a checksum to determine if the model has changed, indicating that the code should be regenerated. The checksum is an array of four integers computed using an MD5 checksum algorithm based on attributes of the model and the blocks it contains.\n\nUse the Simulink.BlockDiagram.getChecksum function to obtain the checksum for your model. For example:cs1 = Simulink.BlockDiagram.getChecksum('myModel'); Obtain a second checksum after you have altered your model. The code regenerates if the new checksum does not match the previous checksum.Use the information in the checksum to determine why the simulation target rebuilt.\n\nFor a detailed explanation of this procedure, see Determine Why Simulink Accelerator Is Regenerating Code."
            },
            {
                "heading": "Parameter Tuning in Rapid Accelerator Mode",
                "content": "In model rebuilds, rapid accelerator mode handles model configuration parameters and runtime parameters differently from other parameters."
            },
            {
                "heading": "Tune Model Configuration Parameters",
                "content": "To tune model configuration parameter values, you can:\n\nSpecify the parameter value on the Simulink.SimulationInput object that configures the simulation by using the setModelParameter function.Programmatically change the configuration parameter value in the model using the set_param function.Change the value in the model using the Configuration Parameters dialog box. To open the Configuration Parameters dialog box, in the Simulink\u00c2\u00ae Toolstrip, on the Modeling tab, click Model Settings.\n\nYou can change some block diagram parameters during simulation without causing a rebuild, including the parameters listed in these tables.\n\nSolver ParametersAbsTolMaxConsecutiveZCsRefineConsecutiveZCsStepRelTolMaxOrderRelTolExtrapolationOrderMaxStepStartTimeInitialStepMinStepStopTimeMaxConsecutiveMinStepOutputTimes\u00c2\n\nLoading and Logging ParametersConsistencyCheckingMaxDataPointsSaveOutputDecimationMinStepSizeMsgSaveStateFinalStateNameOutputOptionSaveTimeLimitDataPointsOutputSaveNameStateSaveNameLoadExternalInputSaveFinalStateTimeSaveNameMaxConsecutiveZCsMsgSaveFormat\u00c2"
            },
            {
                "heading": "Tune Runtime Parameters",
                "content": "The technique you use to tune runtime parameters in rapid accelerator simulations can affect whether the software rebuilds the rapid accelerator executable. Because rebuilding the executable can take significant time, avoiding rebuilds due to tuning parameters improves the efficiency of your rapid accelerator simulation workflow.\n\nFirst, confirm that the parameters you want to tune are tunable and your model is set up to support tuning the desired parameters. To identify runtime parameters in your model, use the Simulink.BlockDiagram.buildRapidAcceleratorTarget. Directly tuning block parameter values in rapid accelerator simulations is not supported. When you want to tune a block parameter value in rapid accelerator simulations, define the block parameter value as a variable. Then, tune the variable value instead.\n\nTo tune runtime parameter values in your model without rebuilding the rapid accelerator executable, follow these steps:\n\nCreate a Simulink.SimulationInput object to configure the simulation.simin = Simulink.SimulationInput(mdl);Use the setModelParameter function to set the SimulationMode parameter value to \"rapid-accelerator\" and the RapidAcceleratorUpToDateCheck parameter value to \"off\".simin = setModelParameter(simin,SimulationMode=\"rapid-accelerator\"); simin = setModelParameter(simin,RapidAcceleratorUpToDateCheck=\"off\");Use the setVariable function to specify the values to use for runtime parameters in the simulation. For example, this code configures the runtime parameter named param1 with a value of 10.simin = setVariable(mdl,\"param1\",10);Run the simulation using the SimulationInput object. For example, this code runs the simulation by specifying the SimulationInput object as an input argument for the sim function.out = sim(simin);\n\nWhen you disable the rapid accelerator up-to-date check, you cannot tune parameters for the rapid accelerator simulation using the set_param function. The set_param function modifies the parameter in the model, while the SimulationInput object modifies the parameter only in the simulation. The configuration on the SimulationInput object is applied during simulation and reverts when the simulation completes.\n\nFor the rapid accelerator simulation to reflect changes you make to the model, you need to regenerate the rapid accelerator simulation target. Leaving the rapid accelerator up-to-date check enabled to tune parameter values using the set_param function can result in extra rapid accelerator target rebuilds compared to tuning parameter values using a SimulationInput object.\n\nFor more information about parameter tunability limitations, see Tunability Considerations and Limitations for Other Modeling Goals."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/code-regeneration-in-accelerated-models.html",
        "images": []
    },
    {
        "title": "Control Data Types of Signals",
        "introduction": "To control the data type of a signal in a Simulink\u00c2\u00ae model, you specify a data type for the corresponding block output. You can also introduce a new signal of a specific data type into a model in any of the following ways: Simulink blocks determine the data type of their outputs by default. Many blocks allow you to override the default type and explicitly specify an output data type, using a block parameter that is typically named Output data type. For example, the Output data type parameter appears on the Signal Attributes pane of the Constant block dialog box. See the following topics for more information: Simulink.AliasType | Simulink.NumericType | Simulink.Bus",
        "chunks": [
            {
                "heading": "Entering Valid Data Type Values",
                "content": "In general, you can specify the output data type as any of the following:\n\nA rule that inherits a data type (see Data Type Inheritance Rules)The name of a built-in data type (see Built-In Data Types)An expression that evaluates to a data type (see Data Type Expressions)\n\nValid data type values vary among blocks. You can use the drop-down menu associated with a block data type parameter to view the data types that a particular block supports. For example, the Data type drop-down menu on the Data Store Memory block dialog box lists the data types that it supports, as shown here.\n\nFor more information about the data types that a specific block supports, see the documentation for the block in the Simulink documentation."
            },
            {
                "heading": "Data Type Inheritance Rules",
                "content": "Blocks can inherit data types from a variety of sources, including signals to which they are connected and particular block parameters. You can specify the value of a data type parameter as a rule that determines how the output signal inherits its data type. To view the inheritance rules that a block supports, use the data type drop-down menu on the block dialog box. The following table lists typical rules that you can select.\n\nInheritance RuleDescriptionInherit: Inherit via back propagationSimulink automatically determines the output data type of the block during data type propagation (see Data Type Propagation). In this case, the block uses the data type of a downstream block or signal object.Inherit: Same as inputThe block uses the data type of its sole input signal for its output signal.Inherit: Same as first inputThe block uses the data type of its first input signal for its output signal.Inherit: Same as second inputThe block uses the data type of its second input signal for its output signal.Inherit: Inherit via internal ruleThe block uses an internal rule to determine its output data type. The internal rule chooses a data type that optimizes numerical accuracy, performance, and generated code size, while taking into account the properties of the embedded target hardware. It is not always possible for the software to optimize efficiency and numerical accuracy at the same time.\n\nWhen you apply inherited data types to a signal, Simulink determines the specific data type of the signal only after you update the block diagram.\n\nTo display this specific data type on the block diagram, see Port Data Types. To inspect this specific data type for multiple signals in a searchable, sortable table, use the Model Data Editor (on the Modeling tab, click Model Data Editor). The right side of the Data Type column shows the specific data type for each signal. For more information, see Model Data Editor."
            },
            {
                "heading": "Built-In Data Types",
                "content": "You can specify the value of a data type parameter as the name of a built-in data type, for example, single or boolean. To view the built-in data types that a block supports, use the data type drop-down menu on the block dialog box. See Data Types Supported by Simulink for a list of all built-in data types that are supported."
            },
            {
                "heading": "Data Type Expressions",
                "content": "You can specify the value of a data type parameter as an expression that evaluates to a numeric data type object. Simply enter the expression in the data type field on the block dialog box. In general, enter one of these expressions:\n\nfixdt CommandSpecify the value of a data type parameter as a command that invokes the fixdt function. This function allows you to create a Simulink.NumericType object that describes a fixed-point or floating-point data type.Data Type Object NameSpecify the value of a data type parameter as the name of an object that represents a data type. Simulink.NumericType, Simulink.AliasType, Simulink.ValueType, and Simulink.BusElement objects simplify the task of making model-wide changes to output data types. Simulink.AliasType objects allow you to use custom aliases for data types. Simulink.ValueType and Simulink.BusElement objects allow you to specify the data type and other parameters, such as the unit, minimum value, and maximum value."
            },
            {
                "heading": "Use the Model Data Editor for Batch Editing",
                "content": "Using the Model Data Editor, you can assign the same data type to multiple signals simultaneously. You can use this technique to design the interface of your model by configuring data types and other attributes of multiple Inport and Outport blocks at once (see Configure Data Interfaces). You can also finely control the data types of arbitrary signals in your block algorithm.\n\nFor example, the slexAircraftExample model in the Aircraft Longitudinal Flight Control example contains numerous Gain blocks. Suppose you want to specify the output data type of the three Gain blocks at the root level of the model as single. You can achieve this task as follows:\n\nIn the Model Data Editor (on the Modeling tab, click Model Data Editor), inspect the Signals tab.Next to the Filter contents box, toggle the Filter using selection button.At the top level of the model, select the signal lines that represent the outputs of the three Gain blocks (labeled Zw, Mw, and Mq). The Model Data Editor shows three rows that correspond to the three signals.In the Model Data Editor, select all three signals (rows). For example, you can press Ctrl+A or hold Shift while clicking the top and bottom rows in the Source column.For any of the three signals, click the cell in the Data Type column. From the drop-down list, select single. The Model Data Editor applies this selection to all of the selected rows.\n\nTo convert a model to a strict single precision design, see Validate a Floating-Point Embedded Model."
            },
            {
                "heading": "Share a Data Type Between Separate Algorithms, Data Paths, Models, and Bus Elements",
                "content": "In some cases, you cannot rely on data type inheritance (see Data Type Inheritance Rules) to establish equivalence between the data types of different data items (such as signal lines in parallel data paths or bus elements in a Simulink.Bus object). Instead, you can create a Simulink.NumericType or Simulink.AliasType object in a workspace or data dictionary.\n\nCreate a Simulink.NumericType object if you do not want to rename the shared data type by creating an alias. Set the IsAlias property to false (the default).\n\nThis example shows how to use a Simulink.NumericType object to share an output data type between two lookup table blocks in the same model.\n\nOpen the Model Fault-Tolerant Fuel Control System example model sldemo_fuelsys.openExample('simulink_automotive/ModelingAFaultTolerantFuelControlSystemExample') sldemo_fuelsysThe model creates Simulink.NumericType objects in the base workspace. One of the objects is named s16En15.At the command prompt, inspect the properties of s16En15.s16En15s16En15 = NumericType with properties: DataTypeMode: 'Single' IsAlias: 0 DataScope: 'Auto' HeaderFile: '' Description: ''This object represents the built-in Simulink data type single.In the model, navigate into the fuel_rate_control/airflow_calc subsystem.On the Modeling tab, click Model Data Editor. In the Model Data Editor, inspect the Signals tab.In the model, click the output signal of the Pumping Constant block. The Model Data Editor Data Type column shows that the signal data type is set to s16En15.Click the output signal of the Ramp Rate Ki block. The output data type of this block is also set to s16En15.Update the block diagram and, if necessary, expand the width of the Data Type column. The right side of the column shows that the two lookup table blocks use the data type single.At the command prompt, configure s16En15 to represent the data type double.s16En15.DataTypeMode = 'Double';Update the block diagram.The output signals of the two lookup table blocks now use the data type double. Due to data type inheritance, other signals, such as e0 and e1, acquire the same data type.\n\nAlternatively, to establish data type equivalence between algorithms or data paths in the same model, you can use blocks such as Data Type Propagation and Data Type Conversion Inherited. When you use these blocks, you do not need to create and permanently store a data type object. However, you cannot use the blocks to share a data type between signals in different models unless the models are in the same model reference hierarchy."
            },
            {
                "heading": "Reuse Custom C Data Types for Signal Data",
                "content": "In a model, you can create signals that conform to custom C data types, such as structures, that your existing C code defines. Use these signals to:\n\nReplace existing C code with a Simulink model.Integrate C code for simulation in Simulink (for example, by using the Legacy Code Tool).Prepare to generate code (Simulink Coder\u00e2\u0084\u00a2) that you can integrate with existing code.\n\nUse these techniques to match your custom data types:\n\nFor a structure type, create a Simulink.Bus object. Use the object as the data type for buses. See Specify Bus Properties with Bus Objects.For an enumeration, create an enumeration class and use it as the data type for signals. See Use Enumerated Data in Simulink Models.To match a typedef statement that represents an alias of a primitive, numeric data type, use a Simulink.AliasType object as the data type for signals. See Simulink.AliasType.\n\nTo create these classes and objects, you can use the function Simulink.importExternalCTypes.\n\nIf a MATLAB Function block or Stateflow\u00c2\u00ae chart in your model uses an imported enumeration or structure type, configure the model configuration parameters to include (#include) the type definition from your external header file. See Control Imported Bus and Enumeration Type Definitions (for a MATLAB Function block) and Access Custom Code Variables and Functions in Stateflow Charts (Stateflow) and Integrate Custom Structures in Stateflow Charts (Stateflow) (for a chart)."
            },
            {
                "heading": "Determine Data Type of Signal That Uses Inherited Setting",
                "content": "When a signal uses an inherited data type setting such as Inherit: Inherit via internal rule (the default setting for most blocks), to determine the meaningful data type that the signal uses for simulation, update the block diagram and then use one or both of these techniques:\n\nIn the Simulink Editor, on the Debug tab, select Information Overlays and navigate to the ports section. Select the port data type you want to display. The data types appear on the block diagram next to each signal. For more information, see Port Data Types.Inspect the right side of the Data Type column in the Model Data Editor (on the Modeling tab, click Model Data Editor). For more information, see Model Data Editor.\n\nUsing these techniques to inspect data types helps you to:\n\nDesign the data type strategy for a model on a high level.Debug numerical issues due to quantization and overflows.Make a model more easily understood when sharing it.\n\nFor more information, see Port Data Types."
            },
            {
                "heading": "Data Types Remain double Despite Changing Settings",
                "content": "If many of the data items (signals, parameters, and states) in your model continue to use the data type double after you configure block parameters such as Output data type, confirm that the model is not configured to override data types. See Control Data Type Override."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/control-signal-data-types.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/constant_blk_dlg.png",
            "https://in.mathworks.com/help/simulink/ug/datastorememory_dlg_datatype.gif"
        ]
    },
    {
        "title": "App Building Components",
        "introduction": "App Designer and UI figures support a large set of components for designing modern, full-featured applications. The tables below list the components that are available. All components are available programmatically. Most UI components are also available in the App Designer Component Library for you to drag and drop onto the canvas. To add components to an App Designer app that are not available in the Component Library, or that you want to add dynamically to the running app, see Add UI Components to App Designer Programmatically. When calling graphics functions in App Designer, the workflow is slightly different than you typically use at the MATLAB\u00c2\u00ae command line. For more information about how to call graphics functions in App Designer, see Display Graphics in App Designer.",
        "chunks": [
            {
                "heading": "Common Components",
                "content": "Component InformationExampleButton CheckBox ColorPicker DatePicker DropDown NumericEditField EditField Hyperlink Image Label ListBox ButtonGroup RadioButton Slider RangeSlider Spinner StateButton Table TextArea ButtonGroup ToggleButton Tree TreeNode CheckBoxTree TreeNode"
            },
            {
                "heading": "Axes",
                "content": "Axes InformationExampleUIAxes Properties Axes Properties This object can be added programmatically only. GeographicAxes Properties This object can be added programmatically only. PolarAxes Properties This object can be added programmatically only."
            },
            {
                "heading": "Containers and Figure Tools",
                "content": "Container InformationExampleGridLayout Panel TabGroup Tab Menu ContextMenu Toolbar PushTool ToggleTool"
            },
            {
                "heading": "Dialogs and Notifications",
                "content": "Dialog InformationExampleuialert This object can be added programmatically only. uiconfirm This object can be added programmatically only. uiprogressdlg This object can be added programmatically only. uisetcolor This object can be added programmatically only. uigetfile This object can be added programmatically only. uiputfile This object can be added programmatically only. uigetdir This object can be added programmatically only. uiopen This object can be added programmatically only. uisave This object can be added programmatically only."
            },
            {
                "heading": "Instrumentation",
                "content": "Component InformationExampleGauge NinetyDegreeGauge LinearGauge SemicircularGauge Knob DiscreteKnob Lamp Switch RockerSwitch ToggleSwitch"
            },
            {
                "heading": "Extensible Components",
                "content": "Component InformationExamplematlab.ui.componentcontainer.ComponentContainer Classmatlab.graphics.chartcontainer.ChartContainer Class HTML"
            },
            {
                "heading": "Toolbox Components",
                "content": "Apps created in App Designer or with the uifigure function support components in multiple additional products. To use these components, a valid license and installation of the associated product is required.\n\nAerospace Toolbox components \u00e2\u0080\u0094 For more information, see Flight Instruments (Aerospace Toolbox).Simulink\u00c2\u00ae components \u00e2\u0080\u0094 For more information, see Create Apps to Control Simulations (Simulink)."
            }
        ],
        "link": "https://in.mathworks.com/help/matlab/creating_guis/choose-components-for-your-app-designer-app.html",
        "images": [
            "https://in.mathworks.com/help/matlab/creating_guis/component_button.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_checkbox.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component-color-picker.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_datepicker.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_dropdown.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_numericfield.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_textfield.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_hyperlink.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_image.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_label.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_listbox.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_rbuttongroup.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_slider_20b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component-range-slider.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_spinner.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_statebutton.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_table_20b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_textarea.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_tbuttongroup.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_tree.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_checkboxtree.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_axes.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_regularaxes.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_geoaxes.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_polaraxes.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_gridlayout_19b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_panel.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_tabgroup.png",
            "https://in.mathworks.com/help/matlab/creating_guis/appd_menu_example.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_contextmenu.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_toolbar_pushtool_toggletool.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uialert.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uiconfirm.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_progressdlg.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_colorpicker.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uigetfile.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uiputfile.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uigetdir.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uiopen.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_uisave.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_cgauge.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_90gauge.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_lineargauge.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_ssgauge.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_knob.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_discreteknob.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_lamp.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_switch.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_rockerswitch.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_toggleswitch.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_componentcontainer.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_html_file.png"
        ]
    },
    {
        "title": "Explore Composite Interfaces",
        "introduction": "To reduce visual complexity in a model, you can group multiple signals, messages, or conserving connections into a composite interface for a block or model component. The grouped elements retain their separate identities, and you can extract them. As you create composite interfaces, consider these potential requirements:",
        "chunks": [
            {
                "heading": "Composite Interfaces",
                "content": "The different types of composite interfaces serve a variety of modeling requirements.\n\nModeling RequirementType of Composite InterfaceAppearance in ModelMore InformationFlexible interfaces and incremental changesVirtual busA virtual bus is a flexible group of named elements.A virtual bus is analogous to a bundle of wires held together by tie wraps.Group Signals or Messages into Virtual BusesDefined interfaces in code generationNonvirtual busA nonvirtual bus is a defined group of named elements.A nonvirtual bus is analogous to a structure in C code.Create Nonvirtual BusesIterative processing of multiple elementsArray of busesAn array of buses is an array of nonvirtual buses that have the same interface definition.Group Nonvirtual Buses in Arrays of BusesIterative processing of individual elementsArrayAn array is a nonscalar signal with one or more dimensions. (default) (Wide nonscalar lines information overlay enabled)Multidimensional ArraysMatrix Concatenate\n\nModels can use a combination of these interfaces.\n\nYou can identify composite interfaces by their line style after you compile a model. When you create a composite interface or open a model that contains composite interfaces, the composite interfaces have the same line style as scalar signals. To compile a model, in the Simulink\u00c2\u00ae Toolstrip, on the Modeling tab, select Update Model."
            },
            {
                "heading": "High-Level Composite Interface Selection Guidelines",
                "content": "This flow chart helps you choose among virtual buses, nonvirtual buses, arrays of buses, and arrays.\n\nThe flow chart identifies whether you have one of these specialized use cases for a composite interface:\n\nIf the interface will provide multiple signals for a subsystem to iteratively process, consider using an array of buses.If the interface will provide one signal for a subsystem to iteratively process or a composite signal for matrix or vector operations, consider using an array.If you will require the generated code to use a structure to represent the interface, consider using a nonvirtual bus.\n\nFor other use cases, consider using a virtual bus.\n\nNoteTo group function-call signals in a virtual vector, see Mux."
            },
            {
                "heading": "Modeling Requirement Considerations",
                "content": "Before implementing a composite interface based on the high-level guidelines, consider additional modeling requirements. For example, if you want to group messages, you must use a virtual bus.\n\nTo determine what composite interfaces meet your modeling requirements, see Compare Capabilities of Composite Interfaces."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/types-of-composite-interfaces.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/linestyle_virtualbus_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_nonvirtualbus_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/array_of_buses_line_style.png",
            "https://in.mathworks.com/help/simulink/ug/linestyle_scalar_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_widenonscalar_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/composite-interface-selection.png"
        ]
    },
    {
        "title": "Add App Designer App to Inverted Pendulum Model - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer.\n\nIn the MATLAB\u00c2\u00ae Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Start Target Computer and Build Real-Time Application",
                "content": "These tasks generate the real-time application that streams data to the App Designer instrument panel app.\n\nOpen the model slrt_ex_pendulum_100Hz.Build the slrt_ex_pendulum_100Hz model.\n\nIn the MATLAB\u00c2\u00ae Command Window, type:\n\nmodel = 'slrt_ex_pendulum_100Hz'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF) set_param(model, 'RTWVerbose', 'off'); evalc('slbuild(model)');"
            },
            {
                "heading": "Run App Designer Instrument Panel App",
                "content": "The App Designer instrument panel app slrt_ex_pendulumApp provides controls to start and interact with the real-time application slrt_ex_pendulum_100Hz.\n\n1. Run the app. To start the App Designer app slrt_ex_pendulumApp.mlapp and create the handle app, in the MATLAB Command Window, type:\n\napp = slrt_ex_pendulumApp;\n\n2. To connect with an available target computer, click the Connect button. The text on the button will switch to 'Disconnect' and the Load button will be enabled.\n\n3. To load the application to the target computer, click the Load button. After the application is loaded on the target computer, the Start button and Stop time edit field will be enabled.\n\n4. To set the stop time of the application, type your preferred stop time in the edit field and hit the Enter key on your keyboard.\n\n5. To start the application, click the Start button.\n\n6. To disrupt the equilibrium of the pendulum on each cart, click the Nudge Cart button. You can adjust the nudge magnitude by using the value selection next to the button, change the reference position by adjusting the value of reference position spinner, or choose a variation pattern for the reference position."
            },
            {
                "heading": "App Callback Code",
                "content": "The instrument panel app functionality is provided by callback code.\n\nComments in the callback code in the instrument panel app slrt_ex_pendulumApp.mlapp describe the callback operations and programming suggestions. To view the callback code, open slrt_ex_pendulumApp.mlapp in the App Designer, and then click the Code View tab. In the Command Window, type:\n\nedit slrt_ex_pendulumApp\n\nSpecify Block Paths for Signals\n\nTo stream data from signals in the model, see the use of connectLine functions in the setupInstrumentation(app) function in the app.\n\nupdateAnimationCallback Function\n\nFor each AcquireGroup, this function checks whether there is fresh data since the last time the callback was called. If there is data, the function updates the animation objects.\n\nSignals are placed in an AcquireGroup based on sample rate and decimation such that all signals in an AcquireGroup have the same time vector.\n\nUpdate Axes and Animation by Using Acquire Groups\n\nIn the callback code, this processing is visible as AcquireGroupData signal groups in the updateAnimationCallback function."
            },
            {
                "heading": "Close the App and Models",
                "content": "The instrument panel app handle app provides access to close the app.\n\nClose the app. In the MATLAB Command Window, type:\n\nclose(app.UIFigure)\n\nClose the open models. In the Command Window, type:\n\nbdclose (model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/add-app-des-app-to-inverted-pendulum-model.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtAddAppDesignerAppToInvertedPendulumModelExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxartwork-pendulum-mlapp-start-up.png"
        ]
    },
    {
        "title": "Test Real-Time Application in Simulink Test - MATLAB &amp; Simulink\n",
        "introduction": "Test Assessment (Simulink Test) | Test Sequence (Simulink Test)",
        "chunks": [
            {
                "heading": "Open the Model",
                "content": "To open the model, in the MATLAB\u00c2\u00ae Command Window, type:\n\nmodel = 'slrt_ex_osc_sltest'; open_system(model);\n\nThe figure shows representative output from a real-time application running on a target computer. At low frequencies, the output of the Integrator1 block settles to the same value as the output of the Signal Generator block. At high frequencies, the output of the Integrator1 block is still ringing at the end of each pulse.\n\nThe test determines the highest frequency at which the output values of the Integrator and Signal Generator blocks are within a specified criterion of each other. The test uses the model itself as a signal source and uses a Test Harness to compare the outputs of the Integrator and Signal Generator blocks."
            },
            {
                "heading": "Step 1. Create Frequency Parameter",
                "content": "Create the parameter Frequency that is tuned at the end of this example.\n\nOpen model explorer.Create a Simulink\u00c2\u00ae parameter Frequency in model workspace for model slrt_ex_osc_sltest.Mark the parameter as a model argument.Enter a default Value of 1. Change the Storage Class to be Model Default.Open the Signal Generator block parameters and change the Frequency parameter to be the new Simulink parameter Frequency."
            },
            {
                "heading": "Step 2. Create Test Harness",
                "content": "On the Simulink Apps tab, click Simulink Test.On the Test tab, click Add Test Harness. The software creates a Test Harness with the default name slrt_ex_osc_sltest_Harness1.In the Basic Properties tab, for the Input to Component under Test, select None.For the Output from Component under Test, select Outport.Select the Add separate assessment block check box.Select the Open harness after creation check box.Take the defaults in the remaining tabs.\n\n8. Click OK.\n\nThe example model slrt_ex_osc_sltest stores the Test Harness within the model. To access the Test Harness from the example model:\n\nIn Simulink Editor, on the Test tab, click Manage Test Harnesses.Click slrt_ex_osc_sltest_Harness1."
            },
            {
                "heading": "Step 3. Configure Test Harness",
                "content": "Open the Test Assessment block.To simplify the Test Assessment configuration, in the Input symbol list, delete the existing input Outport and add inputs Int1 and SigGen.Open the Block Parameters for the Test Assessment block and change the Show port labels option to FromPortIcon. This will show the input symbol names next to the port icon of the block.In slrt_ex_osc_sltest_Harness1, connect a Demux block to the signal named Out.In the Demux block dialog box, set Number of outputs to 2.Connect the top Demux block output to Test Assessment/Int1 and the bottom output to Test Assessment/SigGen."
            },
            {
                "heading": "Step 4. Configure Simulink Parameters",
                "content": "Open the Model Explorer. On the Modeling tab, pull down the Design section and click Model Explorer.Click node slrt_ex_osc_sltest_Harness1 > Model Workspace.In the toolbar, click the Add Simulink Parameter button.Add the following Simulink.Parameter object:\n\nName \u00e2\u0080\u0094 CriterionValue \u00e2\u0080\u0094 0DataType \u00e2\u0080\u0094 doubleStorage Class \u00e2\u0080\u0094 ExportedGlobal\n\n5. In a similar manner, add Simulink parameters w_open and w_close. Because these parameters are in the slrt_ex_osc_sltest_Harness1 model workspace as model parameters, you access them by name directly, without model hierarchy.\n\n6. Save the model."
            },
            {
                "heading": "Step 5. Setup Frequency Argument",
                "content": "Right click on slrt_ex_osc_sltest_Harness1/slrt_ex_osc_sltest.Select Block Parameter(Model reference).Select Instance parameters on pop out window.Mark Frequency as an argument."
            },
            {
                "heading": "Step 6. Prepare Test Assessment Steps",
                "content": "1. Open the Test Assessment block\n\n2. Add these parameters to the Parameter symbol list:\n\nCriterionw_openw_close\n\n3. To add a step, in the Step column, move the cursor to the top row, click Add step after, and type:\n\nCheckSetting\n\n4. Right-click step CheckSetting and set the When decomposition check box.\n\n5. To add a substep to CheckSetting, click Add sub-step, and type:\n\nHi when (SigGen > 0)\n\nThe when expression selects one half of the waveform.\n\n6. Right-click substep Hi when and set the When decomposition check box.\n\n7. To substep Hi when, add substep:\n\nHiCheck when ((et >= w_open) && (et <= w_close)) verify((abs(Int1) >= abs(SigGen) * (1.0 - Criterion)) && ... (abs(Int1) <= abs(SigGen) * (1.0 + Criterion)));\n\nThe when expression selects the time window for testing the acceptance criterion. The verify command tests the acceptance criterion.\n\n8. In a similar manner, to step CheckSetting, add substep:\n\nLo when (SigGen < 0)\n\n9. To substep Lo when, add substep:\n\nLoCheck when ((et >= w_open) && (et <= w_close)) verify((abs(Int1) >= abs(SigGen) * (1.0 - Criterion)) && ... (abs(Int1) <= abs(SigGen) * (1.0 + Criterion)));\n\n10. Right-click substep Lo when and set the When decomposition check box.\n\n11. To satisfy the requirements of When decomposition, remove the default Run step and insert DefaultStep substeps after steps CheckSetting, Hi when, and Lo when. When decomposition requires at least two steps at each level of nesting, and one nondecomposed step at the end of each list of steps.\n\n11. Close the Test Sequence Editor and save the model."
            },
            {
                "heading": "Step 7. Initialize Test Suite",
                "content": "Open the slrt_ex_osc_sltest_Harness1 Test Harness if not already open. Then, click on the slrt_ex_osc_sltest subsystem.On the Harness tab, click Simulink Test Manager.Select New > Test File.Name the Test File realtimetest.Right-click on the existing Test Suite and click Delete to remove the example Test File contents.Right-click the Test File and select New > Real-Time Test.In the new real-time test dialog box, enter Simulation in the Test Type field.Click Create.Rename the new Test Case to frequencysweep.Rename the new Test Suite to realtimesuite."
            },
            {
                "heading": "Step 8. Initialize System Under Test",
                "content": "In the Simulink Test Manager, select Test Case frequencysweep.Select tab System Under Test.Set Model to slrt_ex_osc_sltest.Expand the Test Harness tab, set Harness to slrt_ex_osc_sltest_Harness1.Expand the Simulation Settings Overrides tab, select the Stop Time check box.Take the defaults for the other fields."
            },
            {
                "heading": "Step 9. Initialize Parameter Overrides",
                "content": "1. In Test Manager, select tab Parameter Overrides.\n\n2. Click the Add button. A dialog box opens containing a list of parameters. If parameters are not visible, click the Refresh line at the top of the dialog box.\n\nThe refresh builds the model and uploads the model and block parameters from slrt_ex_osc_sltest_Harness1 and slrt_ex_osc_sltest.\n\n3. Open Parameter Set 1 and select the Criterion, Frequency, w_close, and w_open check boxes."
            },
            {
                "heading": "Step 10. Create Scripted Iterations",
                "content": "To configure and control iterated runs of the Test Harness, a number of constants and variables provide input.\n\nTest Harness constants include:\n\ncStartFreq = 15.0 Start frequency of parameter sweep. cStopFreq = 25.0 End frequency of parameter sweep. cFreqIncr = 1.0 Frequency increment. cWOpen = 0.90 Start of time window for evaluating criterion. cWClose = 0.99 End of time window for evaluating criterion. cCriterion = 0.025 Maximum normalized amplitude difference between Signal Generator and Integrator1 within the time window.\n\nTest Harness variables include:\n\nvfreq Frequency at each iteration. vw_open Window opens once in each half-period. vw_close Window closes once in each half-period.\n\nIn Test Manager, select tab Iterations > Scripted Iterations.In the text box, enter the following code. To resize the Scripted Iterations text box, click and drag the lower-right corner of the box.\n\n% Initialize constants cStartFreq = 15.0; cStopFreq = 25.0; cFreqIncr = 1.0; cWOpen = 0.90; cWClose = 0.99; cCriterion = 0.025; % Loop through test frequencies for vfreq = cStartFreq:cFreqIncr:cStopFreq % Create a new iteration testItr = sltest.testmanager.TestIteration(); % Calculate the time window half_period = 0.5 * (1.0/vfreq); vw_open = half_period * cWOpen; vw_close = half_period * cWClose; % Set the parameters for the iteration testItr.setVariable('Name','Frequency','Source', ... 'slrt_ex_osc_sltest','Value',vfreq); testItr.setVariable('Name','w_open','Source', ... '','Value', vw_open); testItr.setVariable('Name','w_close','Source', ... '','Value', vw_close); testItr.setVariable('Name','Criterion','Source', ... '','Value', cCriterion); % Name and add the iteration to the testcase str = sprintf('%.0f Hz', vfreq); addIteration(sltest_testCase, testItr, str); end"
            },
            {
                "heading": "Step 11. Run Test",
                "content": "Connect to your target computer. Build and download real-time application slrt_ex_osc_sltest to the target computer.In the Simulink Test Manager, click the Run button with the Test Case selected.To view test results, in the left column, click Results and Artifacts. In this case, the test failed at iteration 23 Hz.To view the failing results, open nodes 23 Hz > Verify Statements and 23 Hz > Sim Output (slrt_ex_osc_sltest)."
            },
            {
                "heading": "Step 12. Display Results",
                "content": "In the Data Inspector tab, select the Subplots button.Select a 2x1 grid configuration.In the Simulation Data Inspector top display, select the two Out check boxes and the top Test Assessment check box. This assessment corresponds to the HiCheck substep.In the bottom display, select the two Out check boxes and the bottom Test Assessment check box. This assessment corresponds to the LoCheck substep.Click the Zoom in Time button and select the range 4.00-4.1.\n\nIn the top display, the vertical red line near 4.04 followed by a horizontal green line shows that the HiCheck test failed briefly before succeeding. In the bottom display, the vertical red spike near 4.02 followed by a horizontal green line shows that the LoCheck test failed briefly before succeeding."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/test-real-time-application-in-simulink-test.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtTestRealTimeApplicationExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxslrealtime_osc_slt_waveform.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxslrealtime_osc_slt_harness_params.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxslrealtime_osc_slt_model_params.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxslrealtime_osc_slt_test_assessment.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxsltest-parameter-refresh-icon.png"
        ]
    },
    {
        "title": "Keyboard Shortcuts and Mouse Actions for Simulink Modeling",
        "introduction": "You can use keyboard shortcuts and mouse actions to model systems in Simulink\u00c2\u00ae. To open this page from a model, press Shift+? or click Keyboard Shortcuts on the navigation bar.",
        "chunks": [
            {
                "heading": "View Keyboard Shortcuts in Editor",
                "content": "When you are in any of these modes, you can view a hints panel that displays keyboard shortcuts specific to the active mode.\n\nModeDefinitionHow to Enter ModeHow to View Hints PanelKeyboard SelectionUse the arrow keys to select a different block.Select a block in your model. Press M to switch from movement mode (the default) to selection mode.The hints panel appears when you enter selection mode.MovementMove a block by dragging it with the pointer.Drag a block with the pointer.The hints panel appears when you enter movement mode.Keyboard MovementUse the arrow keys to move the selected block.When you open Simulink, you are in movement mode by default. To switch from selection mode to movement mode, press M.The hints panel appears when you use the arrow keys to move a selected block.Signal tracingTrace the signal line to the signal source or destination. See Highlight Signal Sources and Destinations for details.Click a signal in your model. Pause on the ellipsis that appears. In the action bar that expands, click either Highlight Signal to Source or Highlight Signal to Destination .The hints panel appears when you enter signal tracing mode.Pan and zoomPan to move the view over the model. Zoom to change how close the model appears.When you open Simulink, you are in pan and zoom mode by default. Press the space bar until the hints panel expands. If the hints panel is minimized, press the space bar until the ? button appears. To hide the hints panel, click the canvas.ResizeChange the size of a block.Pause on a block resize handle.The hints panel appears when you enter resize mode.\n\nTo minimize the hints panel, press ? on your keyboard. When the hints panel is minimized, only the ? button is visible.\n\nTo restore the hints panel, press ? on your keyboard.\n\nMinimizing or restoring a hints panel in one mode does not affect the hints panels of other modes. Expanded hints panels remain expanded and minimized hints panels remain minimized across MATLAB\u00c2\u00ae sessions.\n\nFor example, to see the Keyboard Selection hints panel for selection mode:\n\nSelect a block in your model. Press M. The minimized hints panel appears in the lower right of the model window.To restore the hints panel, press ? on your keyboard."
            },
            {
                "heading": "Perform File and Clipboard Actions",
                "content": "TaskShortcutsOpen modelCtrl+OCreate modelCtrl+NPrint modelCtrl+PSave all modified models in current model hierarchyCtrl+SSave current referenced modelCtrl+Shift+SClose modelCtrl+WCutCtrl+XCopyCtrl+CPasteCtrl+VUndoCtrl+ZRedoCtrl+Y, Ctrl+Shift+Z (Simulink Online\u00e2\u0084\u00a2)Find search stringCtrl+F"
            },
            {
                "heading": "Zoom and Pan",
                "content": "TaskShortcuts and ActionsFit diagram to windowSpace barFit selection to windowSpace bar + FZoom inCtrl+Plus (+) or space bar + Plus (+)Zoom outCtrl+Minus (-) or space bar + Minus (-)Zoom to 100%Ctrl+0, Alt+1, or space bar + 0Zoom with scroll wheelScroll wheelCtrl + scroll wheel when Scroll wheel controls zooming is clearedZoom in on model elementDrag the Zoom button from the palette to the element.View portion of block diagram visible in model window relative to full block diagram with miniature mapZoom or pan to part of the model.When only part of the model is visible, press the space bar until the miniature map appears.View different portion of modelClick the destination in the miniature map.PanDrag the highlighted area in the miniature map.Drag with middle button.Space bar + drag.When a scroll bar is shown, to move the scroll bar with your keyboard, press Space bar + left, right, up, or down arrow.Pan verticallyCtrl + scroll wheelPan horizontallyShift + scroll wheelPan by pageShift + space bar + left, right, up, or down arrow"
            },
            {
                "heading": "Navigate Model",
                "content": "TaskShortcuts and ActionsOpen modelDouble-click.EnterChange tabsCtrl+Shift+TabEnter selected subsystem, referenced model, or Stateflow\u00c2\u00ae chartEnterGo to parent of selected subsystem, referenced model, or Stateflow chartEscGo to last viewed component in model hierarchy navigation historyCtrl+[Go to next viewed component in model hierarchy navigation historyCtrl+]Look under block maskCtrl+UFor linked blocks, go to library of parent blockCtrl+LOpen the Model ExplorerCtrl+H"
            },
            {
                "heading": "Select and Move Model Elements",
                "content": "Selected elements have a solid blue outline. The most recently selected element has blue corner brackets in addition to the outline. To represent the cursor when you use the keyboard for selection, a blue box with dashed lines surrounds the element.\n\nBy default, the model is in movement mode. To switch to selection mode, press M.\n\nTaskShortcuts and ActionsToggle between movement and selection modeMSelect all blocks, lines, and annotationsCtrl+AClear selectionCtrl+Alt+ASelect one or more model elementsDraw a selection box around the model elements you want to select. Start the selection box on an empty spot on the canvas.Move any model element, including signal labelsDrag element.Move selected elementsDrag one of the selected elements.Drag selection box.After selecting elements with the keyboard, in selection mode, press the left, right, up, or down arrow.By default, when you move or resize a block with three or more ports, the shape of signal lines connecting to blocks with one or two ports does not change. Instead, the connected blocks move.Turn the functionality off.Hold the space bar while you move or resize a block.When you release the space bar, the functionality turns back on.Change selection to closest similar element in a directionIn selection mode, press the left, right, up, or down arrow.Move cursor to closest element in a direction, regardless of similarityIn selection mode, press Ctrl+Shift + left, right, up, or down arrow.Change selection to element at top-left of canvasCtrl+HomeOn macOS, press home.Change selection to element at bottom-right of canvasCtrl+EndOn macOS, press end.Change selection to leftmost element relative to cursorHomeOn macOS, press control+left.Change selection to rightmost element relative to cursorEndOn macOS, press control+right.Select additional adjacent elementsTo select additional adjacent elements with the keyboard, in selection mode, press Shift + left, right, up, or down arrow.To select additional adjacent elements with the pointer, press Shift while dragging a selection box around the additional elements.Select additional elements that are not adjacentTo select additional elements with the keyboard, in selection mode, press Ctrl + left, right, up, or down arrow and navigate to the element you want to select. Then, add the element to the selection by pressing Ctrl + space bar.On macOS, to add the current element to the selection, press command+shift + space bar or shift + space bar.To select additional elements with the pointer, press Shift and click.Constrain movement of model elements to vertical and horizontal directionsStart dragging the element, then press Shift."
            },
            {
                "heading": "Add and Edit Model Elements",
                "content": "TaskShortcuts and ActionsOpen or hide the Property InspectorCtrl+Shift+IOn macOS, press command+option+O.Before R2023b: On macOS, press command+shift+I.Open or hide the Component Interface ViewCtrl+Shift+V (since R2024b)Open or hide the Type EditorCtrl+Shift+P (since R2023b)Set main parameter for selected blockAlt+EnterAdd block to model at current location with the quick insert menuDouble-click the Simulink Editor canvas and start typing the block name, then select the block from the menu.Ctrl+Period (.) twice and start typing the block name, then press the down arrow to select the block from the list and press Enter to insert the block.On AZERTY keyboards, press Ctrl+Shift+Period (.) instead of Ctrl+Period (.).Choose block to connect to signal lineMove your pointer over the unconnected end of a signal line. When your pointer is over the end of the signal line, it becomes a circle. Double-click the end of the signal line. Using the quick insert menu that appears, add a block. The new block is connected to the end of the signal line that you double-clicked.For information about how to use the quick insert menu, see Add Blocks to Models Using Quick Insert Menu.Open the Library BrowserCtrl+Shift+LAdd annotation to model at current location with the quick insert menuDouble-click the Simulink Editor canvas and type the annotation content, then select the annotation option.Ctrl+Period (.) twice and type the annotation content, then press the down arrow to select the annotation option and press Enter to insert the annotation.On AZERTY keyboards, press Ctrl+Shift+Period (.) instead of Ctrl+Period (.).Copy selected model elementsDrag elements with the right mouse button.Ctrl + drag.Copy selected model elements between Simulink Editor windowsDrag elements between windows.Delete selected model elementsDelete or Backspace"
            },
            {
                "heading": "Connect Model Elements",
                "content": "TaskShortcuts and ActionsConnect blocks with signal linesClick a port. Click the blue chevron symbol that appears near a compatible port you want to connect to.Select the first block, then Ctrl + click a second block.Drag from port to port.Click a port and press Shift as you connect to the next port. Press Shift to make multiple, consecutive connections.Branch signal lineClick a port, move the cursor near the line you want to branch, and then click after you see the preview.Select a line, move the cursor toward the element you want to connect with, and then click the blue chevron symbol that appears near the port.Ctrl + drag line.Right mouse button + drag.Add ports to blocks that take multiple inputsDrag toward the port from a compatible block or signal line.Drag from the edge of the block that you want to add the port to.Click the edge of the port, and then drag.Click the edge of the port, move the cursor over the signal type \u00e2\u0080\u0094 signal, bus, or connector \u00e2\u0080\u0094 from the menu, and drag.Disconnect selected blocksPress Shift, then drag block.After selecting blocks with the keyboard, press M then Shift + left, right, up, or down arrow.Comment through selected blocksCtrl+Shift+YComment out or uncomment selected blocksCtrl+Shift+X"
            },
            {
                "heading": "Name Model Elements",
                "content": "TaskShortcuts and ActionsRename selected model elementClick or double-click the label.Select the element and press F2.On macOS, press command+return instead of F2.Name signal lineDouble-click the signal and type its name.Display name on branch of a named signal lineDouble-click the branch.Name every branch of a signal lineRight-click the signal, select Properties, and use the Signal Properties dialog box.Delete signal label and nameDelete characters in the label, or delete the name in Signal Properties dialog box.Delete signal label only Right-click the label and select Delete Label.Copy signal labelCtrl + drag the signal label.Edit port labels on subsystem blocksPoint to the port label and click the interactive cue (blue box surrounding the label).Select the port. Click the port label cue or press F2. To switch between block name and signal name when editing labels on signal ports, press Ctrl+1,2.To make successive port label edits on a subsystem block: Select a port on the block, edit the label, and press Enter. This action enables keyboard selection of ports.Use up or down arrow keys to select adjacent ports and press F2 for quick editing."
            },
            {
                "heading": "Format Block Diagram",
                "content": "TaskShortcuts and ActionsAutomatically arrange modelCtrl+Shift+AResize block, maintaining ratio of width and heightShift + drag handleResize block about the centerCtrl + drag handleRoute lines around blocksShift + drag while drawingRotate blocks clockwiseCtrl+RRotate blocks counterclockwiseCtrl+Shift+RFlip blocksCtrl+ICreate subsystem from selectionCtrl+GCreate subsystem or area from empty selectionTo create the highlighted option, which you can change by using the arrow keys or mouse:Click inside the selection box.Press Enter.Press the number key associated with an option.Change signal label fontSelect the signal line (not the label), then on the Format tab, click the Font Properties button arrow, then click Fonts for Model.Mask blockCtrl+MRefresh Model blocksCtrl+K"
            },
            {
                "heading": "Perform Generic Actions",
                "content": "TaskShortcuts and ActionsPerform generic action with the quick action search menuDouble-click the Simulink Editor canvas, select the Actions tab, and start typing the action name or description, then select the action from the list.Ctrl+Period (.) and start typing the action name or description, then press the down arrow to select the action and press Enter to perform it.On AZERTY keyboards, press Ctrl+Shift+Period (.) instead of Ctrl+Period (.).Perform context-sensitive actionBefore opening the quick action search menu, select a model element."
            },
            {
                "heading": "Simulate, Update, and Generate Code for Models",
                "content": "TaskShortcutsStart simulationCtrl+T or F5Stop simulationCtrl+Shift+TUpdate modelCtrl+DOpen Configuration Parameters dialog boxCtrl+EBuild model (for code generation)Ctrl+B"
            },
            {
                "heading": "Debug Simulations",
                "content": "Since R2023b\n\nThe keyboard shortcuts in the table are the same in the Simulink Editor, the Stateflow Editor, and the MATLAB Function Block Editor.\n\nTaskShortcutsStep overF10On macOS, press shift+command+O.Step inF11On macOS, press shift+command+I.Step outShift+F11On macOS, press shift+command+U."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/summary-of-mouse-and-keyboard-actions.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/keyboard_shortcuts_button.png",
            "https://in.mathworks.com/help/simulink/ug/highlight-signal-to-source-button.png",
            "https://in.mathworks.com/help/simulink/ug/highlight-source-to-destination-button.png",
            "https://in.mathworks.com/help/simulink/ug/question-mark-button.png",
            "https://in.mathworks.com/help/simulink/ug/question-mark-button.png",
            "https://in.mathworks.com/help/simulink/ug/keyboard-cheat-sheet-keyboard-selection.png",
            "https://in.mathworks.com/help/simulink/ug/editor_zoom_button.png",
            "https://in.mathworks.com/help/simulink/ug/keyboard_selection_cursor.png",
            "https://in.mathworks.com/help/simulink/ug/21a_porthint_symbol.png",
            "https://in.mathworks.com/help/simulink/ug/21a_porthint_symbol.png"
        ]
    },
    {
        "title": "Check model for upgradable Simulink Real-Time features",
        "introduction": "Check ID: mathworks.design.slrealtimeUpgrades Check the model for Simulink Real-Time features from a previous release that require an upgrade for compatibility with the current release.",
        "chunks": [
            {
                "heading": "Description",
                "content": "This check identifies upgradable Simulink Real-Time features and upgrades the features where possible and recommends manual upgrades when needed. Block forwarding in the slrealtimelib library and the Speedgoat I/O Blockset eases the upgrade process."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSystem Target File upgradeChange the System Target File to slrealtime.tlc.Simulink Real-Time block upgradesUpgrades blocks when possible. Identifies blocks for manual upgrade when needed.Signal UpgradesUpgrades signals for Instrument object compatibility.Simulink Real-Time configuration parameter upgradesUpgrades configuration parameters for toolchain build and real-time application options."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your Simulink Real-Time models from release R2020a and previous releases."
            },
            {
                "heading": "See Also",
                "content": "Troubleshoot Model Upgrade for R2020b Troubleshoot System Upgrade for R2020b"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug_upgrade/check-model-for-upgradable-slrt-features.html",
        "images": []
    },
    {
        "title": "Save Signal Data Using Signal Logging",
        "introduction": "You can use signal logging to capture signal data from a simulation without adding blocks to your model. When signals are marked for logging, the software displays a logging badge . This example shows you how to use signal logging to log simulation data to the workspace and the Simulation Data Inspector. To collect and use signal logging data: You can also log subsets of marked signals. One approach for testing parts of a model as you develop it is to mark a superset of signals for logging and then override signal logging settings to select different subsets of signals for logging. You can use the Signal Logging Selector or a programmatic interface. For more information, see Override Signal Logging Settings. For a summary of other approaches to capture simulation data, see Save Simulation Data.",
        "chunks": [
            {
                "heading": "Open Model",
                "content": "Open Live Script\n\nThis example uses a model of a damped nonlinear spring given by the equation\n\nx\u00c2\u00a8+x\u00cb\u0099+k(x-a)+(x-a)3=0,\n\nwhere:\n\na = 3 m is the resting length of the spring.k = 1 N/m is the spring constant.\n\nThe model does not contain any Outport blocks and has no signals marked for logging. This example shows how to turn on signal logging and specify signal logging names."
            },
            {
                "heading": "Enable Signal Logging for Model",
                "content": "By default, signal logging is enabled. With signal logging enabled, the software logs data during simulation for signals you mark for logging. You can enable or disable signal logging for a model using the Configuration Parameters dialog box. For example, check whether signal logging is enabled for the model damped_nonlin_spring.\n\nIn the Modeling pane, select Model Settings.In the Data Import/Export tab, make sure the Signal logging parameter is selected.\n\nSignal logging is enabled, so when you mark signals in the model for logging, the software logs the signal data during simulation. If the Signal logging parameter is not selected, the software does not log signals that are marked for signal logging.\n\nYou can also use the set_param function to enable or disable signal logging for a model programmatically.\n\nset_param(\"damped_nonlin_spring\",'SignalLogging','on')"
            },
            {
                "heading": "Mark Signals for Logging",
                "content": "To analyze the damped nonlinear spring dynamics, mark signals for logging. The signal coming from the Integrator block named Integrator1 represents the position. The signal coming from the Integrator block named Integrator represents the velocity. To log signal data for the position and velocity of the spring, mark the signals for logging:\n\nSelect the signals in the model.On the Simulation tab, click Log Signals.\n\nA logging badge indicates that the signals are marked for signal logging.\n\nAlternatively, you can mark signals for logging programmatically using the Simulink.sdi.markSignalForStreaming function.\n\nSimulink.sdi.markSignalForStreaming('damped_nonlin_spring/Integrator',1,'on') Simulink.sdi.markSignalForStreaming('damped_nonlin_spring/Integrator1',1,'on')\n\nYou can use the Model Data Editor to simplify the process of marking signals for signal logging throughout a model hierarchy. The Model Data Editor displays a flat list of signals in your model that you can sort, group, and filter."
            },
            {
                "heading": "Specify Signal Names",
                "content": "The signals in the damped_nonlin_spring model are unnamed. Naming signals that you log in a model allows you to more easily analyze the logged data. By default, the software uses the signal name in the workspace and the Simulation Data inspector. If the signal does not have a name, the software uses a blank name when the data is logged to the workspace. The Simulation Data Inspector identifies unnamed signals by their block path and port number.\n\nFor example, to make the logged data easier to analyze, you can name the signals representing position and velocity interactively.\n\nDouble-click the signal output from the block named Integrator1. Then, type position.Double-click the signal output from the block named Integrator. Then, type velocity.\n\nAlternatively, you can specify signal names programmatically.\n\nGet the port handle for the signal representing the position and the signal representing velocity.posph = get_param('damped_nonlin_spring/Integrator1','PortHandles'); velph = get_param('damped_nonlin_spring/Integrator','PortHandles');Use the get_param function to get the handle of the line connected to each port.poslh = get_param(posph.Outport,'Line'); vellh = get_param(velph.Outport,'Line');Use the set_param function to set the signal names.set_param(poslh,'Name','position') set_param(vellh,'Name','velocity')\n\nYou can also specify a signal logging name that is different than the signal name used in the model. Specifying a signal-level logging name can be useful for signals that you want to remain unnamed in the model or that share a duplicate name with another signal in the model hierarchy. To set a custom signal logging name, you can use the Signal Properties dialog box, the Instrumentation Properties dialog box, or the Model Explorer."
            },
            {
                "heading": "Simulate Model and View Data",
                "content": "Because signal logging logs data to the Simulation Data Inspector, you can easily visualize simulation data. To view the logged position and velocity data in the Simulation Data Inspector:\n\nSimulate the model.On the Simulation tab, under Review Results, click Data Inspector. In the Simulation Data Inspector, select the position and velocity signals to add the signal data to the plot area.\n\nInitially, the spring is compressed. When released, the spring oscillates. Eventually, because the system is damped, the spring comes to rest at its resting spring length of 3 m.\n\nFor more information about viewing logged signal data in the Simulation Data Inspector, see Inspect Simulation Data and Create Plots Using the Simulation Data Inspector."
            },
            {
                "heading": "Access Signal Logging Data Programmatically",
                "content": "You can also analyze the logged workspace data using MATLAB\u00c2\u00ae. By default, all logged simulation data is returned as a single Simulink.SimulationOutput object in a variable named out.\n\nout\n\nout = Simulink.SimulationOutput: logsout: [1x1 Simulink.SimulationData.Dataset] tout: [59x1 double] SimulationMetadata: [1x1 Simulink.SimulationMetadata] ErrorMessage: [0x0 char]\n\nSignal logging data is grouped in a Simulink.SimulationData.Dataset object with the default name of logsout. When simulation results are returned as a single Simulink.SimulationOutput object, you can access the signal logging data using a dot.\n\nout.logsout\n\nans = Simulink.SimulationData.Dataset 'logsout' with 2 elements Name BlockPath ________ ________________________________ 1 [1x1 Signal] velocity damped_nonlin_spring/Integrator 2 [1x1 Signal] position damped_nonlin_spring/Integrator1 - Use braces { } to access, modify, or add elements using index.\n\nWhen you log data to the workspace and return a single simulation output, the Simulink.SimulationOutput object contains a property for each logging type. For example, when you log data using signal logging and use the default workspace variable name for the Dataset object, the Simulink.SimulationOutput object has the property logsout that contains the logged signal data. You can use the Configuration Parameters dialog box to enable or disable the Single simulation output parameter. For an example, see Access Data in Simulink.SimulationOutput Object.\n\nEach signal logged using signal logging is stored as an element within the Dataset object. To change the workspace variable name of the signal logging Dataset object, you can use the text box next to the Signal logging parameter in the Configuration Parameters dialog box."
            },
            {
                "heading": "Model Settings",
                "content": "\u2022 Signal logging | Single simulation output"
            },
            {
                "heading": "Objects",
                "content": "\u2022 Simulink.SimulationData.Dataset | Simulink.SimulationOutput"
            },
            {
                "heading": "Tools",
                "content": "\u2022 Instrumentation Properties | Signal Properties | Simulation Data Inspector\n\n\u2022 Save Simulation Data\n\u2022 Visualize and Access Signal Logging Data\n\u2022 Log Signals in For-Each Subsystems\n\u2022 Specify Signal Values to Log"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/exporting-signal-data-using-signal-logging.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/logging_badge.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ExportDataUsingSignalLoggingExample_01.png",
            "https://in.mathworks.com/help/simulink/ug/logging_badge.png",
            "https://in.mathworks.com/help/simulink/ug/signal-logging-sdi.png"
        ]
    },
    {
        "title": "Build Integrated Code Within the Simulink Environment",
        "introduction": "",
        "chunks": [
            {
                "heading": "Workflow",
                "content": "To build executable programs that integrate generated code and external C or C++ code, iterate through the tasks in this table.\n\nTaskActionMore Information1Choose a build approach.Approaches for Building Code Generated from Simulink Models (Embedded Coder)For an example, see Build Process Workflow for Real-Time Systems (Embedded Coder).2Configure build process support for your external code.Configure Parameters for Integrated Code Build Process (Embedded Coder)3If you integrated your external code through S-Functions, configure S-Function build support for your external code. Build Support for S-Functions (Embedded Coder) Use makecfg to Customize Generated Makefiles for S-Functions (Embedded Coder) For example, see Call Reusable Hardware-Independent External Code for Simulation and Code Generation (Embedded Coder).4Configure build process to find the external code source, library, and header files.Manage Build Process File Dependencies (Embedded Coder)Control Library Location and Naming During Build (Embedded Coder)5Set up custom build processing required for your external code integration.For the build process customization workflow, see Customize Post-Code-Generation Build Processing (Embedded Coder).To automate applying build customizations to a toolchain approach build, see Customize Build Process with sl_customization.m (Embedded Coder).To automate applying build customizations to a template makefile approach build, see Customize Build Process with STF_make_rtw_hook File (Embedded Coder)."
            },
            {
                "heading": "Configure Parameters for Integrated Code Build Process",
                "content": "The table provides a guide to model configuration parameters on Code Generation > Custom Code pane of the Model Configuration Parameters dialog box that support the build process for external code integration. For information about folders for your external code, see Manage Build Process Folders (Embedded Coder). If you choose to place your external code in the Code generation folder, see Preserve External Code Files in Build Folder (Embedded Coder).\n\nToSelectAdd include folders, which contain header files, to the build processCode information > Include directories, and enter the absolute or relative paths to the folders.If you specify relative paths, the paths must be relative to the folder containing your model files, not relative to the build folder. The order in which you specify the folders is the order in which they are searched for header, source, and library files.Add source files to be compiled and linkedCode information > Source files, and enter the full paths or just the file names for the files.Enter just the file name if the file is in the current MATLAB\u00c2\u00ae folder or in one of the include folders. For each additional source that you specify, the build process expands a generic rule in the template makefile for the folder in which the source file is located.\u00c2 For example, if a source file is located in folder inc, the build process adds a rule similar to the following: %.obj: buildir\\inc\\%.c \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 \u00c2 $(CC) -c -Fo$(@F) $(CFLAGS) $< The build process adds the rules in the order that you list the source files.Add libraries to be linkedCode information > Libraries, and enter the full paths or just the file names for the libraries.Enter just the file name if the library is located in the current MATLAB folder or in one of the include folders.Use the same custom code settings as those specified for simulation of MATLAB Function blocks, Stateflow\u00c2\u00ae charts, and Truth Table blocksUse the same custom code settings as Simulation TargetThis parameter refers to the Simulation Target pane in the Configuration Parameters dialog box.Enable a library model to use custom code settings unique from the parent model to which the library is linkedUse local custom code settings (do not inherit from main model)This parameter is available only for library models that contain MATLAB Function blocks, Stateflow charts, or Truth Table blocks."
            },
            {
                "heading": "Preserve External Code Files in Build Folder",
                "content": "By default, the build process deletes foreign source files. You can preserve foreign source files by following these guidelines.\n\nIf you put a .c/.cpp or .h source file in a build folder, and you want to prevent the code generator from deleting it during the TLC code generation process, insert the text target specific file in the first line of the .c/.cpp or .h file. For example:\n\n/* COMPANY-NAME target specific file * * This file is created for use with the * COMPANY-NAME target. * It is used for ... */ ...\n\nMake sure that you spell the text \u00e2\u0080\u009ctarget specific file\u00e2\u0080\u009d as shown in the preceding example, and that the text is in the first line of the source file. Other text can appear before or after this text.\n\nFlagging user files in this manner prevents postprocessing these files to indent them with generated source files. Auto-indenting occurred in previous releases to build folder files with names having the pattern model_*.c/.cpp (where * was text). The indenting is harmless, but can cause differences detected by source control software that can potentially trigger unnecessary updates."
            },
            {
                "heading": "Build Support for S-Functions",
                "content": "User-written S-Function blocks provide a powerful way to incorporate external code into the Simulink\u00c2\u00ae development environment. In most cases, you use S-functions to integrate existing external code with generated code. Several approaches to writing S-functions are available:\n\nWrite Noninlined S-FunctionWrite Wrapper S-Function and TLC FilesWrite Fully Inlined S-FunctionsWrite Fully Inlined S-Functions with mdlRTW RoutineS-Functions for Code ReuseS-Functions for Multirate Multitasking Environments\n\nS-functions also provide the most flexible and capable way of including build information for legacy and custom code files in the build process.\n\nThere are different ways of adding S-functions to the build process."
            },
            {
                "heading": "Implicit Build Support",
                "content": "When building models with S-functions, the build process adds rules, include paths, and source file names to the generated makefile. The source files (.h, .c, and .cpp) for the S-function must be in the same folder as the S-function MEX-file. Whether using the toolchain approach or template makefile approach for builds, the build process propagates this information through the toolchain or template makefile.\n\nIf the file sfcnname.h exists in the same folder as the S-function MEX-file (for example, sfcnname.mexext), the folder is added to the include path.If the file sfcnname.c or sfcnname.cpp exists in the same folder as the S-function MEX-file, the build process adds a makefile rule for compiling files from that folder. When an S-function is not inlined with a TLC file, the build process must compile the S-function source file. To determine the name of the source file to add to the list of files to compile, the build process searches for sfcnname.cpp on the MATLAB path. If the source file is found, the build process adds the source file name to the makefile. If sfcnname.cpp is not found on the path, the build process adds the file name sfcnname.c to the makefile, whether or not it is on the MATLAB path. NoteFor the Simulink engine to find the MEX-file for simulation and code generation, it must exist on the MATLAB path or exist in our current MATLAB working folder."
            },
            {
                "heading": "Specify Additional Source Files for an S-Function",
                "content": "If your S-function has additional source file dependencies, you must add the names of the additional modules to the build process. Specify the file names:\n\nIn the S-function modules field in the S-Function block parameter dialog boxWith the SFunctionModules parameter in a call to the set_param function\n\nFor example, suppose you build your S-function with multiple modules.\n\nmex sfun_main.c sfun_module1.c sfun_module2.c\n\nYou can then add the modules to the build process by doing one of the following:\n\nIn the S-function block dialog box, specify sfun_main, sfun_module1, and sfun_module2 in the S-function modules field. At the MATLAB command prompt, enter:set_param(sfun_block,'SFunctionModules','sfun_module1 sfun_module2')Alternatively, you can define a variable to represent the parameter value. modules = 'sfun_module1 sfun_module2' set_param(sfun_block,'SFunctionModules', modules)\n\nThe S-function modules field and SFunctionModules parameter do not support complete source file path specifications. To use the parameter, the code generator must find the additional source files when executing the makefile. For the code generator to locate the additional files, place them in the same folder as the S-function MEX-file. You can then leverage the implicit build support described in Implicit Build Support.\n\nWhen you are ready to generate code, force the code generator to rebuild the top model, as described in Control Regeneration of Top Model Code.\n\nFor more complicated S-function file dependencies, such as specifying source files in other locations or specifying libraries or object files, use the rtwmakecfg.m API, as described in Use rtwmakecfg.m API to Customize Generated Makefiles."
            },
            {
                "heading": "Use TLC Library Functions",
                "content": "If you inline your S-function by writing a TLC file, you can add source file names to the build process by using the TLC library function LibAddToModelSources. For details, see LibAddSourceFileCustomSection(file, builtInSection, newSection).\n\nNoteThis function does not support complete source file path specifications. The function assumes that the code generator can find the additional source files when executing the makefile.\n\nAnother useful TLC library function is LibAddToCommonIncludes. Use this function in a #include statement to include S-function header files in the generated model.h header file. For details, see LibAddToCommonIncludes(incFileName).\n\nFor more complicated S-function file dependencies, such as specifying source files in other locations or specifying libraries or object files, use the rtwmakecfg.m API, as described in Use rtwmakecfg.m API to Customize Generated Makefiles."
            },
            {
                "heading": "Precompile S-Function Libraries",
                "content": "You can precompile new or updated S-function libraries (MEX-files) for a model by using the MATLAB language function rtw_precompile_libs. Using a specified model and a library build specification, this function builds and places the libraries in a precompiled library folder.\n\nBy precompiling S-function libraries, you can optimize system builds. Once your precompiled libraries exist, the build process can omit library compilation from subsequent builds. For models that use numerous libraries, the time savings for build processing can be significant.\n\nTo use rtw_precompile_libs:\n\nSet the library file suffix, including the file type extension, based on your system platform.Consider determining the type of platform, and then use the TargetLibSuffix parameter to set the library suffix accordingly. For example, when applying a suffix for a GRT target, you can set the suffix to _std.a for a UNIX\u00c2\u00ae platform and _vcx64.lib for a Windows\u00c2\u00ae platform. if isunix suffix = '_std.a'; else suffix = '_vcx64.lib'; end set_param(my_model,'TargetLibSuffix', suffix);There are a number of factors that influence the precompiled library suffix and extension. The following table provides examples for typical selections of system target file, the compiler toolchain, and other options that affect your choice of suffix and extension. For more information, examine the template make files in the matlab/rtw/c/grt folder or matlab/rtw/c/ert folder.TMF FileCOMPILER _TOOL_CHAIN ValuePrecompiler Libraries (PRECOMP_LIBRARIES)Library Suffix S-Function (EXPAND _LIBRARY _NAME Value) Library Suffix Integer- Only Code (EXPAND _LIBRARY _NAME Value)Library Suffix Optimize for Speed (EXPAND _LIBRARY _NAME Value)Library Extension (EXPAND _LIBRARY _NAME Value)ert_vcx64.tmfvcx64_rtwsfcn_vcx64_int_ert_vcx64_ert_vcx64.libert_unix.tmfunix_rtwsfcn_int_ert_ert.agrt_vcx64.tmfvcx64n/an/a_vcx64.libgrt_unix.tmfunixn/an/a_std.aSet the precompiled library folder.Use one of the following methods to set the precompiled library folder:Set the TargetPreCompLibLocation parameter, as described in Specify the Location of Precompiled Libraries.Set the makeInfo.precompile field in an rtwmakecfg.m function file. (For more information, see Use rtwmakecfg.m API to Customize Generated Makefiles.)If you set TargetPreCompLibLocation and makeInfo.precompile, the setting for TargetPreCompLibLocation takes precedence.The following command sets the precompiled library folder for model my_model to folder lib under the current working folder.set_param(my_model,'TargetPreCompLibLocation', fullfile(pwd,'lib'));NoteIf you set both the target folder for the precompiled library files and a target library file suffix, the build process detects whether any precompiled library files are missing while processing builds.Define a build specification.Set up a structure that defines a build specification. The following table describes fields that you can define in the structure. These fields are optional, except for rtwmakecfgDirs. FieldDescription rtwmakecfgDirs A cell array of character vectors that name the folders containing rtwmakecfg files for libraries to be precompiled. The function uses the Name and Location elements of makeInfo.library, as returned by rtwmakecfg, to specify the name and location of the precompiled libraries. If you set the TargetPreCompLibLocation parameter to specify the library folder, that setting overrides the makeInfo.library.Location setting.Note: The specified model must contain blocks that use precompiled libraries specified by the rtwmakecfg files because the TMF-to-makefile conversion generates the library rules only if the build process uses the libraries. libSuffix A character vector that specifies the suffix, including the file type extension, to be appended to the name of each library (for example, .a or _vc.lib). The character vector must include a period (.). You must set the suffix with either this field or the TargetLibSuffix parameter. If you specify a suffix with both mechanisms, the TargetLibSuffix setting overrides the setting of this field. intOnlyBuild A Boolean flag. When set to true, the flag indicates the libraries are to be optimized such that they are compiled from integer code only. This field applies to ERT targets only. makeOpts A character vector that specifies an option to be included in the rtwMake command line. addLibs A cell array of structures that specify libraries to be built that are not specified by an rtwmakecfg function. Each structure must be defined with two fields that are character arrays:libName \u00e2\u0080\u0094 the name of the library without a suffixlibLoc \u00e2\u0080\u0094 the location for the precompiled libraryThe target makefile (TMF) can specify other libraries and how those libraries are built. Use this field to precompile those libraries. The following commands set up build specification build_spec, which indicates that the files to be compiled are in folder src under the current working folder.build_spec = []; build_spec.rtwmakecfgDirs = {fullfile(pwd,'src')};Issue a call to rtw_precompile_libs.The call must specify the model for which you want to build the precompiled libraries and the build specification. For example:rtw_precompile_libs(my_model,build_spec);"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/build-integrated-code-within-the-simulink-environment.html#bp67s_y-2",
        "images": []
    },
    {
        "title": "Use a Queue Block to Manage Messages - MATLAB &amp; Simulink\n",
        "introduction": "Sine Wave | Send | Receive | Queue | Hit Crossing Probe | Sequence Viewer",
        "chunks": [
            {
                "heading": "Manipulate Message Transitions Using Queue Sorting Policies",
                "content": "The Queue block supports three message sorting policies:\n\nLast-in-first-out (LIFO) \u00e2\u0080\u0094 The newest message in the storage departs first.\n\nFirst-in-first-out (FIFO) \u00e2\u0080\u0094 The oldest message in the storage departs first.\n\nPriority \u00e2\u0080\u0094 Messages are sorted based on their priority. The priority queue can be used only when the Overwrite the oldest element if queue is full check box is cleared.\n\nThis example uses a simple message-based communication model that is introduced in Animate and Understand Sending and Receiving Messages. The model includes Message Flow 1 and Message Flow 2 in which messages flow from Sine Wave1 to Scope1 and Sine Wave2 to Scope2."
            },
            {
                "heading": "Model Description",
                "content": "In Message Flow 1 and Message Flow 2:\n\nThe Sample time parameter of Sine Wave1 and Sine Wave2 are set to 0.1. They are identical sine wave sources.\n\nThe Sample time parameter of Receive1 and Receive2 are set to 0.5. They are identical Receive blocks.\n\nThe capacity of the Queue1 and Queue2 are 100. Both queues have the same capacity.\n\nThe sorting policy of the Queue1 is LIFO and Queue2 is FIFO, which is displayed under the block labels. The only difference between two message flow scenarios is the queue sorting policy.\n\nThe signals among Sine Wave1, Receive1, and Receive2 are logged."
            },
            {
                "heading": "Simulate the Model and Review the Results",
                "content": "Simulate the model and observe the results in the Simulation Data Inspector.\n\nObserve the output from Sine Wave1. The output from SineWave2 is not displayed because it is identical to SineWave1. Also observe that the signal from Receive1 is the representation of the sine wave but with longer intervals between samples. However, the signal from Receive2 is the first part of the sine wave reaching to the positive peak because the sorting policy of the Queue block is set to FIFO and its capacity is large enough to store messages."
            },
            {
                "heading": "Queue Block Message Overwriting Policies",
                "content": "You can also specify the Queue block message overwriting policy when the queue is full:\n\nBy default, the Overwrite the oldest element if queue is full check box is selected. The block is set to always accept an incoming message, overwriting the oldest message in the storage. In this case, the block overwrites the oldest message, but the message departing the block is determined by the queue sorting policy.\n\nIn this example of queue behavior, messages are enumerated based on their arrival time at the FIFO and LIFO queues with capacity 8. A new message with number 9 arrives. In FIFO and LIFO cases, message 9 replaces message 1 because it is the oldest element in the queue. However, observe the change of head and tail of the queue during this process. In the FIFO queue, message 2 departs first because it is the oldest message after message 1 is replaced. In the LIFO queue, message 9 departs first because it is the last message that arrives at the storage. After the message departure, a new message 10 arrives. The queue accepts the new messages to its empty storage bin.\n\nIf the Overwrite the oldest element if queue is full check box is cleared, the icon of the Queue block changes and the block does not accept new messages when the queue is full. This is a blocking queue behavior."
            },
            {
                "heading": "Queue Block with Overwriting Policy Enabled",
                "content": "In the QueueSortingPoliciesModelSequenceViewer model, the capacities of the Queue blocks in Message Flow 1 and Message Flow 2 are changed to 15. Decreasing the capacity causes the incoming messages to overwrite the existing ones in the storage.\n\nSimulate the model and open the Sequence Viewer block. In the Sequence Viewer block, scroll up or click the Go to first event icon on the left. Observe the messages departing the block based on FIFO and LIFO policies.\n\nBoth Queue blocks have limited capacity. When their capacity is full, a new incoming message overwrites the oldest existing message in the queue. Scroll down and observe that the Sequence Viewer block displays the messages that overwrite the existing ones."
            },
            {
                "heading": "An Example of a Blocking Queue Behavior",
                "content": "Open the QueueOverWritingPolicyModel to inspect the blocking queue behavior.\n\nIn the Receive block, set the Sample time parameter to 0.5.\n\nObserve that in the Queue block:\n\nThe Overwrite the oldest element if queue is full check box is cleared. Observe the block icon change.\n\nThe Capacity parameter is set to 16.\n\nIn the Statistics tab, the Number of entities departed, d and Number of entities in block, n check boxes are selected."
            },
            {
                "heading": "Simulate the Model and Review Results",
                "content": "Simulate the model. Observe the warning displayed in the Diagnostic Viewer. Messages sent by the Send block were dropped during simulation.\n\nThe Queue block blocks the messages when the Overwrite the oldest element if queue is full check box is cleared. You can increase the capacity of the Queue block to prevent message dropping."
            },
            {
                "heading": "Use Statistics to Analyze Queue Behavior",
                "content": "When the Overwrite the oldest element if queue is full check box is cleared the Statistics tab is enabled. Use Statistics tab to enable output ports and observe the Queue block statistics. Statistics are not supported for code generation.\n\nObserve the signals labeled Number of Messages in Block and Number of Messages Departed. Up to simulation time 2, there are 16 messages in the storage, which is the queue capacity. After that, Number of Messages in Block takes values 15 and 16 because messages depart every 0.5 simulation time and a new message arrives.\n\nAt simulation time 10, a total of 21 messages departs the block."
            },
            {
                "heading": "Use Event Actions",
                "content": "You can also use Event actions, when the Overwrite the oldest element if queue is full check box is cleared. Event actions are not supported for code generation. For more information, see Events and Event Actions (SimEvents).\n\nUse Event actions to specify the behavior of the message in certain events. For instance, the Entry and the Exit actions are called just after the message entry and just before message exit. The Blocked action is called after a message is blocked.\n\nFor more information, see Connect Message Receive Interface with Simulink Functions.\n\nYou can also model more complex communication policies by using blocks from the SimEvents\u00c2\u00ae library, which requires a SimEvents\u00c2\u00ae license."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/use-a-queue-block-to-manage-messages.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/UseAQueueBlockToManageMessagesExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_fifovslifo_sdi.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_blockdialog.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_fifovslifo_example.png",
            "https://in.mathworks.com/help/examples/simulink/win64/UseAQueueBlockToManageMessagesExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_viewerfifovslifo.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_vieweroverwriting.png",
            "https://in.mathworks.com/help/examples/simulink/win64/UseAQueueBlockToManageMessagesExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxqueue_overwrite_statistics_graphic.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_fifovslifo_warning.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_entityqueue_in.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_queue_entityqueue_departed.png"
        ]
    },
    {
        "title": "Create and Run Real-Time Application from Simulink Model - MATLAB &amp; Simulink\n",
        "introduction": "Target | Mux | load",
        "chunks": [
            {
                "heading": "Open the Non-Real-Time Model",
                "content": "To open the model, in the MATLAB\u00c2\u00ae Command Window, type:\n\nmodel_nrt = 'slrt_ex_osc_nrt'; open_system(model_nrt);\n\nTo complete the tutorial, you must already know how to create, configure, and simulate such a model. As you go through the tutorial, you transform slrt_ex_osc_nrt into a Simulink Real-Time\u00e2\u0084\u00a2 model configured to build as a real-time application. You then build, download, and execute the real-time application on your target computer.\n\nThe final model is named slrt_ex_osc_rt. To open the model, in the MATLAB Command Window, type:\n\nmodel_rt = 'slrt_ex_osc_rt'; open_system(model_rt);"
            },
            {
                "heading": "Transform Simulink Model to Real-Time Application",
                "content": "Add blocks and set configuration parameters for running a Simulink model as a real-time application.\n\nTo run a Simulink model as a real-time application under Simulink Real-Time, add and configure a real-time File Log block and set configuration parameters for code generation and target execution."
            },
            {
                "heading": "Add Simulink Real-Time File Log Block",
                "content": "Simulink Real-Time supports a real-time File Log block. This tutorial uses the File Log block, which logs signal data for display in the Simulation Data Inspector after the simulation run.\n\nIn the MATLAB Command Window, type slrt_ex_osc_nrt. MATLAB loads the oscillator model and displays the Simulink block diagram.In Simulink Editor, from the Apps tab, click Simulink Real-Time.From the Real-Time tab Prepare section, click Library Browser.In the Simulink left pane, browse to and double-click the node Simulink Real-Time.From the list of I/O block categories, click node Logging.Click and drag the File Log block to the Simulink block diagram. Simulink adds a new real-time File Log block to the model.Connect the Mux output to the File Log block input.On the Simulation tab, from the Save button, click Save As. Enter a file name. For example, enter slrt_ex_osc_ucf, and then click OK. To open the unconfigured model slrt_ex_osc_ucf, in the MATLAB Command Window, type:\n\nmodel_ucf = 'slrt_ex_osc_ucf'; open_system(model_ucf);"
            },
            {
                "heading": "Set File Log Block Parameters",
                "content": "File Log block parameters define the decimation for logged signals. After the simulation run, the signals that you log by using this block are available in the Simulation Data Inspector. For this tutorial, configure a File Log block.\n\nIn the MATLAB Command Window, type slrt_ex_osc_ucf. MATLAB loads the oscillator model and displays the Simulink block diagram.Double-click the File Log block.In the Decimation text box, type 1. This value means that data is collected at each sample interval.Click OK, and then from the Simulation tab, click Save."
            },
            {
                "heading": "Set Configuration Parameters",
                "content": "The example model, slrt_ex_osc_ucf, is a non-real-time model of a damped oscillator. You enter the simulation and real-time run parameters in the Configuration Parameters dialog box. These parameters provide information to Simulink Coder\u00e2\u0084\u00a2 on how to build a real-time application from the Simulink model.\n\nAfter you open a Simulink model and start the target computer, you can enter the simulation parameters.\n\nIn the MATLAB Command Window, type slrt_ex_osc_ucf.In Simulink Editor, from the Apps tab, click Simulink Real-Time.From the Real-Time tab, click Hardware Settings.In the Configuration Parameters dialog box, click the Solver node.In the Solver selection section, from the Type list, select Fixed-step.From the Solver list, select a solver. For example, select the general-purpose solver ode4 (Runge-Kutta).Under Solver details, in the Fixed-step size (fundamental sample time) box, enter the sample time for the real-time application. For example, enter 0.00025 seconds (250 microseconds). After creating the real-time application, you can change this value. If you find that a value overloads the CPU on the target computer, try a larger Fixed-step size value, such as 0.0002 seconds. The sample times of the model blocks can be multiples only of Fixed-step size. If you enter 'auto' in Fixed-step size, the fundamental sample time is calculated from the sample times of the model blocks.Click OK.From the Apps tab, select Simulink Real-Time. This selection configures the system target file and other model settings for Simulink Real-Time.In the Simulation tab, from the Save button, click Save As.Enter a file name. For example, enter slrt_ex_osc_rt."
            },
            {
                "heading": "Start Target Computer and Display Status Monitor",
                "content": "Boot the RTOS on the target computer and display the status monitor.\n\nStarting the target computer boots the RTOS. The target computer waits for the Simulink Real-Time software to download and start a real-time application from the development computer or to start a real-time application that was previously downloaded.\n\nAfter you have configured the Simulink Real-Time product by using the Simulink Real-Time Explorer, you can start the target computer and connect the development computer to the target computer. Before building the real-time application, you start the target computer. After the build process is complete, you download the real-time application to the target computer.\n\nThe status monitor application on the target computer displays status of the real-time application and other target computer status information. The target computer display supports multiple sessions. You can choose to display the status monitor (default, session 1) or display the target computer command line interface (session 2). To display the target computer status monitor:\n\nStart the target computer.The target computer displays session 1 (default) and the target computer status monitor.\n\nTo view the status monitor from the development computer, you can use PuTTY to open an SSH client and start the status monitor application /usr/target/bin/statusmonitor on the target computer.\n\nFor more information, see Target Computer Status Monitor."
            },
            {
                "heading": "Close Models",
                "content": "bdclose(model_nrt); bdclose(model_rt); bdclose(model_ucf);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/gs/create-and-run-a-real-time-application.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtCreateAndRunRealTimeAppFromSimulinkModelExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtCreateAndRunRealTimeAppFromSimulinkModelExample_02.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtCreateAndRunRealTimeAppFromSimulinkModelExample_03.png"
        ]
    },
    {
        "title": "Modify Sample Times for Nonvirtual Buses",
        "introduction": "Unlike virtual buses, which can combine signals that have different sample times, all of the signals in a nonvirtual bus must have the same sample time. To group signals with different sample times in a nonvirtual bus, make the sample times of the input signals the same by inserting Rate Transition blocks. Suppose a model creates a nonvirtual bus using a Bus Creator block. To standardize the sample time of the input signals, the model uses three Rate Transition blocks before the Bus Creator block. Suppose another model converts a virtual bus to a nonvirtual bus using a root-level Outport block. To standardize the sample time of the elements of the virtual bus, the model uses a single Rate Transition block before the Outport block. Alternatively, specify the same sample time at each block that generates an element of the bus.",
        "chunks": [
            {
                "heading": "Blocks",
                "content": "\u2022 Rate Transition\n\n\u2022 Composite Interface Guidelines\n\u2022 Identify Automatic Bus Conversions\n\u2022 What Is Sample Time?\n\u2022 Specify Sample Time\n\u2022 View Sample Time Information"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/specify-bus-signal-sample-times.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/ex_large_bus_multirate_mdl.png",
            "https://in.mathworks.com/help/simulink/ug/ex_large_bus_multirate_mdl_virt.png"
        ]
    },
    {
        "title": "Troubleshoot Unsatisfactory Real-Time Performance",
        "introduction": "I want some recommended methods to improve unsatisfactory real-time application performance. Compile with GCC -ffast-math",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "Run-time performance and reduce the task execution time (TET) of a model depend on model design, Speedgoat\u00c2\u00ae target computer capacity, and target computer utilization."
            },
            {
                "heading": "Try This Workaround",
                "content": "You can improve run-time performance and reduce the task execution time (TET) of a model with these methods."
            },
            {
                "heading": "Enable Compile with GCC -ffast-math Option",
                "content": "The Compile with GCC -ffast-math option enables the GCC compiler -ffast-math option when compiling real-time application code. This option is disabled by default for Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 models.\n\nBy enabling the Compile with GCC -ffast-math option, you provide the compiler with more flexibility to optimize floating-point math at the expense of deviating from the IEEE-754 floating-point standard.\n\nFor more information about the -ffast-math option, see the Semantics of Floating-Point Math in GCC and gcc.gnu.org/wiki/FloatingPointMath/."
            },
            {
                "heading": "Run Performance Tools",
                "content": "Use these performance tools:\n\nTo profile execution of a real-time application , use the startProfiler command. To run the profiler and plot the results, use the plot function.\n\nFor more information, see Execution Profiling for Real-Time Applications."
            },
            {
                "heading": "Customize Concurrent Execution on Multicore Target Computer",
                "content": "You can improve run-time performance by configuring your model to take advantage of your multicore target computer:\n\nPartition the model into subsystems according to the physical requirements of the system that you are modeling. Set the block sample rates within each subsystem to the slowest rate that meets the physical requirements of the system. Create execution tasks and triggers, and then explicitly assign subsystem partitions to the tasks. See Partition Your Model Using Explicit Partitioning and Multicore Programming with Simulink.You can also use the Simulink Schedule Editor to partition the model. In the Simulink Editor, click the Modeling tab and select Design > Schedule Editor. For more information, see Create Partitions from a Rate-Based Model. Run the real-time application.\n\nNoteDo not use MATLAB System blocks in the top level of Simulink Real-Time models in which task execution is explicitly partitioned. These blocks generate a TLC error when building the real-time application, for example:\"Unable to find TLCBlockSID within the Block scope\""
            },
            {
                "heading": "Minimize the Model",
                "content": "You can improve run-time performance by minimizing your model to make more memory and CPU cycles available for the real-time application:\n\nOn the Solver pane, increase Fixed-step size (fundamental sample time). Executing with a short sample time can overload the CPU.Use polling mode. See Execution Modes for Real-Time Applications.Reduce the number of I/O channels in the model."
            },
            {
                "heading": "Contact Technical Support",
                "content": "For additional guidance, refer to these sources:\n\nMathWorks\u00c2\u00ae Tech Support: MathWorks Help Center websiteMATLAB\u00c2\u00ae Answers: www.mathworks.com/matlabcentral/answers/?term=Simulink+Real-TimeMATLAB Central: www.mathworks.com/matlabcentral\n\nFor Speedgoat hardware issues, contact Speedgoat Tech Support: www.speedgoat.com/knowledge-center."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-unsatisfactory-real-time-performance.html",
        "images": []
    },
    {
        "title": "Troubleshoot Long Build Times for Real-Time Application",
        "introduction": "The model build process for a Simscape\u00e2\u0084\u00a2 Multibody\u00e2\u0084\u00a2 models is slow and uses an unexpected amount of memory.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "The default QNX\u00c2\u00ae Neutrino\u00c2\u00ae compiler switches for Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 apply optimizations that lead to long build times or slow builds for some complex models, such as Simscape Multibody models."
            },
            {
                "heading": "Try This Workaround",
                "content": "To improve the real-time application build speed, change the compiler switch selections from the default selections by adding the -fdisable-rtl-sched2 switch for the C/C++ compiler:\n\nOpen your Simulink Real-Time model.In the Simulink Editor, from the Real-Time tab, select Hardware Settings.Select Code Generation > Build configuration > SpecifyClick the C Compiler options and add option -fdisable-rtl-sched2.Click the C++ Compiler options and add option -fdisable-rtl-sched2.Click Apply and OK.\n\nAfter updating the compiler options, the options appear as shown.\n\nIf you prefer to use a programmatic approach to update these compiler switches, you could use this code.\n\n% add a compiler flag '-fdisable-rtl-sched2' set_param(modelName, 'BuildConfiguration', 'Specify'); options = get_param(modelName, 'CustomToolchainOptions'); ccompiler_idx = find(strcmp(options, 'C Compiler')); cppcompiler_idx = find(strcmp(options, 'C++ Compiler')); options{ccompiler_idx+1} = ... [options{ccompiler_idx+1} ' -fdisable-rtl-sched2']; options{cppcompiler_idx+1} = ... [options{cppcompiler_idx+1} ' -fdisable-rtl-sched2']; set_param(modelName, 'CustomToolchainOptions', options);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-long-build-times-for-real-time-application.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/window-config-parameters-qnx-c-compiler.png"
        ]
    },
    {
        "title": "Execution Profiling for Real-Time Applications - MATLAB &amp; Simulink\n",
        "introduction": "schedule (Embedded Coder) | report | plot | ProfilerData | stopProfiler | startProfiler | resetProfiler | getProfilerData | getAvailableProfile | deleteProfilerData",
        "chunks": [
            {
                "heading": "Configure Real-Time Application for Function Execution Profiling",
                "content": "The model is slrt_ex_mds_and_tasks. To open this model, open the subsystem models first:\n\nslrt_ex_mds_subsystem1 slrt_ex_mds_subsystem2 slrt_ex_mds_and_tasks\n\n1. Open model slrt_ex_mds_and_tasks.\n\n2. In the top model, open the Configuration Parameters dialog box. Select Code Generation >> Verification.\n\n3. For Measure function execution times, select Coarse (reference models and subsystems only). The Measure task execution time check box is selected and locked. Or, in the MATLAB Command Window, type:\n\nset_param('slrt_ex_mds_and_tasks','CodeProfilingInstrumentation','Coarse');\n\n4. Click OK. Save model slrt_ex_mds_and_tasks in a local folder."
            },
            {
                "heading": "Generate Real-Time Application Execution Profile",
                "content": "Generate profile data for model slrt_ex_mds_and_tasks on a multicore target computer.\n\nYou must have previously configured the target computer to take advantage of multiple cores and configured the model for task and function execution profiling.\n\n1. Open, build, and download the model.\n\ntg = slrealtime; connect(tg); model = 'slrt_ex_mds_and_tasks'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); open_system('slrt_ex_mds_subsystem1'); set_param('slrt_ex_mds_subsystem1',\"SystemTargetFile\",modelSTF); open_system('slrt_ex_mds_subsystem2'); set_param('slrt_ex_mds_subsystem2',\"SystemTargetFile\",modelSTF); evalc('slbuild(model)'); load(tg,model); setStopTime(tg,20);\n\nWhen you include profiling, the Code Generation Report is generated by default. It contains links to the generated C code and include files. By clicking these links, you can examine the generated code and interpret the Code Execution Profile Report.\n\n2. Start the real-time application, then start the profiler.\n\nstartProfiler(tg); start(tg); pause(5); stopProfiler(tg); stop(tg);\n\n3. Display the profiler data.\n\nwhile 1 tmp = strcmp(tg.ProfilerStatus,'DataAvailable'); if tmp == true break end end profiler_data = getProfilerData(tg); plot(profiler_data); report(profiler_data);\n\nProcessing data on target computer ... Transferring data from target computer ... Processing data on host computer ...\n\nThe Execution Profile schedule display in the Simulation Data Inspector shows how scheduling is generated in real-time simulation. To open the schedule display in the Simulation Data Inspector after creating the executionProfile object, use the executionProfile.schedule() function.\n\nThe Code Execution Profiling Report displays model execution profile results for each task.\n\nTo display the profile data for a section of the model, in the Section column, click the Membrane button next to the task.\n\nTo display the TET data for the section in Simulation Data Inspector, click the Plot time series data button.\n\nTo view the section in Simulink Editor, click the link next to the Expand Tree button.\n\nTo view the lines of generated code corresponding to the section, click the Expand Tree button, and then click the View Source button.\n\nbdclose(model); bdclose('slrt_ex_mds_subsystem1'); bdclose('slrt_ex_mds_subsystem2');"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/execution-profiling-for-real-time-application.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtExecutionProfilingForRealTimeApplicationsExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtExecutionProfilingForRealTimeApplicationsExample_02.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtExecutionProfilingForRealTimeApplicationsExample_03.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxparam_verify.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-execution-profiler-schedule-in-sdi.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxprofile_report.png"
        ]
    },
    {
        "title": "Calibrate Parameters with Vector CANape",
        "introduction": "This example shows how to view signals and tune parameters by using Vector CANape\u00c2\u00ae. You must have already completed the steps in Prepare ASAP2 Data Description File. You also must be familiar with the Vector CANape user interface. For information about the user interface, see the vendor documentation (www.vector.com).",
        "chunks": [
            {
                "heading": "Prepare Project",
                "content": "Open model slrt_ex_osc_cal.openExample('slrt_ex_osc_cal');Build and download the real-time application slrt_ex_osc_cal.Start the real-time application by selecting REAL-TIME > RUN ON TARGET > Start Application.Disconnect the connection from MATLAB:tg = slrealtime disconnect(tg)You can now connect to third-party calibration tools.Open Vector CANape.Create a Vector CANape project with project name slrt_ex_osc_cal. Accept the default folder."
            },
            {
                "heading": "Prepare Device",
                "content": "From the extracted slrt_ex_osc_cal.a2l, create an XCP device named slrt_ex_osc_cal_slrt.Do not configure dataset management.Select your local computer Ethernet adapter as the Ethernet channel.Accept the remaining defaults.Upload data from the device."
            },
            {
                "heading": "Configure Signals and Parameters",
                "content": "Open device slrt_ex_osc_cal_slrt, and then open slrt_ex_osc_cal.a2l.Add signals DampedOsc, SignalGenerator, L_1D, and L_2D in separate display windows.To make the waveform easier to evaluate, set the time and y-axis scaling.For example, try the following settings for DampedOsc:y-axis min home value \u00e2\u0080\u0094 \u00e2\u0080\u009325y-axis max home value \u00e2\u0080\u0094 25Min home time-axis value \u00e2\u0080\u0094 0 sMax home time-axis value \u00e2\u0080\u0094 0.1 sTime duration \u00e2\u0080\u0094 0.1 sOpen the measurement list.To set the required sample time for a signal, open the measurement properties for the signal. Select the required sample time from the measurement mode list.The default sample time is the base sample time.Add a graphic control on parameter Kg."
            },
            {
                "heading": "Measure Signals and Calibrate Parameters",
                "content": "Start the Vector CANape measurement.To shorten the ring time on DampedOsc, L_1D, and L_2D, set parameter Kg to 800.As required, toggle between calibration RAM active and inactive.\n\nWhen using the Run on Target button on the Simulink Editor Real-Time tab to run the simulation, there is a time lag of a couple of seconds between the start of the real-time application on the target computer and the connect model operation on the development computer. If you are examining signals at or very close to application start, consider using the step-by-step approach to connect model and then using an SSH connection (for example, using PuTTY) start the real-time application. For more information, see Execute Real-Time Application in Simulink External Mode by Using Step-by-Step Commands and Execute Target Computer RTOS Commands at Target Computer Command Line."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/calibrate-by-using-vector-canape.html",
        "images": []
    },
    {
        "title": "Supported Targets for Multicore Programming",
        "introduction": "",
        "chunks": [
            {
                "heading": "Supported Multicore Targets",
                "content": "You can build and download models that are implicitly or explicitly partitioned for the following multicore targets using system target files:\n\nLinux\u00c2\u00ae, Windows\u00c2\u00ae, and macOS using ert.tlc and grt.tlc. Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 using slrealtime.\u00e2\u0080\u008btlc.\n\nNoteTo build and download your model, you must have Simulink Coder\u00e2\u0084\u00a2 software installed.To build and download your model to a Simulink Real-Time system, you must have Simulink Real-Time software installed. You must also have a multicore target system supported by the Simulink Real-Time product. Deploying to an embedded processor that runs Linux and VxWorks\u00c2\u00ae operating systems requires the Embedded Coder\u00c2\u00ae product."
            },
            {
                "heading": "Supported Heterogeneous Targets",
                "content": "In addition to multicore targets, Simulink also supports building and downloading partitions of an explicitly partitioned model to heterogeneous targets that contain a multicore target and one or more field-programmable gate arrays (FPGAs).\n\nSelect the heterogeneous architecture using the Target architecture option in the Concurrent Execution dialog box Concurrent Execution pane:\n\nItemDescriptionSample ArchitectureExample architecture consisting of single CPU with multiple cores and two FPGAs. You can use this architecture to model for concurrent execution.Simulink Real-TimeSimulink Real-Time target containing FPGA boards.Xilinx Zynq ZC702 evaluation kitXilinx\u00c2\u00ae Zynq\u00c2\u00ae ZC702 evaluation kit target.Xilinx Zynq ZC706 evaluation kitXilinx Zynq ZC706 evaluation kit target.Xilinx Zynq ZedboardXilinx Zynq ZedBoard\u00e2\u0084\u00a2 target.Altera Cyclone V SoC development kit Rev. CAltera\u00c2\u00ae Cyclone\u00c2\u00ae SoC Rev. C development kit target.Altera Cyclone V SoC development kit Rev. DAltera Cyclone SoC Rev. D development kit target.Arrow SoCKit development boardArrow\u00c2\u00ae SoCKit development board target.\n\nNoteBuilding HDL code and downloading it to FPGAs requires the HDL Coder\u00e2\u0084\u00a2 product. You can generate HDL code if:You have an HDL Coder licenseYou are building on Windows or Linux operating systemsYou cannot generate HDL code on Macintosh systems."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/supported-targets-for-multicore-programming.html",
        "images": []
    },
    {
        "title": "Troubleshoot Signals Not Accessible by Name",
        "introduction": "Some signal types cannot be logged or streamed in the real-time application. Gain",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "You cannot log or stream by name these types of signals in the real-time application:\n\nVirtual or bus signals (including signals from bus creator blocks and virtual blocks). For example, assume that you connect the output of a Mux block (a virtual block) to a Simulink\u00c2\u00ae Scope block. The Scope block displays the names of the Mux input signals rather than the names of the Mux output signals.Signals that Simulink optimizes away after you set the Signal storage reuse or Block reduction configuration parameters. The output of a block that was optimized away is replaced with the corresponding input signal to the block. To access these signals, make them test points.Signals of complex or multiword data types.If a block name consists only of spaces, Simulink Real-Time\u00e2\u0084\u00a2 Explorer does not display a node for signals from that block. To reference such a block:Provide an alphanumeric name for the block.Rebuild and download the model to the Speedgoat\u00c2\u00ae target computer.Reconnect the MATLAB\u00c2\u00ae session to the target computer."
            },
            {
                "heading": "Try This Workaround",
                "content": "Check these signal types are not being logged or streamed by name in the real-time application::\n\nVirtual or bus signals (including signals from bus creator blocks and virtual blocks)Signals that Simulink optimizes awaySignals of complex or multiword data typesBlocks without alphanumeric names"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signals-not-accessible-by-name.html",
        "images": []
    },
    {
        "title": "Add Build Process Dependencies",
        "introduction": "When you specify a system target file for code generation, the code generator can build a standalone executable program that can run on the development computer. To build the executable program, the code generator uses the selected compiler and the makefile generated by the toolchain or template makefile (TMF) build process approach. Part of the makefile generation process is to add source file, header file, and library file information (the dependencies) in the generated makefile for a compilation. Or, for a specific application, you can add the generated files and file dependencies through a configuration management system. The generated code for a model consists of a small set of files. (See Manage Build Process Files.) These files have dependencies on other files, which occur due to: The model or external code introduces dependencies for various reasons:",
        "chunks": [
            {
                "heading": "File Dependency Information for the Build Process",
                "content": "The code generator provides several mechanisms to input file dependency information into the build process. The mechanisms depend on whether your dependencies are block-based or are model- or system target file-based.\n\nFor block dependencies, consider using:\n\nS-functions and blocksetsAdd folders that contain S-function MEX-files that the model uses to the header include path.Create makefile rules for these folders to allow for finding source code.Specify additional source filenames with the S-Function block parameter SFunctionModules.Specify additional dependencies with the rtwmakecfg.m mechanism. See Use rtwmakecfg.m API to Customize Generated Makefiles.For more information on applying these approaches to legacy or external code integration, see Import Calls to External Code into Generated Code with Legacy Code Tool.S-Function Builder block, which provides its own UI for specifying dependency information\n\nFor model- or system target file-based dependencies, such as external header files, consider using:\n\nThe Code Generation > Custom Code pane in the Configuration Parameters dialog box. You can specify additional libraries, source files, and include folders.TLC functions LibAddToCommonIncludes() and LibAddToModelSources(). You can specify dependencies during the TLC phase. See LibAddToCommonIncludes(incFileName) and LibAddSourceFileCustomSection(file, builtInSection, newSection). The Embedded Coder\u00c2\u00ae product also provides a TLC-based customization template for generating additional source files."
            },
            {
                "heading": "Generated Makefile Dependencies",
                "content": "For toolchain approach or template makefile (TMF) approach build processes, the code generator generates a makefile. For TMFs, the generated makefile provides token expansion in which the build process expands different tokens in the makefile to include the additional dependency information. The resulting makefile contains the complete dependency information. See Customize Template Makefiles.\n\nThe generated makefile contains:\n\nNames of the source file dependenciesFolders where source files are locatedLocation of the header filesPrecompiled library dependenciesLibraries that the make utility compiles and creates\n\nA property of make utilities is that you do not have to specify the specific location for a given source C or C++ file. If a rule exists for that folder and the source filename is a prerequisite in the makefile, the make utility can find the source file and compile it. The C or C++ compiler (preprocessor) does not require absolute paths to the headers. The compiler finds header file with the name of the header file by using an #include directive and an include path. The generated C or C++ source code depends on this standard compiler capability.\n\nLibraries are created and linked against, but occlude the specific functions that the program calls.\n\nThese properties can make it difficult to determine the minimum list of file dependencies manually. You can use the makefile as a starting point to determine the dependencies in the generated code.\n\nAnother approach to determining the dependencies is using linker information, such as a linker map file, to determine the symbol dependencies. The map file provides the location of code generator and blockset source and header files to help in locating the dependencies."
            },
            {
                "heading": "Code Generator Static File Dependencies",
                "content": "Several locations in the MATLAB\u00c2\u00ae folder tree contain static file dependencies specific to the code generator:\n\nmatlabroot/rtw/c/src (open) This folder has subfolders and contains additional files must be compiled. Examples include solver functions (for continuous time support), external mode support files, C API support files, and S-function support files. Include source files in this folder into the build process with the SRC variables of the makefile.Header files in the folder matlabroot/extern/includeHeader files in the folder matlabroot/simulink/includeThese folders contain additional header file dependencies such as tmwtypes.h, simstruc_types.h, and simstruc.h.NoteFor ERT-based system target files, you can avoid several header dependencies. ERT-based system target files generate the minimum set of type definitions, macros, and so on, in the file rtwtypes.h."
            },
            {
                "heading": "Blockset Static File Dependencies",
                "content": "Blockset products with S-function code apply the rtwmakecfg.m mechanism to provide the code generator with dependency information. The rtwmakecfg.m file from the blockset contains the list of include path and source path dependencies for the blockset. Typically, blocksets create a library from the source files to which the generated model code can link. The libraries are created and identified when you use the rtwmakecfg.m mechanism.\n\nTo locate the rtwmakecfg.m files for blocksets in your MATLAB installed tree, use the following command:\n\n>> which -all rtwmakecfg.m\n\nIf the model that you are compiling uses one or more of the blocksets listed by the which command, you can determine folder and file dependency information from the respective rtwmakecfg.m file."
            },
            {
                "heading": "Folder Dependency Information for the Build Process",
                "content": "You can add #include statements to generated code. Such references can come from several sources, including TLC scripts for inlining S-functions, custom storage classes, bus objects, and data type objects. The included files consist of header files for external code or other customizations. You can specify compiler include paths with the -I compiler option. The build process uses the specified paths to search for included header files.\n\nUsage scenarios for the generated code include, but are not limited to, the following:\n\nA custom build process compiles generated code that requires an environment-specific set of #include statements. In this scenario, the build process invokes the code generator when you select model configuration parameter Generate code only. Consider using fully qualified paths, relative paths, or just the header filenames in the #include statements. Use include paths.The build process compiles the generated code.In this case, you can specify compiler include paths (-I) for the build process in several ways:Specify additional include paths on the Code Generation > Custom Code pane in the Configuration Parameters dialog box. The code generator propagates the include paths into the generated makefile.The rtwmakecfg.m mechanism allows S-functions to introduce additional include paths into the build process. The code generator propagates the include paths into the generated makefile.When building a model that uses a custom system target file and is makefile-based, you can directly add the include paths into the template makefile that the system target file uses.Use the make command to specify a USER_INCLUDES make variable that defines a folder in which the build process searches for included files. For example:make_rtw USER_INCLUDES=-Id:\\work\\feature1The build process passes the custom includes to the command-line invocation of the make utility, which adds them to the overall flags passed to the compiler."
            },
            {
                "heading": "Use #include Statements and Include Paths",
                "content": "Consider the following approaches for using #include statements and include paths with the build process to generate code that remains portable and minimizes compatibility problems with future versions.\n\nAssume that additional header files are:\n\nc:\\work\\feature1\\foo.h c:\\work\\feature2\\bar.h\n\nAn approach is to include in the #include statements only the filename, such as:#include \"foo.h\" #include \"bar.h\"Then, the include path passed to the compiler contains folders in which the headers files exist:cc -Ic:\\work\\feature1 -Ic:\\work\\feature2 ...Another approach is to use relative paths in #include statements and provide an anchor folder for these relative paths using an include path, for example:#include \"feature1\\foo.h\" #include \"feature2\\bar.h\"\n\nThen, specify the anchor folder (for example \\work) to the compiler:\n\ncc -Ic:\\work ..."
            },
            {
                "heading": "Avoid These Folder Dependencies",
                "content": "When using the build process, avoid dependencies on folders in the build process Code generation folder, such as the model_ert_rtw folder or the slprj folder. Do not use paths in #include statements that are relative to the location of the generated source file. For example, if your MATLAB code generation folder is c:\\work, the build process generates the model.c source file into a subfolder such as:\n\nc:\\work\\model_ert_rtw\\model.c\n\nThe model.c file has #include statements of the form:\n\n#include \"..\\feature1\\foo.h\" #include \"..\\feature2\\bar.h\"\n\nIt is preferable to use one of the other suggested approaches because the relative path creates a dependency on the code generator folder structure."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/add-build-process-dependencies.html",
        "images": []
    },
    {
        "title": "Specify a Target Architecture",
        "introduction": "For models configured for concurrent execution, you can choose the architecture to which you want to deploy your model. Choose from a set of predefined architectures in Simulink\u00c2\u00ae, or you can create an interface for a custom architecture. After selecting your architecture, you can use explicit partitioning to specify which tasks run on it. For more information, see Partition Your Model Using Explicit Partitioning.",
        "chunks": [
            {
                "heading": "Choose from Predefined Architectures",
                "content": "You can choose from the predefined architectures available in Simulink, or you can download support packages for different available architectures.\n\nIn the Concurrent Execution dialog box, in the Concurrent Execution pane, click Select. The concurrent execution target architecture selector appears.Select your target.PropertyDescriptionMulticoreSingle CPU with multiple cores.Sample ArchitectureSingle CPU with multiple cores and two FPGAs.Get more ...Click OK to start the Support Package Installer. From the list, select the target and follow the instructions. In the Target architecture window, clear the Preserve compatible properties check box to reset existing target property settings to their default. Alternatively, select the Preserve compatible properties check box to preserve existing target property settings.Click OK.Simulink adds the corresponding software and hardware nodes to the configuration tree hierarchy. For example, the following illustrates one software node and two hardware nodes added to the configuration tree when you select Sample architecture as the target architecture."
            },
            {
                "heading": "Define a Custom Architecture File",
                "content": "A custom architecture file is an XML file that allows you to define custom target properties for tasks and triggers. For example, you may want to define custom properties to represent threading APIs. Threading APIs are necessary to take advantage of concurrency on your target processor.\n\nThe following is an example custom architecture file:\n\n<architecture brief=\"Multicore with custom threading API\" format=\"1.1\" revision=\"1.1\" uuid=\"MulticoreCustomAPI\" name=\"MulticoreCustomAPI\"> <configurationSet> <parameter name=\"SystemTargetFile\" value=\"ert.tlc\"/> <parameter name=\"SystemTargetFile\" value=\"grt.tlc\"/> </configurationSet> <node name=\"MulticoreProcessor\" type=\"SoftwareNode\" uuid=\"MulticoreProcessor\"/> <template name=\"CustomTask\" type=\"Task\" uuid=\"CustomTask\"> <property name=\"affinity\" prompt=\"Affinity:\" value=\"1\" evaluate=\"true\"/> <property name=\"schedulingPolicy\" prompt=\"Scheduling policy:\" value=\"Rate-monotonic\"> <allowedValue>Rate-monotonic</allowedValue> <allowedValue>Round-robin</allowedValue> </property> </template> </architecture>\n\nAn architecture file must contain:\n\nThe architecture element that defines basic information used by Simulink to identify the architecture.A configurationSet element that lists the system target files for which this architecture is valid.One node element that Simulink uses to identify the multicore processing element.NoteThe architecture must contain exactly one node element that identifies a multicore processing element. You cannot create multiple nodes identifying multiple processing elements or an architecture with no multicore processing element. One or more template elements that list custom properties for tasks and triggers.The type attribute can be Task, PeriodicTrigger, or AperiodicTrigger.Each property is editable and has the default value specified in the value attribute.Each property can be a text box, check box, or combo box. A check box is one where you can set the value attribute to on or off. A combo box is one where you can optionally list allowedValue elements as part of the property.Each text box property can also optionally define an evaluate attribute. This lets you place MATLAB\u00c2\u00ae variable names as the value of the property.Assuming that you have saved the custom target architecture file in C:\\custom_arch.xml, register this file with Simulink using the Simulink.architecture.register function.\n\nFor example:\n\nSave the contents of the listed XML file in custom_arch.xml.In the MATLAB Command Window, type:Simulink.architecture.register('custom_arch.xml') In the MATLAB Command Window, type:openExample('slexMulticoreSolverExample')In the Simulink editor, open the Configuration Parameters > Solver pane and click Configure Tasks. The Concurrent Execution dialog box displays.In the Concurrent Execution pane, click Select... under Target Architecture. The Target architecture window displays.Select MulticoreCustomAPI and click OK.\n\nYour Concurrent Execution dialog box updates to contain Code Generation properties for the tasks as shown. These are the properties defined in the XML file."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/choose-a-target-architecture.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/mds_select_target_arch.png",
            "https://in.mathworks.com/help/simulink/ug/mds-select-target-sample-arch.png",
            "https://in.mathworks.com/help/simulink/ug/mds_select_custom.png",
            "https://in.mathworks.com/help/simulink/ug/mds-code-gen-custom-properties.png"
        ]
    },
    {
        "title": "Simulink Checks",
        "introduction": "",
        "chunks": [
            {
                "heading": "Simulink Check Overview",
                "content": "Use the Simulink\u00c2\u00ae Model Advisor checks to configure your model for simulation."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "By Product Overview",
                "content": "Use the By Product Model Advisor checks to configure your model The MathWorks\u00c2\u00ae product applications."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "By Task Overview",
                "content": "Use the By Task Model Advisor checks to configure your model for specific tasks."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "Model Referencing Overview",
                "content": "Use the Model Referencing Model Advisor checks to configure your model for model referencing considerations."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "Simulink Model File Integrity",
                "content": "Use the Simulink Model File Integrity Model Advisor checks to find problems with character encoding and nondefault model properties."
            },
            {
                "heading": "See Also",
                "content": "Check Model History properties"
            },
            {
                "heading": "Units Inconsistencies",
                "content": "Use the Units Inconsistencies Model Advisor checks to find inconsistencies with unit specifications."
            },
            {
                "heading": "See Also",
                "content": "Identify unit mismatches in the model Identify automatic unit conversions in the model Identify disallowed unit systems in the model Identify undefined units in the model"
            },
            {
                "heading": "Managing Library Links Overview",
                "content": "Use the Managing Library Links Model Advisor checks to find common problems with library links."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "Migrating to Simplified Initialization Mode Overview",
                "content": "Simplified initialization mode was introduced in R2008b to improve the consistency of simulation results. This mode is especially important for models that do not specify initial conditions for conditionally executed subsystem output ports. For more information, see Simplified Initialization Mode and Classic Initialization Mode.\n\nUse the Model Advisor checks in Migrating to Simplified Initialization Mode to help migrate your model to simplified initialization mode."
            },
            {
                "heading": "See Also",
                "content": "Simplified Initialization Mode Classic Initialization Mode Underspecified initialization detection Check usage of Merge blocks Check usage of Outport blocks Check usage of Discrete-Time Integrator blocks Check model settings for migration to simplified initialization mode"
            },
            {
                "heading": "Modeling Guidelines for MISRA C:2012 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with MISRA C:2012."
            },
            {
                "heading": "See Also",
                "content": "MISRA C:2012 Compliance Considerations Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Guidelines for Secure Coding (CERT C, CWE, ISO/IEC TS 17961)",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with the CERT C, CWE, ISO/IEC TS 17961 secure coding standards."
            },
            {
                "heading": "See Also",
                "content": "Secure Coding (Embedded Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Upgrading to the Current Simulink Version Overview",
                "content": "Use the Open the Upgrade Advisor check to access the Upgrade Advisor. Use the Upgrade Advisor for help with using the current release to upgrade and improve models. The Upgrade Advisor identifies cases where you can benefit by changing your model to use new features and settings in Simulink. The Advisor provides advice for transitioning to new technologies, and upgrading a model hierarchy.\n\nThe Upgrade Advisor also identifies cases when a model will not work because changes and improvements in Simulink require changes to a model.\n\nThe Upgrade Advisor offers options to perform recommended actions automatically or instructions for manual fixes.\n\nAlternatively, you can open the Upgrade Advisor in the following ways:\n\nFrom the Model Editor, in the Modeling tab, select Model Advisor > Upgrade Advisor.From the MATLAB\u00c2\u00ae command line, use the upgradeadvisor function:upgradeadvisor modelname"
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Model Upgrades"
            },
            {
                "heading": "Modeling Signals and Parameters Using Buses Overview",
                "content": "Use the Modeling Signals and Parameters Using Buses checks to find common problems with signals and parameters when using buses."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "Code Generation Efficiency Overview",
                "content": "Use the Code Generation Efficiency checks to configure your model with consideration for code generation efficiency."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "Data Transfer Efficiency Overview",
                "content": "Use the Data Transfer Efficiency checks to configure your model with consideration for data transfer efficiency."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for DO-178C/DO-331 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models from which code is generated for applications that must meet safety or mission-critical requirements.\n\nThe Model Advisor performs a checkout of the Simulink Check\u00e2\u0084\u00a2 license when you run the checks."
            },
            {
                "heading": "See Also",
                "content": "Radio Technical Commission for Aeronautics (RTCA) for information on the DO-178C Software Considerations in Airborne Systems and Equipment Certification and related standards"
            },
            {
                "heading": "Requirements Traceability Overview",
                "content": "Model Advisor checks for requirements traceability."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Model Diagnostic Settings Overview",
                "content": "Model Advisor checks for model diagnostic settings."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Simulink Overview",
                "content": "Model Advisor checks for Simulink modeling elements."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Stateflow Overview",
                "content": "Model Advisor checks for Stateflow\u00c2\u00ae modeling objects."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Library Links Overview",
                "content": "Model Advisor checks for library links."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Model Referencing Overview",
                "content": "Model Advisor checks for referenced models."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Bug Reports Overview",
                "content": "Checks to display bug reports."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks"
            },
            {
                "heading": "Simulink Coder Overview",
                "content": "Model Advisor checks for Simulink Coder\u00e2\u0084\u00a2."
            },
            {
                "heading": "See Also",
                "content": "Model Advisor Checks (Simulink Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for ISO 26262 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with ISO 26262\u00e2\u0080\u00936.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the modeling standards for ISO 26262 checks."
            },
            {
                "heading": "Tip",
                "content": "If your model uses model referencing, run the checks on all referenced models before running them on the top model."
            },
            {
                "heading": "See Also",
                "content": "International Organization for Standardization for information on ISO 26262\u00e2\u0080\u00936 Road vehicles \u00e2\u0080\u0094 Functional safety \u00e2\u0080\u0094 Part 6: Product development: Software levelISO 26262: 2018 (Embedded Coder)Modeling Guidelines for ISO 26262-6: 2018 (IEC Certification Kit)Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for IEC 61508 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with IEC 61508-3.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the modeling standards for IEC 61508 checks."
            },
            {
                "heading": "Tip",
                "content": "If your model uses model referencing, run the checks on all referenced models before running them on the top model."
            },
            {
                "heading": "See Also",
                "content": "International Electrotechnical Commission for more information on IEC 61508\u00e2\u0080\u00933 Functional safety of electrical/electronic/programmable electronic safety-related systems \u00e2\u0080\u0094 Part 3: Software requirementsIEC 61508: 2010 (Embedded Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for IEC 62304 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with IEC 62304.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the modeling standards for IEC 62304 checks."
            },
            {
                "heading": "Tip",
                "content": "If your model uses model referencing, run the checks on all referenced models before running them on the top model."
            },
            {
                "heading": "See Also",
                "content": "MATLAB and Simulink for Medical Devices for more information on IEC 62304 Medical device software - Software life cycle processesIEC 62304: 2015 (Embedded Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for EN 50128 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with the EN 50128 standard.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the modeling standards for EN 50128 checks."
            },
            {
                "heading": "Tip",
                "content": "If your model uses model referencing, run the checks on all referenced models before running them on the top model."
            },
            {
                "heading": "See Also",
                "content": "European Committee for Electrotechnical Standardization for more information on EN 50128 (Railway applications \u00e2\u0080\u0094 Software for railway control and protection systems)EN 50128 / EN 50128: 2011 (Embedded Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Modeling Standards for ISO 25119 Overview",
                "content": "These Model Advisor checks facilitate designing and troubleshooting models, subsystems, and the corresponding generated code for applications to comply with ISO 25119.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the modeling standards for ISO 25119 checks."
            },
            {
                "heading": "Tip",
                "content": "If your model uses model referencing, run the checks on all referenced models before running them on the top model."
            },
            {
                "heading": "See Also",
                "content": "ISO 25119 Standard (Embedded Coder) Run Model Advisor Checks"
            },
            {
                "heading": "Requirements Consistency Checking Overview",
                "content": "Checks consistency of requirements.\n\nThe Model Advisor performs a checkout of the Simulink Check license when you run the requirements consistency checking checks."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks Model Advisor Checks (Simulink Coder)"
            },
            {
                "heading": "S-function Checks Overview",
                "content": "Checks the S-functions in a model or a library to identify potential problems and improvements."
            },
            {
                "heading": "See Also",
                "content": "Run Quality Checks on S-Functions Using S-Function Analyzer Troubleshoot S-Function Checks"
            },
            {
                "heading": "Modeling Single-Precision Systems Overview",
                "content": "Checks for blocks that introduce double-precision operations."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Simulink Checks Model Advisor Checks (Simulink Coder)"
            },
            {
                "heading": "Identify unconnected lines, input ports, and output ports",
                "content": "Check ID: mathworks.design.UnconnectedLinesPorts\n\nCheck for unconnected lines or ports."
            },
            {
                "heading": "Description",
                "content": "This check lists unconnected lines or ports. These can have difficulty propagating signal attributes such as data type, sample time, and dimensions.\n\nNotePorts connected to ground/terminator blocks will pass this test."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionLines, input ports, or output ports are unconnected.Connect the signals. Double-click the list of unconnected items to locate failure."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "Tips",
                "content": "Use the PortConnectivity command to obtain an array of structures describing block input or output ports."
            },
            {
                "heading": "See Also",
                "content": "Common Block Properties for information on the PortConnectivity command.\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check root model Inport block specifications",
                "content": "Check ID: mathworks.design.RootInportSpec\n\nCheck that root model Inport blocks fully define dimensions, sample time, and data type."
            },
            {
                "heading": "Description",
                "content": "Using root model Inport blocks that do not fully define dimensions, sample time, or data type can lead to undesired simulation results. Simulink software back-propagates dimensions, sample times and data types from downstream blocks unless you explicitly assign them values."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionRoot-level Inport blocks have undefined attributes.Fully define the attributes of the root-level Inport blocks."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "Tips",
                "content": "The following configurations pass this check:\n\nConfiguration Parameters > Solver > Periodic sample time constraint is set to Ensure sample time independent For export-function models, inherited sample time is not flagged."
            },
            {
                "heading": "See Also",
                "content": "About Data Types in Simulink.Determine Signal Dimensions. Model Advisor Exclusion Overview (Simulink Check)Specify Sample TimePeriodic sample time constraint"
            },
            {
                "heading": "Check optimization settings",
                "content": "Check ID: mathworks.design.OptimizationSettings\n\nCheck for optimizations that can lead to non-optimal code generation and simulation."
            },
            {
                "heading": "Description",
                "content": "This check reviews the status of optimizations that can improve code efficiency and simulation time."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe specified optimizations are off.Select the following optimization check boxes on the Optimization pane in the Configuration Parameters dialog box: Remove root level I/O zero initialization (Embedded Coder) Remove internal data zero initialization (Embedded Coder) Select the following optimization check boxes on the Optimization pane in the Configuration Parameters dialog box:Inline invariant signals (Simulink Coder) (only if you have a Simulink Coder license)Select the following optimization check boxes in the Configuration Parameters dialog box: Block reduction Conditional input branch execution Implement logic signals as Boolean data (vs. double) Use memset to initialize floats and doubles to 0.0 (Simulink Coder) Remove code from floating-point to integer conversions that wraps out-of-range values (Simulink Coder) (only if you have a Simulink Coder license)Signal storage reuse (Simulink Coder) (only if you have a Simulink Coder license) Enable local block outputs (Simulink Coder) Reuse local block outputs (Simulink Coder) Eliminate superfluous local variables (Expression folding) (Simulink Coder) Select the following optimization check boxes on the Optimization pane in the Configuration Parameters dialog box:NoteModel Advisor checks these parameters only if there is a Stateflow chart in the model. Use bitsets for storing state configuration (Simulink Coder) Use bitsets for storing Boolean data (Simulink Coder) Application lifespan (days) is set as infinite. This could lead to expensive 64-bit counter usage. Choose a stop time if this is not intended.The specified diagnostics, which can increase the time it takes to simulate your model, are set to warning or error.Select none for: Solver data inconsistencyArray bounds exceededDiagnostics > Data Validity > Simulation range checking The specified Embedded Coder\u00c2\u00ae parameters are off.If you have an Embedded Coder license and you are using an ERT-based system target file: Select Single output/update function. For details, see Single output/update function (Simulink Coder).Select Ignore test point signals. For details, see Ignore test point signals (Embedded Coder).Set Pass reusable subsystem outputs as to Individual arguments. For details, see Pass reusable subsystem outputs as (Embedded Coder)."
            },
            {
                "heading": "Tips",
                "content": "If the system contains Model blocks and the referenced model is in Accelerator mode, simulating the model requires generating and compiling code.\n\ncheck"
            },
            {
                "heading": "See Also",
                "content": "Model Configuration Parameters: Code Generation Optimization (Simulink Coder)"
            },
            {
                "heading": "Check diagnostic settings ignored during accelerated model reference simulation",
                "content": "Check ID: mathworks.design.ModelRefSIMConfigCompliance\n\nChecks for referenced models for which Simulink changes configuration parameter settings during accelerated simulation."
            },
            {
                "heading": "Description",
                "content": "For models referenced in accelerator mode, Simulink ignores the settings of the following configuration parameters that you set to a value other than None.\n\nArray bounds exceededDiagnostics > Data Validity > Inf or NaN block outputDiagnostics > Data Validity > Division by singular matrixDiagnostics > Data Validity > Wrap on overflow\n\nAlso, for models referenced in accelerator mode, Simulink ignores the following Configuration Parameters > Diagnostics > Data Validity > Data Store Memory block parameters if you set them to a value other than Disable all. For details, see Data Store Diagnostics.\n\nDetect read before writeDetect write after read Detect write after write"
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionYou want to see the results of running the identified diagnostics with settings to produce warnings or errors.Simulate the model in Normal mode and resolve diagnostic warnings or errors."
            },
            {
                "heading": "Check for parameter tunability information ignored for referenced models",
                "content": "Check ID: mathworks.design.ParamTunabilityIgnored\n\nChecks if parameter tunability information is included in the Model Parameter Configuration dialog box."
            },
            {
                "heading": "Description",
                "content": "Simulink software ignores tunability information specified in the Model Parameter Configuration dialog box. This check identifies those models containing parameter tunability information that Simulink software will ignore if the model is referenced by other models."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains ignored parameter tunability information.Click the links to convert to equivalent Simulink parameter objects in the MATLAB workspace."
            },
            {
                "heading": "See Also",
                "content": "Create Tunable Calibration Parameter in the Generated Code (Simulink Coder)"
            },
            {
                "heading": "Check for implicit signal resolution",
                "content": "Check ID: mathworks.design.ImplicitSignalResolution\n\nIdentify models that attempt to resolve named signals and states to Simulink.Signal objects."
            },
            {
                "heading": "Description",
                "content": "Requiring Simulink software to resolve all named signals and states is inefficient and slows incremental code generation and model reference. This check identifies those signals and states for which you may turn off implicit signal resolution and enforce resolution."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionNot all signals and states are resolved.Turn off implicit signal resolution and enforce resolution for each signal and state that does resolve."
            },
            {
                "heading": "See Also",
                "content": "Resolve Signal Objects for Output Variables."
            },
            {
                "heading": "Check for optimal bus virtuality",
                "content": "Check ID: mathworks.design.OptBusVirtuality\n\nIdentify virtual buses that could be made nonvirtual. Making these buses nonvirtual improves generated code efficiency."
            },
            {
                "heading": "Description",
                "content": "This check identifies blocks incorporating virtual buses that cross a subsystem boundary. Changing these to nonvirtual improves generated code efficiency."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBlocks that specify a virtual bus crossing a model reference boundary.Change the highlighted bus to nonvirtual."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Signal Basics Composite Interface Guidelines Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check for Discrete-Time Integrator blocks with initial condition uncertainty",
                "content": "Check ID: mathworks.design.DiscreteTimeIntegratorInitCondition\n\nIdentify Discrete-Time Integrator blocks with state ports and initial condition ports that are fed by neither an Initial Condition nor a Constant block."
            },
            {
                "heading": "Description",
                "content": "Discrete-Time Integrator blocks with state port and initial condition ports might not be suitably initialized unless they are fed from an Initial Condition or Constant block. This is more likely to happen when Discrete-Time Integrator blocks are used to model second-order or higher-order dynamic systems."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionDiscrete-Time Integrator blocks are not initialized during the model initialization phase.Add a Constant or Initial Condition block to feed the external Initial Condition port."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "IC blockDiscrete-Time Integrator blockConstant block Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify disabled library links",
                "content": "Check ID: mathworks.design.DisabledLibLinks\n\nSearch model for disabled library links."
            },
            {
                "heading": "Description",
                "content": "Disabled library links can cause unexpected simulation results. Resolve disabled links before saving a model.\n\nNoteThis check may overlap with Check model for block upgrade issues."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionLibrary links are disabled.Click the Library Link > Resolve link option in the context menu."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "Tips",
                "content": "Use the Model Browser to find library links.To enable a broken link, right-click a block in your model to display the context menu. Select Library Link > Resolve link."
            },
            {
                "heading": "See Also",
                "content": "Restore Disabled Links\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check for large number of function arguments from virtual bus across model reference boundary",
                "content": "Check ID: mathworks.design.CheckVirtualBusAcrossModelReferenceArgs\n\nChecks virtual buses that cross model reference boundaries and flags cases where using virtual buses across a model reference boundary increases the number of function arguments significantly."
            },
            {
                "heading": "Description",
                "content": "To improve the speed of the code generation process, you can use this check to reduce the number of generated function arguments. If the check finds a model that where many arguments will be generated for a function, you can click Update Model to modify the model so that it generates fewer arguments."
            },
            {
                "heading": "Results and Recommended Action",
                "content": "Methods that generate many function arguments as the result of a virtual bus crossing model reference boundary slow down the code generation process.\n\nConditionRecommended ActionMethods are listed that generate a large number of arguments for the current the model configuration that this check can reduce by modifying the model.Click Update Model.\n\nClicking Update Model resets Inport and Outport block parameters and inserts Signal Conversion blocks, as necessary, to reduce the number of generated function arguments for the model."
            },
            {
                "heading": "See Also",
                "content": "Use Buses at Model Interfaces"
            },
            {
                "heading": "Identify parameterized library links",
                "content": "Check ID: mathworks.design.ParameterizedLibLinks\n\nSearch model for parameterized library links."
            },
            {
                "heading": "Description",
                "content": "Parameterized library links that are unintentional can result in unexpected parameter settings in your model. This can result in improper model operation."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionParameterized links are listed.Verify that the links are intended to be parameterized."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "Tips",
                "content": "Right-click a block in your model to display the context menu. Choose Link Options and click Go To Library Block to see the original block from the library.To parameterize a library link, choose Look Under Mask, from the context menu and select the parameter."
            },
            {
                "heading": "See Also",
                "content": "Restore Disabled Links\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify unresolved library links",
                "content": "Check ID: mathworks.design.UnresolvedLibLinks\n\nSearch the model for unresolved library links, where the specified library block cannot be found."
            },
            {
                "heading": "Description",
                "content": "Check for unresolved library links. Models do not simulate while there are unresolved library links."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionLibrary links are unresolved.Locate missing library block or an alternative."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Fix Unresolved Library Links\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify configurable subsystem blocks for converting to variant subsystem blocks",
                "content": "Check ID: mathworks.design.CSStoVSSConvert\n\nSearch the model to identify configurable subsystem blocks at the model or subsystem level."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended Action Configurable subsystem blocks are identified.Convert these blocks to variant subsystem blocks to avoid compatibility issues. See Convert Configurable Subsystem to Variant Subsystem."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your library models."
            },
            {
                "heading": "See Also",
                "content": "Simulink.VariantUtils.convertToVariantSubsystem"
            },
            {
                "heading": "Identify Variant Model blocks and convert those to Variant Subsystem containing Model block choices",
                "content": "Check ID: mathworks.design.ConvertMdlrefVarToVSS\n\nSearch the model to identify Variant Model blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionVariant Model blocks available in the model are listed.Convert these blocks to Variant Subsystem blocks."
            },
            {
                "heading": "See Also",
                "content": "Simulink.VariantUtils.convertToVariantSubsystem"
            },
            {
                "heading": "Identify Variant blocks using Variant objects with empty conditions",
                "content": "Check ID: mathworks.design.emptyVariantObjects\n\nSearch the model to identify the Variant blocks or library having empty Variant objects."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe Variant blocks in the model or library having empty Variant objects are listed.Use valid conditions in the variant objects."
            },
            {
                "heading": "See Also",
                "content": "Introduction to Variant Controls"
            },
            {
                "heading": "Check usage of function-call connections",
                "content": "Check ID: mathworks.design.CheckForProperFcnCallUsage\n\nCheck model diagnostic settings that apply to function-call connectivity and that might impact model execution."
            },
            {
                "heading": "Description",
                "content": "Check for connectivity diagnostic settings that might lead to non-deterministic model execution."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionConfiguration parameter Context-dependent inputs is set to Warning. This might lead to non-deterministic model execution.Set Configuration parameter Context-dependent inputs to Error."
            },
            {
                "heading": "See Also",
                "content": "Function-Call Subsystem"
            },
            {
                "heading": "Managing Data Store Memory Blocks",
                "content": "Use these checks for the Data Store Memory Blocks to configure your model for acceptable usage of Data Store Memory blocks."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Model Advisor Checks (Simulink Coder) Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "Check Data Store Memory blocks for multitasking, strong typing, and shadowing issues",
                "content": "Check ID: mathworks.design.DataStoreMemoryBlkIssue\n\nLook for modeling issues related to Data Store Memory blocks."
            },
            {
                "heading": "Description",
                "content": "Checks for multitasking data integrity, strong typing, and shadowing of data stores of higher scope."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe Duplicate data store names check is set to none or warning. Consider setting the Duplicate data store names check to error in the Configuration Parameters dialog box, on the Diagnostics > Data Validity pane.The data store variable names are not strongly typed in one of the following: Signal Attributes pane of the Block Parameters dialog for the Date Store Memory blockGlobal data store name Specify a data type other than auto by taking one of the following actions: Choose a data type other than Inherit: auto on the Signal Attributes pane of the Block Parameters dialog for the Date Store Memory block.If you are using a global data store name, then specify its data type in the Simulink.Signal object. The Multitask data store check is set to none or warning. Consider setting the Multitask data store check to error in the Configuration Parameters dialog box, on the Diagnostics > Data Validity pane."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "Local and Global Data Stores Storage Classes for Data Store Memory Blocks (Simulink Coder) Data Store MemoryData Store ReadData Store Write Duplicate data store names Multitask data store Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check if read/write diagnostics are enabled for data store blocks",
                "content": "Check ID: mathworks.design.DiagnosticDataStoreBlk\n\nFor data store blocks in the model, enable the read-and-write diagnostics order checking to detect run-time issues."
            },
            {
                "heading": "Description",
                "content": "Check for the read-and-write diagnostics order checking. By enabling the read-and-write diagnostics, you detect potential run-time issues."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe Detect read before write check is disabled.Consider enabling Detect read before write in the Configuration Parameter dialog box Diagnostics> Data Validity pane.The Detect write after read check is disabled.Consider enabling Detect write after read in the Configuration Parameter dialog box Diagnostics> Data Validity pane.The Detect write after write check is disabled.Consider enabling Detect write after write in the Configuration Parameter dialog box Diagnostics> Data Validity pane."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "Tips",
                "content": ".\n\nThe run-time diagnostics can slow simulations down considerably. Once you have verified that Simulink does not generate warnings or errors during simulation, set them to Disable all."
            },
            {
                "heading": "See Also",
                "content": "Local and Global Data Stores Data Store MemoryData Store ReadData Store Write Detect read before write Detect write after read Detect write after write Check for potential ordering issues involving data store access Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check data store block sample times for modeling errors",
                "content": "Check ID: mathworks.design.DataStoreBlkSampleTime\n\nIdentify modeling errors due to the sample times of data store blocks."
            },
            {
                "heading": "Description",
                "content": "Check data store blocks for continuous or fixed-in-minor-step sample times."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionData store blocks in your model have continuous or fixed-in-minor-step sample times.Consider making the listed blocks discrete or replacing them with either Memory or Goto and From blocks."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "Local and Global Data Stores Data Store MemoryData Store ReadData Store Write Fixed-in-Minor-Step Sample Time Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check for potential ordering issues involving data store access",
                "content": "Check ID: mathworks.design.OrderingDataStoreAccess\n\nLook for read/write issues which may cause inaccuracies in the results."
            },
            {
                "heading": "Description",
                "content": "During an Update Diagram, identify potential issues relating to read-before-write, write-after-read, and write-after-write conditions for data store blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionReading and writing (read-before-write or write-after-read condition) occur out of order.Consider restructuring your model so that the Data Store Read block executes before the Data Store Write block.Multiple writes occur within a single time step.Change the model to write data only once per time step or refer to the following Tips section."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "Tips",
                "content": "This check performs a static analysis which might not identify every instance of improper usage. Specifically, Function-Call Subsystems, Stateflow Charts, MATLAB for code generation, For Iterator Subsystems, and For Each Subsystems can cause both missed detections and false positives. For a more comprehensive check, consider enabling the following diagnostics on the Diagnostics > Data Validity pane in the Configuration Parameters dialog box: Detect read before write, Detect write after read, and Detect write after write."
            },
            {
                "heading": "See Also",
                "content": "Local and Global Data Stores Data Store MemoryData Store ReadData Store Write Detect read before write Detect write after read Detect write after write Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check structure parameter usage with bus signals",
                "content": "Check ID: mathworks.design.MismatchedBusParams\n\nIdentify blocks and Simulink.Signal objects that initialize buses by using mismatched structures."
            },
            {
                "heading": "Description",
                "content": "In a model, you can use a MATLAB structure to initialize a bus. For example, if you pass a bus through a Unit Delay block, you can set the Initial condition parameter to a structure. For basic information about initializing buses by using structures, see Specify Initial Conditions for Bus Elements.\n\nRun this check to generate efficient and readable code by matching the shape and numeric data types of initial condition structures with those of buses. Matching these characteristics avoids unnecessary explicit typecasts and replaces field-by-field structure assignments with, for example, calls to memcpy."
            },
            {
                "heading": "Partial Structures",
                "content": "This check lists blocks and Simulink.Signal objects that initialize buses by using partial structures. During the iterative process of creating a model, you can use partial structures to focus on a subset of signal elements in a bus. For a mature model, use full structures to:\n\nGenerate readable and efficient code.Support a modeling style that explicitly initializes unspecified signals. When you use partial structures, Simulink implicitly initializes unspecified signals.\n\nFor more information about full and partial structures, see Specify Initial Conditions for Bus Elements."
            },
            {
                "heading": "Data Type Mismatches",
                "content": "This check lists blocks and Simulink.Signal objects whose initial condition structures introduce data type mismatches. The fields of these structures have numeric data types that do not match the data types of the corresponding bus elements.\n\nThis check does not detect a mismatch for blocks, such as the Unit Delay block, that implicitly convert the data type of initial condition to the input signal.\n\nWhen you configure an initial condition structure to appear as a tunable global structure in the generated code, avoid unnecessary explicit typecasts by matching the data types. See Generate Tunable Initial Condition Structure for Bus (Simulink Coder)."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBlock or signal object uses partial structureConsider using the function Simulink.Bus.createMATLABStructure to create a full initial condition structure.Data types of structure fields do not match data types of corresponding signal elementsConsider defining the structure as a Simulink.Parameter object, and creating a Simulink.Bus object to use as the data type of the bus and of the parameter object. To control numeric data types, use the Simulink.BusElement objects in the bus object."
            },
            {
                "heading": "See Also",
                "content": "Specify Initial Conditions for Bus Elements Generate Tunable Initial Condition Structure for Bus (Simulink Coder) Data Stores with Signal Objects Simulink.Bus.createMATLABStructSimulink.Signal"
            },
            {
                "heading": "Check Delay, Unit Delay and Zero-Order Hold blocks for rate transition",
                "content": "Check ID: mathworks.design.ReplaceZOHDelayByRTB\n\nIdentify Delay, Unit Delay, or Zero-Order Hold blocks that are used for rate transition. Replace these blocks with actual Rate Transition blocks."
            },
            {
                "heading": "Description",
                "content": "If a model uses Delay, Unit Delay, or Zero-Order Hold blocks to provide rate transition between input and output signals, Simulink makes a hidden replacement of these blocks with built-in Rate Transition blocks. In the compiled block diagram, a yellow symbol and the letters \u00e2\u0080\u009cRT\u00e2\u0080\u009d appear in the upper-left corner of a replacement block. This replacement can affect the behavior of the model, as follows:\n\nThese blocks lose their algorithmic design properties to delay a signal or implement zero-order hold. Instead, they acquire rate transition behavior.This modeling technique works only in specific transition configurations (slow-to-fast for Delay and Unit Delay blocks, and fast-to-slow for Zero-Order Hold block). Set the block sample time to be equal to the slower rate (source for the Delay and Unit Delay blocks and destination for the Zero-Order Hold block).When the block sample time of a downstream or upstream block changes, these Delay, Unit Delay and Zero-Order Hold blocks might not perform rate transition. For example, setting the source and destination sample times equal stops rate transition. The blocks then assume their original algorithmic design properties.The block sample time shows incomplete information about sample time rates. The block code runs at two different rates to handle data transfer. However, the block sample time and sample time color show it as a single-rate block. Tools and MATLAB scripts that use sample time information base their behavior on this information.\n\nAn alternative is to replace Delay, Unit Delay, or Zero-Order Hold blocks with actual Rate Transition blocks.\n\nThe technique ensures unambiguous results in block behavior. Delay, Unit Delay, or Zero-Order Hold blocks act according to their algorithmic design to delay and hold signals respectively. Only Rate Transition blocks perform actual rate transition.Using an actual Rate Transition block for rate transition offers a configurable solution to handle data transfer if you want to specify deterministic behavior or the type of memory buffers to implement.\n\nUse this check to identify instances in your model where Delay, Unit Delay or Zero-Order Hold blocks undergo hidden replacement to provide rate transition between signals. Click Upgrade Model to replace these blocks with actual Rate Transition blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel has no instances of Delay, Unit Delay, or Zero-Order Hold blocks used for rate transition.No action required.Model has instances of Delay, Unit Delay, or Zero-Order Hold blocks used for rate transition. The check identifies these instances and allows you to upgrade the model. Click Upgrade Model to replace with actual Rate Transition blocks.Save changes to your model.\n\nIf you do not choose to replace the Delay, Unit Delay, and/or Zero-Order Hold blocks with actual Rate Transition blocks, Simulink continues to perform a hidden replacement of these blocks with built-in rate transition blocks."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Model Upgrades Rate Transition Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check for calls to slDataTypeAndScale",
                "content": "Check ID: mathworks.design.CallslDataTypeAndScale\n\nIdentify calls to the internal function slDataTypeAndScale."
            },
            {
                "heading": "Description",
                "content": "In some previous versions of Simulink, opening a model that had been saved in an earlier version triggers an automatic upgrade to code for data type handling. The automatic upgrade inserts calls to the internal function slDataTypeAndScale. Although Simulink continues to support some uses of the function, if you eliminate calls to it, you get cleaner and faster code.\n\nSimulink does not support calls to slDataTypeAndScale when:\n\nThe first argument is a Simulink.AliasType object.The first argument is a Simulink.NumericType object with property IsAlias set to true.\n\nRunning Check for calls to slDataTypeAndScale identifies calls to slDataTypeAndScale that are required or recommended for replacement. In most cases, running the check and following the recommended action removes the calls. You can ignore calls that remain. Run the check unless you are sure there are not calls to slDataTypeAndScale."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionRequired Replacement CasesManually or automatically replace calls to slDataTypeAndScale. Cases listed require you to replace calls to slDataTypeAndScale.Recommended Replacement CasesFor the listed cases, it is recommended that you manually or automatically replace calls to slDataTypeAndScale. Manual Inspection CasesInspect each listed case to determine whether it should be manually upgraded."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "Tips",
                "content": "Do not manually insert a call to slDataTypeAndScale into a model. The function was for internal use only.Running Check for calls to slDataTypeAndScale calls the Simulink function slRemoveDataTypeAndScale. Calling this function directly provides a wider range of conversion options. However, you very rarely need more conversion options."
            },
            {
                "heading": "See Also",
                "content": "For more information about upgrading data types and scales, in the MATLAB Command Window, execute the following:help slDataTypeAndScalehelp slRemoveDataTypeAndScale Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check bus signals treated as vectors",
                "content": "Check ID: mathworks.design.BusTreatedAsVector\n\nIdentify buses that Simulink treats as vectors."
            },
            {
                "heading": "Description",
                "content": "You cannot use buses that the Simulink software implicitly converts to vectors. Instead, either insert a Bus to Vector conversion block between the bus and the block input port that it feeds, or use the Simulink.BlockDiagram.addBusToVector function."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBuses are implicitly converted to vectors.Use Simulink.BlockDiagram.addBusToVector or insert a Bus to Vector block.Model is not configured to identify buses that Simulink treats as vectors.In the Configuration Parameters dialog box, on the Diagnostics > Connectivity pane, set Bus signal treated as vector to error."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify inserts a Bus to Vector block at the input ports of blocks that implicitly convert buses to vectors."
            },
            {
                "heading": "Tips",
                "content": "Run this check before running Check consistency of initialization parameters for Outport and Merge blocks.For more information, see Identify Automatic Bus Conversions."
            },
            {
                "heading": "See Also",
                "content": "Identify Automatic Bus Conversions Bus to Vector block Bus signal treated as vector Migrating to Simplified Initialization Mode Overview Simulink.BlockDiagram.addBusToVector"
            },
            {
                "heading": "Check for potentially delayed function-call subsystem return values",
                "content": "Check ID: mathworks.design.DelayedFcnCallSubsys\n\nIdentify function-call return values that might be delayed because Simulink software inserted an implicit Signal Conversion block."
            },
            {
                "heading": "Description",
                "content": "So that signals reside in contiguous memory, Simulink software can automatically insert an implicit Signal Conversion block in front of function-call initiator block input ports. This can result in a one-step delay in returning signal values from calling function-call subsystems. The delay can be avoided by ensuring the signal originates from a signal block within the function-call system. Or, if the delay is acceptable, insert a Unit Delay block in front of the affected input ports."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe listed block input ports could have an implicit Signal Conversion block.Decide if a one-step delay in returning signal values is acceptable for the listed signals.If the delay is not acceptable, rework your model so that the input signal originates from within the calling subsystem.If the delay is acceptable, insert a Unit Delay block in front of each listed input port."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "Signal Conversion block\n\nUnit Delay block\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify block output signals with continuous sample time and non-floating point data type",
                "content": "Check ID: mathworks.design.OutputSignalSampleTime\n\nFind continuous sample time, non-floating-point output signals."
            },
            {
                "heading": "Description",
                "content": "Non-floating-point signals might not represent continuous variables without loss of information."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSignals with continuous sample times have a non-floating-point data type.On the identified signals, either change the sample time to be discrete or fixed-in-minor-step ([0 1])."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "What Is Sample Time?.\n\nModel Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check usage of Merge blocks",
                "content": "Check ID: mathworks.design.MergeBlkUsage\n\nIdentify Merge blocks with parameter settings that can lead to unexpected behavior, and help migrate your model to simplified initialization mode.\n\nNoteRun this check along with the other checks in the Migrating to Simplified Initialization Mode Overview."
            },
            {
                "heading": "Description",
                "content": "Simplified initialization mode was introduced in R2008b to improve the consistency of simulation results. For more information, see Simplified Initialization Mode and Classic Initialization Mode.\n\nThis Model Advisor check identifies settings in the Merge blocks in your model that can cause problems if you use classic initialization mode. It also recommends settings for consistent behavior of Merge blocks. The results of the subchecks contain two types of statements: Failed and Warning. Failed statements identify issues that you must address manually before you can migrate the model to the simplified initialization mode. Warning statements identify issues or changes in behavior that can occur after migration."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionCheck the run-time diagnostic setting of the Merge block. In the Configuration Parameters dialog box, set Detect multiple driving blocks executing at the same time step to error. Verify that the model simulates without errors before running this check again. Check for Model blocks that are using the PIL simulation mode.The simplified initialization mode does not support the Processor-in-the-loop (PIL) simulation for model references.Check for library blocks with instances that cannot be migrated.Examine the failed subcheck results for each block to determine the corrective actions.Check for single-input Merge blocks.Replace both the Mux block used to produce the input signal and the Merge block with one multi-input Merge block.Single-input Merge blocks are not supported in the simplified initialization mode.Check for root Merge blocks that have an unspecified Initial output value.If you do not specify an explicit value for the Initial output parameter of root Merge blocks, then Simulink uses the default initial value of the output data type.A root Merge block is a Merge block with an output port that does not connect to another Merge block. For information on the default initial value, see Initialize Signal Values.Check for Merge blocks with nonzero input port offsets.Clear the Allow unequal port widths parameter of the Merge block. NoteConsider using Merge blocks only for signal elements that require true merging. You can combine other elements with merged elements using the Concatenate block.Check for Merge blocks that have unconnected inputs or that have inputs from non-conditionally executed subsystems.Set the Number of inputs parameter of the Merge block to the number of Merge block inputs. You must connect each input to a signal. Verify that each Merge block input is driven by a conditionally executed subsystem. Merge blocks cannot be driven directly by an Iterator Subsystem or a block that is not a conditionally executed subsystem.Check for Merge blocks with inputs that are combined or reordered outside of conditionally executed subsystems.Verify that combinations or reordering of Merge block input signals takes place within a conditionally executed subsystem. Such designs may use Mux, Bus Creator, or Selector blocks.Check for Merge blocks with multiple input ports that are driven by a single source.Verify that the Merge block does not have multiple input signals that are driven by the same conditionally executed subsystem or conditionally executed Model block. Check for Merge blocks that use signal objects to specify the Initial output value.Verify that the following behavior is acceptable.In the simplified initialization mode, signal objects cannot specify the Initial output parameter of the Merge block. While you can still initialize the output signal for a Merge block using a signal object, the initialization result may be overwritten by that of the Merge block.NoteSimulink generates a warning that the initial value of the signal object has been ignored."
            },
            {
                "heading": "See Also",
                "content": "Migrating to Simplified Initialization Mode Overview Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check usage of Outport blocks",
                "content": "Check ID: mathworks.design.InitParamOutportMergeBlk\n\nIdentify Outport blocks and conditional subsystems with parameter settings that can lead to unexpected behavior, and help migrate your model to simplified initialization mode.\n\nNoteRun this check along with the other checks in the Migrating to Simplified Initialization Mode Overview."
            },
            {
                "heading": "Description",
                "content": "Simplified initialization mode was introduced in R2008b to improve the consistency of simulation results. This mode is especially important for models that do not specify initial conditions for conditionally executed subsystem output ports. For more information, see Simplified Initialization Mode and Classic Initialization Mode.\n\nThis Model Advisor check identifies Outport blocks and conditional subsystems in your model that can cause problems if you use the simplified initialization mode. It also recommends settings for consistent behavior of Outport blocks. The results of the subchecks contain two types of statements: Failed and Warning. Failed statements identify issues that you must address manually before you can migrate the model to the simplified initialization mode. Warning statements identify issues or changes in behavior can occur after migration."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended Action Check for blocks inside of the Iterator Subsystem that require elapsed time. Within an Iterator Subsystem hierarchy, do not use blocks that require a service that maintains the time that has elapsed between two consecutive executions.Since an Iterator Subsystem can execute multiple times at a given time step, the concept of elapsed time is not well-defined between two such executions. Using these blocks inside of an Iterator Subsystem can cause unexpected behavior. Check for Outport blocks that have conflicting signal buffer requirements.The Outport block has a function-call trigger or function-call data dependency signal passing through it, along with standard data signals. Some of the standard data signals require an explicit signal buffer for the initialization of the output signal of the corresponding subsystem. However, buffering function-call related signals lead to a function-call data dependency violation. Consider modifying the model to pass function-call related signals through a separate Outport block. For examples of function-call data dependency violations, see Simulink Subsystem Semantics. A standard data signal may require an additional signal copy for one of the following reasons: The Outport block is driven by a block with output that cannot be overwritten. The Ground block and the Constant block are examples of such blocks.The Outport block shares the same signal source with another Outport block in the same subsystem or in one nested within the current subsystem but having a different initial output value.The Outport block connects to the input of a Merge blockOne of the input signals of the Outport block is specifying a Simulink.Signal object with an explicit initial value. Check for Outport blocks that are driven by a bus and whose Initial output value is not scalar.For Outport blocks driven by buses, classic initialization mode does not support Initial Condition (IC) structures, while simplified initialization mode does. Hence, when migrating a model from classic to simplified mode, specify a scalar for the Initial Output parameter. After migration completes, to specify different initial values for different elements of the bus, use IC structures. For more information, see Specify Initial Conditions for Bus Elements.Check for Outport blocks that require an explicit signal copy.An explicit copy of the bus driving the Outport block is required for the initialization of the output signal of the corresponding subsystem. Insert a Signal Conversion block before the Outport block, then set the Output parameter of the Signal Conversion block to Bus copy. A standard data signal may require an additional signal copy for one or more of the following reasons: A block with output that cannot be overwritten is driving the Outport block. The Ground block and the Constant block are examples of such blocks.The Outport block shares the same signal source with another Outport block in the same subsystem or in one nested within the current subsystem but having a different initial output value.The Outport block connects to the input of a Merge blockOne of the input signals of the Outport block is specifying a Simulink.Signal object with an explicit initial value. Check for merged Outport blocks that inherit the Initial Output value from Outport blocks that have been configured to reset when the blocks become disabled.When Outport blocks are driving a Merge block, do not set their Output when disabled parameters to reset.Check for merged Outport blocks that are driven by nested conditionally executed subsystems.Determine if the new behavior of the Outport blocks is acceptable. If it is not acceptable, modify the model to account for the new behavior before migrating to the simplified initialization mode.Check for merged Outport blocks that reset when the blocks are disabled.Set the Output when disabled parameter of the Outport block to held. This setting is required because the Outport block connects to a Merge block.For more information, see Outport.Check for Outport blocks that have an undefined Initial output value with invalid initial condition sources.Verify that the following behavior is acceptable.When the Initial output parameter is unspecified ([]), it inherits the initial output from the source blocks. If at least one of the sources of the Outport block is not a valid source to inherit the initial value, the block uses the default initial value for that data type.For simplified initialization mode, valid sources an Outport blocks can inherit the Initial output value from are: Constant, Initial Condition, Merge (with initial output), Stateflow chart, function-call model reference, or conditionally executed subsystem blocks. Check Outport blocks that have automatic rate transitions.Simulink has inserted a Rate Transition block at the input of the Outport block. Specify the Initial output parameter for each Outport block. Otherwise, perform the following procedure:In the Configuration Parameters dialog box, on the Solver pane, clear the option Automatically handle rate transition for data transfer.Run this Model Advisor check again.Check Outport blocks that have a special signal storage requirement and have an undefined Initial output value.Verify that the following behavior is acceptable.Specify the Initial output parameter for the Outport block. Set this value to [] (empty matrix) to use the default initial value of the output data type.Check the Initial output setting of Outport blocks that reset when they are disabled.Specify the Initial output parameter of the Outport block. You must specify the Initial output value for blocks that are configured to reset when they become disabled.Check the Initial output setting for Outport blocks that pass through a function-call data dependency signal.You cannot specify an Initial output value for the Outport block because function-call data dependency signals are passing through it. To set the Initial output value:Set the Initial output parameter of the Outport block to [].Provide the initial value at the source of the data dependency signal rather than at the Outport block.Check for Outport blocks that use signal objects to specify the Initial output value.Verify that the following behavior is acceptable.In the simplified initialization mode, signal objects cannot specify the Initial output parameter of an Outport block. You can still initialize the input or output signals for an Outport block using signal objects, but the initialization results may be overwritten by those of the Outport block.NoteIf you are working with a conditionally executed subsystem Outport block, Simulink generates a warning that the initial value of the signal object has been ignored.Check for library blocks with instances that have warnings.Examine the warning subcheck results for each block before migrating to the simplified initialization mode.Check for merged Outport blocks that are either unconnected or connected to a Ground block.Verify that the following behavior is acceptable. The Outport block is driving a Merge block, but its inputs are either unconnected or connected to Ground blocks. In the classic initialization mode, unconnected or grounded output ports do not update the merge signal even when their parent conditionally executed subsystems are executing. In the simplified initialization mode, however, these output ports will update the merge signal with a value of zero when their parent conditionally executed subsystems are executing.Check for Outport blocks that obtain the Initial output value from an input signal when they are migrated.Verify that the following behavior is acceptable.The Initial output parameter of the Outport block is not specified. As a result, the simplified initialization mode will assume that the Initial output value for the Outport block is derived from the input signal. This assumption may result in different initialization behavior.If this behavior is not acceptable, modify your model before you migrate to the simplified initialization mode.Check for outer Outport blocks that have an explicit Initial output.Verify that the following behavior is acceptable.In classic initialization mode, the Initial output and Output when disabled parameters of the Outport block must match those of their source Outport blocks.In simplified initialization mode, Simulink sets the Initial output parameter of outer Outport blocks to [] (empty matrix) and Output when disabled parameter to held.Check for blocks that read input from conditionally executed subsystems during initialization.Verify that the following behavior is acceptable.Some blocks, such as the Discrete-Time Integrator block, read their inputs from conditionally executed subsystems during initialization in the classic initialization mode. Simulink performs this step as an optimization technique.This optimization is not allowed in the simplified initialization mode because the output of a conditionally executed subsystem at the first time step after initialization may be different than the initial value declared in the corresponding Outport block. In particular, this discrepancy occurs if the subsystem is active at the first time step.Check for a migration conflict for Outport blocks that use a Dialog as the Source of initial output value.Other instances of Outport blocks with the same library link either cannot be migrated or are being migrated in a different manner. Review the results from the Check for library blocks with instances that cannot be migrated to learn about the different migration paths for other instances of each Outport block.The Outport block will maintain its current settings and use its specified Initial output value.Check for a migration conflict for Outport blocks that use Input signal as the Source of initial output value.Other instances of Outport blocks with the same library link either cannot be migrated or are being migrated in a different manner. Review the results from the Check for library blocks with instances that cannot be migrated to learn about the different migration paths for other instances of each Outport block.The Outport block currently specifies an Initial output of [] (empty matrix), and the Output when disabled as held. This means that each output port does not perform initialization, but implicitly relies on source blocks to initialize its input signal. After migration, the parameter Source of initial output value will be set to Input signal to reflect this behavior. Check for a migration conflict for Outport blocks that have SimEvents\u00c2\u00ae semantics.Other instances of Outport blocks with the same library link either cannot be migrated or are being migrated in a different manner. Review the results from the Check for library blocks with instances that cannot be migrated to learn about the different migration paths for other instances of each Outport block.The Outport blocks will continue to use an Initial output value of [] (empty matrix) and an Output when disabled setting of held. Simulink will maintain these settings because their parent conditionally executed subsystems are connected to SimEvents blocks. Check for a migration conflict for innermost Outport blocks with variable-size input and unspecified Initial output.For these Outport blocks, the signal size varies only when the parent subsystem of the block is re-enabled. Therefore, Simulink implicitly assumes that the Initial output parameter is equal to 0, even though the parameter is unspecified, []. Consequently, unless you specify the parameter, the Model Advisor will explicitly set the parameter to 0 when the model is migrated to the simplified initialization mode. Other instances of Outport blocks with the same library link either cannot be migrated or are being migrated in a different manner. Review the results from the Check for library blocks with instances that cannot be migrated to learn about the different migration paths for other instances of each Outport block.Check for a migration conflict for Outport blocks that use a default ground value as the Initial output.The parameter Initial output is set to [] (empty matrix) and the source of the Outport is an invalid initial condition source. Thus, the block uses the default initial value as the initial output in the simplified initialization mode. Other instances of Outport blocks with the same library link either have errors or are being migrated differently.Check for a migration conflict for merged Outport blocks without explicit specification of Initial output.Review the results from the subcheck Check for library blocks with instances that cannot be migrated to learn about different migration paths for other instances of each Outport block. For the remaining Outport blocks, Initial output is set to [] (empty matrix) and Output when disabled is set to held respectively, in simplified initialization mode."
            },
            {
                "heading": "See Also",
                "content": "Migrating to Simplified Initialization Mode Overview Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check usage of Discrete-Time Integrator blocks",
                "content": "Check ID: mathworks.design.DiscreteBlock\n\nIdentify Discrete-Time Integrator blocks with parameter settings that can lead to unexpected behavior, and help migrate your model to simplified initialization mode.\n\nNoteRun this check along with the other checks in the Migrating to Simplified Initialization Mode Overview."
            },
            {
                "heading": "Description",
                "content": "Simplified initialization mode was introduced in R2008b to improve the consistency of simulation results. For more information, see Simplified Initialization Mode and Classic Initialization Mode.\n\nThis Model Advisor check identifies settings in Discrete-Time Integrator blocks in your model that can cause problems if you use the simplified initialization mode. It also recommends settings for consistent behavior of Discrete-Time Integrator blocks. The results of the subchecks contain two types of statements: Failed and Warning. Failed statements identify issues that you must address manually before you can migrate the model to the simplified initialization mode. Warning statements identify issues or changes in behavior that can occur after migration."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionCheck for Discrete-Time Integrator blocks whose parameter Initial condition setting is set to Output.Determine if the new behavior of the Discrete-Time Integrator blocks is acceptable. If it is not acceptable, modify the model to account for the new behavior before migrating to the simplified initialization mode.Check for Discrete-Time Integrator blocks whose Initial condition setting parameter is set to State (most efficient) and are in a subsystem that uses triggered sample time.Use periodic sample time for the block, or set Initial Condition setting to Output.Check for blocks inside of the Iterator Subsystem that require elapsed time.Within an Iterator Subsystem hierarchy, do not use blocks that require a service that maintains the time that has elapsed between two consecutive executions.Since an Iterator Subsystem can execute multiple times at a given time step, the concept of elapsed time is not well-defined between two such executions. Using these blocks inside of an Iterator Subsystem can cause unexpected behavior."
            },
            {
                "heading": "See Also",
                "content": "Migrating to Simplified Initialization Mode Overview Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check model settings for migration to simplified initialization mode",
                "content": "NoteDo not run this check in isolation. Run this check along with the other checks in the Migrating to Simplified Initialization Mode Overview.\n\nCheck ID: mathworks.design.ModelLevelMessages\n\nIdentify settings in Model blocks and model configuration parameters that can lead to unexpected behavior, and help migrate your model to simplified initialization mode."
            },
            {
                "heading": "Description",
                "content": "Simplified initialization mode was introduced in R2008b to improve consistency of simulation results. For more information, see Simplified Initialization Mode and Classic Initialization Mode.\n\nThis Model Advisor check identifies issues in the model configuration parameters and Model blocks in your model that can cause problems when you migrate to simplified initialization mode. The results of the subchecks contain two types of statements: Failed and Warning. Failed statements identify issues that you must address manually before you can migrate the model to simplified initialization mode. Warning statements identify issues or changes in behavior that can occur after migration.\n\nAfter running this Model Advisor consistency check, if you click Explore Result button, the messages pertain only to blocks that are not library-links.\n\nNoteBecause it is difficult to undo these changes, select File > Save Restore Point As to back up your model before migrating to the simplified initialization mode.\n\nFor more information, see Model Configuration Parameters: Connectivity Diagnostics."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionVerify that all Model blocks are using the simplified initialization mode.Migrate the model referenced by the Model block to the simplified initialization mode, then migrate the top model.Verify simplified initialization mode settingSet Configuration Parameters > Underspecified initialization detection to Simplified."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify Settings causes the following:\n\nThe Model parameter is set to simplifiedIf an Outport block has the Initial output parameter set to the empty character vector, [], then the SourceOfInitialOutputValue parameter is set to Input signal.If an Outport has an empty Initial output and a variable-size signal, then the Initial output is set to zero."
            },
            {
                "heading": "See Also",
                "content": "Migrating to Simplified Initialization Mode Overview Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Simulation Accuracy Overview",
                "content": "Use the Simulation Accuracy Model Advisor checks to configure your model for accuracy considerations."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Model Advisor Checks (Simulink Coder) Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "Check S-functions in the model",
                "content": "Check ID: mathworks.design.SFuncAnalyzer\n\nPerform quality checks on S-functions in Simulink models or subsystems."
            },
            {
                "heading": "Description",
                "content": "The S-function analyzer performs quality checks on S-functions to identify improvements and potential problems in the specified model. The checks displays an error when the build dependency cannot be automatically derived, for example, when the source code is not in the current folder."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionContinuous states are modified in mdlOutputs method.Modify Continuous States at a major time step and use ssSetSolverNeedsReset function in S-function code.Continuous states are modified in the mdlUpdate method.Modify Continuous States only at a major time step and use ssSetSolverNeedsReset function in S-function code.S-function discrete states are modified in the mdlOutputs at a minor step.Modify the discrete states only at a major step guarded by ssIsMajorTimeStep function. S-function mode vector is modified in the mdlOutputs method at a minor step.Modify the mode vector only at a major step guarded by sslsMajorTimeStep function.S-function is using static or global variables to declare internal states.Declare the states explicitly using ssSetNumDiscStates function or Model Global Data by Creating Data Stores.S-function has continuous states but sample time is not declared continuous.Specify continuous sample time using ssSetSampleTime function.S-function has discrete states but the mdlOutputs and mdlUpdate methods are combined.Define the mdlOutputs and mdlUpdate methods separately and modify discrete states only in mdlUpdate method.S-function sets the SS_OPTION_CAN_BE_CALLED_CONDITIONALLY option when having state-like data or multiple sample times.Remove the options when the S-function has state-like data or multiple sample times.MEX compilers do not exist on the machine.Check for the presence or install MEX compilers on the machine.S-function encounters errors while compiling the model. Check the Diagnostic Viewer output and recompile the model."
            },
            {
                "heading": "Check for non-continuous signals driving derivative ports",
                "content": "Check ID: mathworks.design.NonContSigDerivPort\n\nIdentify noncontinuous signals that drive derivative ports."
            },
            {
                "heading": "Description",
                "content": "Noncontinuous signals that drive derivative ports cause the solver to reset every time the signal changes value, which slows down simulation."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThere are noncontinuous signals in the model driving derivative ports. Make the specified signals continuous.Replace the continuous blocks receiving these signals with discrete state versions of the blocks."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "Simulink Models Simulation Phases in Dynamic Systems Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Simulation Runtime Accuracy Diagnostics Overview",
                "content": "Use the Simulation Runtime Accuracy Diagnostics Model Advisor checks to configure your model for simulation accuracy diagnostics that can help find problems, but slows simulations."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks Model Advisor Checks (Simulink Coder) Simulink Check Checks (Simulink Check)"
            },
            {
                "heading": "Runtime diagnostics for S-functions",
                "content": "Check ID: mathworks.design.DiagnosticSFcn\n\nCheck array bounds and solver consistency if S-Function blocks are in the model."
            },
            {
                "heading": "Description",
                "content": "Validates whether S-Function blocks adhere to the ODE solver consistency rules that Simulink applies to its built-in blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSolver data inconsistency is set to none.In the Configuration Parameters dialog box, set Solver data inconsistency to warning or error.Array bounds exceeded is set to none.In the Configuration Parameters dialog box, set Array bounds exceeded to warning or error"
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "What Is an S-Function? How S-Functions Work Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify unit mismatches in the model",
                "content": "Check ID: mathworks.design.UnitMismatches\n\nIdentify instances of unit mismatches between ports in the model and between model argument values and definitions."
            },
            {
                "heading": "Description",
                "content": "Check for instances of unit mismatches between:\n\nPorts in the modelModel argument values and definitions\n\nTo detect and report warnings for mismatched units on model arguments, you must set the simulation mode of Model blocks to normal mode."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionUnit mismatches foundChange one of the mismatched unit settings to match the unit settings for the other port."
            },
            {
                "heading": "See Also",
                "content": "Unit Specification in Simulink Models."
            },
            {
                "heading": "Identify automatic unit conversions in the model",
                "content": "Check ID: mathworks.design.AutoUnitConversions\n\nIdentify instances of automatic unit conversions in the model."
            },
            {
                "heading": "Description",
                "content": "Identify instances of automatic unit conversions in the model."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionAutomatic unit conversions foundCheck that the converted units are expected for the model."
            },
            {
                "heading": "See Also",
                "content": "Unit Specification in Simulink Models."
            },
            {
                "heading": "Identify disallowed unit systems in the model",
                "content": "Check ID: mathworks.design.DisallowedUnitSystems\n\nIdentify instances of disallowed unit systems in the model."
            },
            {
                "heading": "Description",
                "content": "Identify instances of disallowed unit systems in the model."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionDisallowed unit systems foundEither choose a unit that conforms to the configured unit system, or select another unit system. For more information, see Restricting Unit Systems."
            },
            {
                "heading": "See Also",
                "content": "Unit Specification in Simulink Models."
            },
            {
                "heading": "Identify undefined units in the model",
                "content": "Check ID: mathworks.design.UndefinedUnits\n\nIdentify instances of unit specifications, not defined in the unit database, in the model."
            },
            {
                "heading": "Description",
                "content": "Identify instances of unit specifications, not defined in the unit database, in the model."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionUndefined units foundChange the unit to one that Simulink supports."
            },
            {
                "heading": "See Also",
                "content": "Unit Specification in Simulink Models. Allowed Units"
            },
            {
                "heading": "Identify ambiguous units in the model",
                "content": "Check ID: mathworks.design.AmbiguousUnits\n\nIdentify instances of ambiguous unit specifications, such as duplicate unit names in the unit database, in the model."
            },
            {
                "heading": "Description",
                "content": "Identify instances of ambiguous unit specifications, such as duplicate unit names in the unit database, in the model."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionAmbiguous units foundYou can ignore the warning or specify the unit with corresponding unit system using the format unit_system::unit_name."
            },
            {
                "heading": "See Also",
                "content": "Unit Specification in Simulink Models. Allowed Units"
            },
            {
                "heading": "Open the Upgrade Advisor",
                "content": "Check ID: com.mathworks.Simulink.UpgradeAdvisor.MAEntryPoint\n\nThis check provides access to the Upgrade Advisor."
            },
            {
                "heading": "Description",
                "content": "Run this check to access the Upgrade Advisor. Use the Upgrade Advisor for help with using the current release to upgrade and improve models. The Upgrade Advisor identifies cases where you can benefit by changing your model to use new features and settings in Simulink. The Advisor provides advice for transitioning to new technologies, and upgrading a model hierarchy.\n\nThe Upgrade Advisor also identifies cases when a model will not work because changes and improvements in Simulink require changes to a model.\n\nThe Upgrade Advisor offers options to perform recommended actions automatically or instructions for manual fixes."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionCheck for upgrade issues.Click the link \u00e2\u0080\u009cOpen the Upgrade Advisor\u00e2\u0080\u009d to close the Model Advisor and open the Upgrade Advisor for the current model."
            },
            {
                "heading": "Tips",
                "content": "Alternatively, you can open the Upgrade Advisor in the following ways:\n\nFrom the Model Editor, in the Modeling tab, select Model Advisor > Upgrade Advisor.From the MATLAB command line, use the upgradeadvisor function:upgradeadvisor modelnameSee Programmatically Open Upgrade Advisor and Programmatically Analyze and Upgrade Model."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Check model for block upgrade issues",
                "content": "Check ID: mathworks.design.Update\n\nCheck for common block upgrade issues."
            },
            {
                "heading": "Description",
                "content": "Check blocks in the model for compatibility issues resulting from using a new version of Simulink software."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBlocks with compatibility issues found.Click Modify to fix the detected block issues.Check update status for the Level 2 API S-functions.Consider replacing Level 1 S-functions with Level 2."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify replaces blocks from a previous release of Simulink software with the latest versions."
            },
            {
                "heading": "See Also",
                "content": "Write Level-2 MATLAB S-Functions.Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Check model for block upgrade issues requiring compile time information",
                "content": "Check ID: mathworks.design.UpdateRequireCompile\n\nCheck for common block upgrade issues."
            },
            {
                "heading": "Description",
                "content": "Check blocks for compatibility issues resulting from upgrading to a new version of Simulink software. Some block upgrades require the collection of information or data when the model is in the compile mode. For this check, the model is set to compiled mode and then checked for upgrades."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains Lookup Table or Lookup Table (2-D) blocks and some of the blocks specify Use Input Nearest or Use Input Above for a lookup method.Replace Lookup Table blocks and Lookup Table (2-D) blocks with n-D Lookup Table blocks. Do not apply Use Input Nearest or Use Input Above for lookup methods; select another option.Model contains Lookup Table or Lookup Table (2-D) blocks and some blocks perform multiplication first during interpolation.Replace Lookup Table blocks and Lookup Table (2-D) blocks with n-D Lookup Table blocks. However, because the n-D Lookup Table block performs division first, this replacement might cause a numerical difference in the result.Model contains Lookup Table or Lookup Table (2-D) blocks. Some of these blocks specify Interpolation-Extrapolation as the Lookup method but their input and output are not the same floating-point type.Replace Lookup Table blocks and Lookup Table (2-D) blocks with n-D Lookup Table blocks. Then change the extrapolation method or the port data types for block replacement.Model contains Unit Delay blocks with Sample time set to -1 that inherit a continuous sample time.Replace Unit Delay blocks with Memory blocks."
            },
            {
                "heading": "Check Data Store Memory blocks for multitasking",
                "content": ""
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify replaces blocks from a previous release of Simulink software with the latest versions."
            },
            {
                "heading": "See Also",
                "content": "n-D Lookup Table Unit Delay Upgrade Models Using Upgrade Advisor Model Upgrades"
            },
            {
                "heading": "Check if SLX file compression is off",
                "content": "Check ID: mathworks.design.CheckSLXFileCompressionLevel\n\nCheck if SLX file compression is turned off to reduce Git\u00e2\u0084\u00a2 repository size."
            },
            {
                "heading": "Description",
                "content": "Check whether compression for the SLX model is turned off."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel, library, or subsystem is saved in SLX format. File compression is turned on.Consider turning off file compression to optimize storage under source control."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on models, libraries, and subsystems checked in to Git source control."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Check that the model or library is saved in current version",
                "content": "Check ID: mathworks.design.CheckSavedInCurrentVersion\n\nCheck that the model, library, or subsystem is saved in the current version of Simulink."
            },
            {
                "heading": "Description",
                "content": "Check whether the model file is saved in the current Simulink release."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel, library, or subsystem not saved in the current version of Simulink.Consider saving the model file in the current version of Simulink."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your models, libraries, and subsystems."
            },
            {
                "heading": "Tips",
                "content": "Projects can help you save all the models and libraries in your project to the current Simulink release. See Check for Compatibility Issues and Upgrade Simulink Models Using Project Upgrade."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades Check for Compatibility Issues and Upgrade Simulink Models Using Project Upgrade"
            },
            {
                "heading": "Check model for SB2SL blocks",
                "content": "Check ID: mathworks.simulink.SB2SL.Check\n\nCheck that the model does not have outdated SB2SL blocks."
            },
            {
                "heading": "Description",
                "content": "Check if the model contains outdated SB2SL blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains outdated SB2SL blocksConsider upgrading the model to current SB2SL blocks."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Update SB2SL Blocks replaces blocks with the latest versions."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor."
            },
            {
                "heading": "Check Model History properties",
                "content": "Check ID: mathworks.design.SLXModelProperties\n\nCheck for edited model history properties"
            },
            {
                "heading": "Description",
                "content": "Check models for edited Model History property values that could be used with source control tool keyword substitution. This keyword substitution is incompatible with SLX file format.\n\nIn the MDL file format you can configure some model properties to make use of source control tool keyword substitution. If you save your model in SLX format, source control tools cannot perform keyword substitution. Information in the model file from such keyword substitution is cached when you first save the MDL file as SLX, and is not updated again. The Model Properties History pane and Model Info blocks in your model show stale information from then on."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionEdited model history propertiesManually or automatically reset the properties to the default values. Click the button to reset, or to inspect and change these properties manually, open the Model Properties dialog box and look in the History pane."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your library models."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Identify Model Info blocks that can interact with external source control tools",
                "content": "Check ID: mathworks.design.ModelInfoKeywordSubstitution\n\nUse this check to find Model Info blocks that can be altered by external source control tools through keyword substitution."
            },
            {
                "heading": "Description",
                "content": "This check searches for character vectors in the Model Info block enclosed within dollar signs that can be overwritten by an external source control tool. Using third-party source control tool keyword expansion might corrupt your model files when you submit them. Keyword substitution is not available in SLX model file format.\n\nFor a more flexible interface to source control tools, use a Simulink project instead of the Model Info block. See About Source Control with Projects."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe Model Info block contains fields like this: $keyword$Review the list of fields in the report, then remove the keyword character vectors from the Model Info block."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. About Source Control with Projects"
            },
            {
                "heading": "Check model for upgradable SerDes Toolbox blocks",
                "content": "Check ID: mathworks.design.serdesUpgrades\n\nLists blocks saved in a previous version of SerDes Toolbox\u00e2\u0084\u00a2 that are outdated."
            },
            {
                "heading": "Description",
                "content": "This check searches for and lists SerDes Toolbox blocks that can be upgraded for compatibility with the current release."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBlocks saved in older versions of SerDes Toolbox are found.Click Upgrade SerDes Toolbox Blocks to upgrade the SerDes Toolbox blocks to be compatible with the current release."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Upgrade SerDes Toolbox Blocks upgrades the outdated SerDes Toolbox blocks to be compatible with the current release."
            },
            {
                "heading": "See Also",
                "content": "Design and Simulate SerDes Systems (SerDes Toolbox)"
            },
            {
                "heading": "Check model for legacy 3DoF or 6DoF blocks",
                "content": "Check ID: mathworks.design.Aeroblks.CheckDOF\n\nLists 3DoF and 6DoF blocks are outdated."
            },
            {
                "heading": "Description",
                "content": "This check searches for 3DoF and 6DoF blocks from library versions prior to 3.13 (R2014a)."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionBlocks configured with old versions of 3DoF or 6DoF blocks found.Click Replace 3DoF and 6DoF Blocks to replace the blocks with latest versions."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Replace 3DoF and 6DoF Blocks replaces blocks with the latest versions."
            },
            {
                "heading": "See Also",
                "content": "Equations of Motion (Aerospace Blockset)"
            },
            {
                "heading": "Check model for Aerospace Blockset navigation blocks",
                "content": "Check ID: mathworks.design.Aeroblks.CheckNAV\n\nSearches for Three-Axis Inertial Measurement Unit, Three-Axis Gyroscope, and Three-Axis Accelerometer blocks prior to 3.21 (R2018a)."
            },
            {
                "heading": "Description",
                "content": "This check searches for Three-Axis Inertial Measurement Unit, Three-Axis Gyroscope, and Three-Axis Accelerometer blocks that have been updated in R2018a."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThree-Axis Inertial Measurement Unit, Three-Axis Gyroscope, and Three-Axis Accelerometer blocks prior to R2018a.In R2018a or later, if you did not previously solve for steady state conditions, save the model now. If you previously solved for steady state conditions for the model, solve for these steady state conditions again, and then save the model."
            },
            {
                "heading": "See Also",
                "content": "Three-axis Accelerometer (Aerospace Blockset)Three-axis Gyroscope (Aerospace Blockset)Three-axis Inertial Measurement Unit (Aerospace Blockset)"
            },
            {
                "heading": "Check and update masked blocks in library to use promoted parameters",
                "content": "Check ID: mathworks.design.CheckAndUpdateOldMaskedBuiltinBlocks\n\nCheck for libraries that should be updated to use promoted parameters."
            },
            {
                "heading": "Description",
                "content": "This check searches libraries created before R2011b for masked blocks that should be updated to use promoted parameters. Since R2011b, if a block parameter is not promoted, its value in the linked block is locked to its value in the library block. This check excludes blocks of type Subsystem, Model reference, S-Function and M-S-Function."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionLibraries that need to be updated are foundClick Update. Once the libraries have been updated, run the check again"
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check and update mask image display commands with unnecessary imread() function calls",
                "content": "Check ID: mathworks.design.CheckMaskDisplayImageFormat\n\nCheck identifies masks using image display commands with unnecessary calls to the imread() function."
            },
            {
                "heading": "Description",
                "content": "This check searches for the mask display commands that make unnecessary calls to the imread() function, and updates them with mask display commands that do not call the imread() function. Since 2013a, a performance and memory optimization is available for mask images specified using the image path instead of the RGB triple matrix."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionMask display commands that make unnecessary calls to the imread() function are found.Click Update. Once the blocks have been updated, run the check again."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check and update mask to affirm icon drawing commands dependency on mask workspace",
                "content": "Check ID: mathworks.design.CheckMaskRunInitFlag\n\nCheck identifies if the mask icon drawing commands have dependency on the mask workspace."
            },
            {
                "heading": "Description",
                "content": "This check identifies if the mask icon drawing commands have dependency on the mask workspace and updates the RunInitForIconRedraw property accordingly. If there is no mask workspace dependency, the value of RunInitForIconRedraw is set to off, whereas, if there is mask workspace dependency the values is set to on.\n\nSetting the values of RunInitForIconRedraw to off when there is no mask workspace dependency optimizes the performance by not executing the mask initialization code before drawing the block icon."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionMask drawing commands that are dependent or independent of the mask workspace are found.Click Update. Once the blocks have been updated, run the check again."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can:\n\nRun this check on your library models.Exclude blocks and charts from this check if you have a Simulink Check license."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Identify masked blocks that specify tabs in mask dialog using MaskTabNames parameter",
                "content": "Check ID: mathworks.design.CheckAndUpdateOldMaskTabnames\n\nThis check identifies masked blocks that specify tabs in mask dialog using the MaskTabNames parameter."
            },
            {
                "heading": "Description",
                "content": "This check identifies masked blocks that use the MaskTabNames parameter to programmatically create tabs in the mask dialog. Since R2013b, dialog controls are used to group parameters in a tab on the mask dialog."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionMasked blocks that use the MaskTabNames parameter to create tabs programmatically in the mask dialog are found.Click Upgrade available in the Action section. Once the blocks have been updated, run the check again."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your library models."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Identify questionable operations for strict single-precision design",
                "content": "Check ID: mathworks.design.StowawayDoubles\n\nFor a strict single-precision design, this check identifies the blocks that introduce double-precision operations, and non-optimal model settings."
            },
            {
                "heading": "Description",
                "content": "For a strict single-precision design, this check identifies the blocks that introduce double-precision operations, and non-optimal model settings."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionDouble-precision floating-point operations found in model. Verify that: Block input and output data types are set correctly.In the Configuration Parameters dialog box, Default for underspecified data type is set to single. Model uses a library standard that is not optimal for strict-single designs.Verify that:All target-specific math libraries used by the model support single-precision implementations.Set Configuration Parameters > Language standard to C99 (ISO).Logic signals are not implemented as Boolean data.Verify that:In the Configuration Parameters dialog box, Implement logic signals as Boolean data is selected."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "If you have a Simulink Check license, you can exclude blocks and charts from this check."
            },
            {
                "heading": "See Also",
                "content": "Validate a Floating-Point Embedded Model Upgrade Models Using Upgrade Advisor. Model Upgrades Model Advisor Exclusion Overview (Simulink Check)"
            },
            {
                "heading": "Check get_param calls for block CompiledSampleTime",
                "content": "Check ID: mathworks.design.CallsGetParamCompiledSampleTime\n\nUse this check to identify MATLAB files in your working environment that contain get_param function calls to return the block CompiledSampleTime parameter."
            },
            {
                "heading": "Description",
                "content": "For multi-rate blocks (including subsystems), Simulink returns the block compiled sample time as a cell array of the sample rates in the block. The return value is a cell array of pairs of doubles. MATLAB code that accepts this return value only as pairs of doubles can return an error when called with a multi-rate block. Use this check to identify such code in your environment. Modify these instances of code to accept a cell array of pairs of doubles instead.\n\nFor example, consider a variable blkTs, which has been assigned the compiled sample time of a multi-rate block.\n\nblkTs = get_param(block,'CompiledSampleTime');\n\nHere are some examples in which the original code works only if blkTs is a pair of doubles and the block is a single-rate block:\n\nExample 1if isinf(blkTs(1)) disp('found constant sample time') end Since blkTs is now a cell array, Simulink gives this error message:Undefined function 'isinf' for input arguments of type 'cell'Instead, use this code, for which blkTs can be a cell array or a pair of doubles.if isequal(blkTs, [inf,0]) disp('found constant sample time') end Example 2if all(blkTs == [-1,-1]) disp('found triggered sample time') end For the above example, since blkTs is now a cell array, Simulink gives this error:Undefined function 'eq' for input arguments of type 'cell'Instead, use this code, for which blkTs can be a cell array or a pair of doubles.if isequal(blkTs, [-1,-1]) disp('found triggered sample time') endExample 3if (blkTs(1) == -1) disp('found a triggered context') endAgain, since blkTs is now a cell array, Simulink gives this error:Undefined function 'eq' for input arguments of type 'cell'Instead, use this code.if ~iscell(blkTs) blkTs = {blkTs}; end for idx = 1:length(blkTs) thisTs = blkTs{idx}; if (thisTs(1) == -1) disp('found a triggered context') end endThe above code checks for a triggered type sample time (triggered or asynchronous). In cases in which a block has constant sample time ([inf,0]) in addition to triggered or asynchronous or when a block has multiple asynchronous rates, this alternative property detects the triggered type sample time.\n\nThis check scans MATLAB files in your environment. If the check finds instances of MATLAB code that contain get_param calls to output the block compiled sample time, Upgrade Advisor displays these results. It suggests that you modify code that accepts the block compiled sample time from multi-rate blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionNo MATLAB files call get_param(block,CompiledSampleTime)NoneSome MATLAB files call get_param(block,CompiledSampleTime)If files use the block CompiledSampleTime parameter from multi-rate blocks, modify these files to accept the parameter as a cell array of pairs of doubles"
            },
            {
                "heading": "See Also",
                "content": "Sample Times in Subsystems Block Compiled Sample Time"
            },
            {
                "heading": "Check if all simulation outputs are returned as a single Simulink.SimulationOutput object",
                "content": "Check ID: mathworks.design.CheckSingleSimulationOutput\n\nUse this check to identify if the simulation result is returned as a single Simulink.SimulationOutput object."
            },
            {
                "heading": "Description",
                "content": "This check scans your model to verify if the parameter ReturnWorkspaceOutputs is enabled. Enabling this parameter, returns simulation outputs in a Simulink.SimulationOutput when simulating interactively. Simulation outputs include signal, state, output, DSM logging, and scope and To Workspace block logging.\n\nWhen ReturnWorkspaceOutputs is enabled, it provides:\n\nEasier management of simulation data.Automatic access to SimulationMetadata.Compatibility with multiple parallel simulations and batch simulations."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSimulation outputs are not returned as a single Simulink.SimulationOutput objectReturn all simulation outputs as a single Simulink.SimulationOutput object"
            },
            {
                "heading": "See Also",
                "content": "Single simulation output Simulink.SimulationOutput"
            },
            {
                "heading": "Check model for parameter initialization and tuning issues",
                "content": "Check ID: mathworks.design.ParameterTuning\n\nUse this check to identify issues in the model that occur when you initialize parameters or tune them."
            },
            {
                "heading": "Description",
                "content": "This check scans your model for parameter initialization and tuning issues like:\n\nRate mismatch between blocksDivide by zero issue in conditionally executed subsystemsInvalid control port value in Index Vector blocks"
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe model has rate transition issues.Select Automatically handle rate transition for data transfer in the Solver pane of the model configuration parameters.The model has a divide by zero issue in a conditionally executed subsystem with a control port.At the command prompt, run set_param(control_port,'DisallowConstTsAndPrmTs', 'on')The model has an invalid control port value in a conditionally executed subsystem.At the command prompt, run set_param(control_port,'DisallowConstTsAndPrmTs', 'on')"
            },
            {
                "heading": "Action Results",
                "content": "Select Upgrade model to resolve issues in the model related to parameter initialization and tuning."
            },
            {
                "heading": "See Also",
                "content": "Automatic Rate Transition"
            },
            {
                "heading": "Check for virtual bus across model reference boundaries",
                "content": "Check ID: mathworks.design.CheckVirtualBusAcrossModelReference\n\nCheck virtual buses that cross model reference boundaries."
            },
            {
                "heading": "Description",
                "content": "This Upgrade Advisor check identifies root Inport and Outport blocks that have these issues at model reference boundaries:\n\nIncompatible virtual busesLarge virtual buses that can slow performance (since R2024b)\n\nThis check also identifies the Model blocks that correspond with the affected Outport blocks.\n\nUsing nonvirtual buses instead of virtual buses resolves the issues."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "TipRun this check for all levels in the model reference hierarchy using the Analyze model hierarchy and continue upgrade sequence check.\n\nConditionRecommended ActionRoot Inport blocks receive incompatible or large virtual buses as input.Click Upgrade Model to select Output as nonvirtual bus for the Inport blocks and to insert Signal Conversion blocks that restore the virtual buses.Root Outport blocks receive incompatible or large virtual buses as input.Click Upgrade Model to select Output as nonvirtual bus in parent for the Outport blocks.Model blocks reference models that contain root Outport blocks that receive incompatible or large virtual buses as input.Click Upgrade Model to insert Signal Conversion blocks after the Model blocks, converting nonvirtual buses to virtual buses as necessary.The software inserts a Signal Conversion block after each Model block port whose Outport block was updated to address issues. The Signal Conversion block is configured to output a virtual bus.\n\nFor root-level Inport and Outport blocks that receive incompatible virtual buses, the conversion happens in models where you:\n\nUse function prototype control.Perform C++ code generation with the I/O arguments step method option.To change the C++ code generation function specification setting to Default step method: In the Configuration Parameters > Code Generation > Interface pane, click Configure C++ Class Interface.In the dialog box, set the Function specification parameter to Default step method. Use buses that have variable-dimension signals.Use an associated non-auto storage class for Outport block signals.The conversion for non-auto storage class occurs only if you have the target generation license that the model requires. For example, an ERT target requires an Embedded Coder license.Use export-function models where an Outport block is driven by a nonvirtual bus.Have Model blocks that reference models containing Outport blocks that have been fixed."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade AdvisorSimplify Subsystem and Model Interfaces with Bus Element PortsUse Buses at Model Interfaces"
            },
            {
                "heading": "Check model for custom library blocks that rely on frame status of the signal",
                "content": "Check ID: mathworks.design.DSPFrameUpgrade\n\nThis check identifies custom library blocks in the model that depend on the frame status of the signal.\n\nDescription\n\nThis check searches for the custom library blocks in a model that depend on the frame status of the signal. The check analyzes the blocks, recommends fixes, and gives reasons for the fixes. You must make the fixes manually."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe check finds custom library blocks that depend on the frame status of the signal.Follow the recommendation given by the Upgrade Advisor."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check only on custom library blocks in your model.\n\nYou must make the fixes manually.\n\nThis check appears only if you have the DSP System Toolbox\u00e2\u0084\u00a2 installed."
            },
            {
                "heading": "Check model for S-function upgrade issues",
                "content": "Check ID: 'mathworks.design.CheckForSFcnUpgradeIssues'\n\nUse this check on your model to identify your S-function's upgrade compatibility issues. These issues may include the use of 32-bit APIs, compilation with incompatible options, or use of deprecated separate complex APIs. Some common issues and information related to the fixes are described in results and recommendations section below."
            },
            {
                "heading": "Description",
                "content": "When upgrading your S-functions to use the features in the latest release, this check scans your model to warn against S-function upgrade incompatibility issues. If the result of this check gives a warning or error, fix your C MEX S-functions according to the description."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionCustom-built S-functions are not supported.Recompile your S-function with available compatible options. See Custom-built MEX File Not Supported In Current Release for more information.S-function is not compiled with the latest API (mex -R2018a).Recompile using the latest flag (mex -R2018a). See MEX File Is Compiled With Outdated Option for more information.S-function uses 32-bit functions.Modify your code according to the instructions in MEX File Calls A 32-bit Function.S-function is using deprecated separate complex APIs (mxGetPi, mxSetPi, mxGetImagData, mxSetImagData).Use interleaved complex APIs and recompile your code with the latest flag (mex -R2018a). See Upgrade MEX Files to Use Interleaved Complex API for more information.S-function is using deprecated type-unsafe data API (mxGetData, mxSetData).Use type-safe data APIs and recompile your code. See MEX File Calls An Untyped Data Access Function for more information.S-function is compiled with a future release and not supported in current release.See MEX File Built In MATLAB Release Not Supported In Current Release to recompile your files."
            },
            {
                "heading": "See Also",
                "content": "MATLAB Data in C S-Functions"
            },
            {
                "heading": "Update System object syntax",
                "content": "Check ID: 'mathworks.design.CheckSystemObjectUpdate'\n\nUse this check to identify and update any custom MATLAB System object\u00e2\u0084\u00a2 in your model that have outdated syntax."
            },
            {
                "heading": "Description",
                "content": "This check scans your model to identify outdated System object syntax. If the check passes, all the syntax is up to date. If the check fails, you can update the syntax."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSystem object syntax is up to date.None.System object syntax requires update.A report is generated for each unique System object associated with a MATLAB System block. Use Update to update the syntax."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor"
            },
            {
                "heading": "Check Rapid accelerator signal logging",
                "content": "Check ID: mathworks.design.CheckRapidAcceleratorSignalLogging\n\nWhen simulating your model in rapid accelerator mode, use this check to find signals logged in your model that are globally disabled. Rapid accelerator mode supports signal logging. Use this check to enable signal logging globally."
            },
            {
                "heading": "Description",
                "content": "This check scans your model to see if a simulation is in rapid accelerator mode and whether the model contains signals with signal logging. If the check finds an instance and signal logging is globally disabled, an option to turn on signal logging globally appears."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionSimulation mode is not rapid accelerator.None. You can enable signal logging in rapid accelerator mode.Simulation mode is rapid accelerator. Upgrade Advisor did not find signals with signal logging enabled.None. The model does not use signal logging. Enable signal logging for signals and globally if you want to log signals.Simulation mode is rapid accelerator. Upgrade Advisor found signals with signal logging enabled. However, global setting for signal logging was disabled. Enable signal logging globally if you want to log signals with signal logging enabled.Signal logging was already globally enabled.None."
            },
            {
                "heading": "Action Results",
                "content": "Selecting Modify enables signal logging globally in your model."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor."
            },
            {
                "heading": "Check virtual bus inputs to blocks",
                "content": "Check ID: mathworks.design.VirtualBusUsage\n\nCheck bus input signals for a set of blocks."
            },
            {
                "heading": "Description",
                "content": "Check bus input signals for a set of blocks.\n\nStarting in R2015b, virtual bus inputs to blocks that require nonbus or nonvirtual bus input can cause an error. Examples of blocks that can specify a bus object as their output data type include a Bus Creator block and a root Inport block. The blocks that cause an error when they have a virtual bus input in this situation are:\n\nAssignmentDelayThe Delay block causes an error only if you use the Block Parameters dialog box to:Set an initial condition that is a MATLAB structure or zero.Specify a value for State name.Permute DimensionReshapeSelectorUnit DelayThe Unit Delay block causes an error only if you use the Block Parameters dialog box to:Set an initial condition that is a MATLAB structure or zero.Specify a value for State name.Vector Concatenate"
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionVirtual bus input to these blocks:AssignmentDelay (if you specify an initial condition from the dialog box that is a MATLAB structure or zero and the value for State name is not empty)Permute DimensionReshapeSelectorUnit Delay (if you specify an initial condition that is a MATLAB structure or zero and the value for State name is not empty)Vector ConcatenateIn the Upgrade Advisor, click Modify.The check inserts a Bus to Vector block to attempt to convert the virtual buses to vectors. For issues that the Upgrade Advisor identifies but cannot fix, modify the model manually. For details, see Identify Automatic Bus Conversions."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify inserts a Bus to Vector block at the input ports of blocks.\n\nFor many models, running the Upgrade Advisor modifies your model so that buses are not treated as vectors. However, for some models you can encounter compatibility issues even after running the check. Modify your model manually to address those issues.\n\nAfter you compile the model using Upgrade Advisor, the Simulink Editor sometimes indicates that you need to save the model (the model is dirty), even though you did not make changes. To prevent this issue from reoccurring for this model, save the model.\n\nModeling PatternIssueSolutionData Store Memory block with Data Type set to Inherit: autoA Data Store Memory block whose associated Data Store Read or Data Store Write blocks read or write bus data must use a bus object.In the Data Store Memory block, set the Data Type signal attribute to Bus: <BusObject>.Signal Conversion block Output parameter matches input bus typeA Signal Conversion block whose Output parameter is set to Nonvirtual bus requires a virtual bus input.A Signal Conversion block whose Output parameter is set to Virtual bus requires a nonvirtual bus input.To create a copy of the input signal, set Output to Signal copy.Merge, Switch, or Multiport Switch block with multiple bus inputsMerge, Switch, or Multiport Switch blocks with multiple bus inputs require those inputs to have the same names and hierarchy.Reconfigure the model so that the bus inputs have the same names and hierarchy.Root Inport block outputting a virtual bus and specifying a value for Port dimensionsA root Inport block that outputs to a virtual bus must inherit the dimensions.Set the Inport block Port dimensions signal attribute to 1 or -1 (inherit).Mux block with nonvirtual bus inputsA Mux block cannot accept nonvirtual buses.To treat the output as an array, replace the Mux block with a Vector Concatenate block.If you want a virtual bus output, use a Bus Creator block to combine the signals.Bus to Vector block without a virtual bus inputA nonbus signal does not need a Bus to Vector block. Remove the Bus to Vector block.Assignment block with virtual bus inputsThe Upgrade Advisor converts the Assignment block Y0 port bus input to a vector.Add a Bus to Vector block before the Assignment block.S-function using a nonvirtual busAn S-function that is not a Level-2 C S-function does not support nonvirtual buses.Change the S-function to be a Level-2 C S-function.Consider using an S-Function Builder block to create a Level-2 C S-function.Stateflow chart with parameterized data typeIn a Stateflow chart, you cannot parameterize the data type of an input or output in terms of another input or output if the data type is a bus object.For the parameterized port, set Data Type to Bus: <object name>.Subsystem with bus operations in a Stateflow chartAn Inport block inside a subsystem in a Stateflow chart requires a bus object data type if its signal is a bus.In the Inport block, set Data type to Bus: <object name>.Ground block used as a bus sourceThe output signal of a Ground block cannot be a source for a bus.Use a Constant block with Constant value set to 0 and the Output data type signal attribute set to Bus: <object name>.Root Outport block with a single-element bus object data typeThe input to the Outport block must be a bus if it specifies a bus object as its data type.In the Outport block, set Data type to Inherit: auto."
            },
            {
                "heading": "See Also",
                "content": "Bus to Vector block Identify Automatic Bus Conversions Migrating to Simplified Initialization Mode Overview Simulink.BlockDiagram.addBusToVector"
            },
            {
                "heading": "Check for root outports with constant sample time",
                "content": "Check ID: mathworks.design.CheckConstRootOutportWithInterfaceUpgrade\n\nUse this check to identify root output ports with a constant sample time used with an AUTOSAR target, Function Prototype Control, or the model C++ class interface."
            },
            {
                "heading": "Description",
                "content": "Root output ports with constant sample time are not supported when using an AUTOSAR target, Function Prototype Control, or the model C++ class interface. Use this check to identify root Outport blocks with this condition and modify the blocks as recommended."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionRoot output port with constant sample time used with an AUTOSAR target, Function Prototype Control or the model C++ class interface.Consider one of the following:Set the sample time of the block to the fundamental sample time.Identify the source of the constant sample time and set its sample time to the fundamental sample time.Place a Rate Transition block with inherited sample time (-1) before the block."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor."
            },
            {
                "heading": "Analyze model hierarchy and continue upgrade sequence",
                "content": "Check ID: com.mathworks.Simulink.UpgradeAdvisor.UpgradeModelHierarchy\n\nCheck for child models and guide you through upgrade checks."
            },
            {
                "heading": "Description",
                "content": "This check identifies child models of this model, and guides you through upgrade checks to run both non-compile and compile checks. The Advisor provides tools to help with these tasks:\n\nIf the check finds child models, it offers to run the Upgrade Advisor upon each child model in turn and continue the upgrade sequence. If you have a model hierarchy you need to check and update each child model in turn.If there are no child models, you still need to continue the check sequence until you have run both non-compile and compile checks.\n\nYou must run upgrade checks in this order: first the checks that do not require compile time information and do not trigger an Update Diagram, then the compile checks.\n\nClick Continue Upgrade Sequence to run the next checks. If there are child models, this will open the next model. Keep clicking Continue Upgrade Sequence until the check passes."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionChild models foundClick Continue Upgrade Sequence to run the next checks. If there are child models, this will close the current Upgrade Advisor session, and open Upgrade Advisor for the next model in the hierarchy.No child models, but more checks to runIf there are no child models, click Continue Upgrade Sequence to refresh the Upgrade Advisor with compilation checks selected. The compile checks trigger an Update Diagram (marked with ^). Run the next checks and take advised actions. When you return to this check, click Continue Upgrade Sequence until this check passes."
            },
            {
                "heading": "Tips",
                "content": "Best practice for upgrading a model hierarchy is to check and upgrade each model starting at the leaf end and working up to the root model.\n\nWhen you click Continue Upgrade Sequence, the Upgrade Advisor opens the leaf model as far inside the hierarchy as it can find. Subsequent steps guide you through upgrading your hierarchy from leaf to root model.\n\nWhen you open the Upgrade Advisor, the checks that are selected do not require compile time information and do not trigger an Update Diagram. Checks that trigger an Update Diagram are not selected to run by default, and are marked with ^. When you use the Upgrade Advisor on a hierarchy, keep clicking Continue Upgrade Sequence to move through this sequence of analysis:\n\nThe Upgrade Advisor opens each model and library in turn, from leaf to root, and selects the non-compile checks. Run the checks, take any advised actions, then click Continue Upgrade Sequence to open the next model and continue.When you reach the root end of the hierarchy, the Upgrade Advisor then opens each model again in the same order (but not libraries) and selects only the checks that require a model compile. Run the checks, take any advised actions, then click Continue Upgrade Sequence to open the next model. Continue until you reach the end of the hierarchy and this check passes."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor. Model Upgrades"
            },
            {
                "heading": "Check Access to Data Stores",
                "content": "Check ID: mathworks.design.ConflictsForDataStoreReadWriters\n\nIdentify potential execution order sensitivity when reading and writing to data stores."
            },
            {
                "heading": "Description",
                "content": "The execution order of blocks that read and write to the same data store can change the simulation result. When blocks in the same hierarchy access the same data store, the execution order is not deterministic."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionData Store Memory block accessed by multiple blocks in the same hierarchy.To enforce execution order for the blocks, consider the following:Add a data dependency between the blocks.Set block priority.Move blocks into separate Function-Call Subsystem blocks and schedule them."
            },
            {
                "heading": "See Also",
                "content": "Local and Global Data Stores Data Store MemoryData Store ReadData Store Write"
            },
            {
                "heading": "Check relative execution orders for Data Store Read and Data Store Write blocks",
                "content": "Check ID: mathworks.design.TaskBasedSorting\n\nCheck relative execution order changes between legacy and task-based sorting for Data Store Read and Data Store Write blocks."
            },
            {
                "heading": "Description",
                "content": "Legacy models used block sorting to determine block execution order. With task-based sorting, the relative execution order involving Data Store Memory blocks can change. This check detects the changes and provides an option to update your model with the original execution order."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionExecution order with a Data Store Memory block changes. You want the original execution order.Click the Modify button."
            },
            {
                "heading": "See Also",
                "content": "Control and Display Execution Order"
            },
            {
                "heading": "Check for case mismatches in references to models and libraries",
                "content": "Check ID: mathworks.design.CaseSensitiveBlockDiagramNames\n\nIdentify and fix case-insensitive references to models and libraries."
            },
            {
                "heading": "Description",
                "content": "Starting R2020a, Simulink model and library names are case-sensitive. This check detects and provides an option to fix case-insensitive references to models and libraries."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionThe check finds case mismatches in references to models and libraries.Follow the recommendation given by the Upgrade Advisor."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor"
            },
            {
                "heading": "Check model for Signal Builder blocks",
                "content": "Check ID: mathworks.design.Sigbldr.upgradeCheck\n\nSearches for Signal Builder blocks in models."
            },
            {
                "heading": "Description",
                "content": "Find Signal Builder blocks in models and replace them with equivalently configured Signal Editor blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains one or more Signal Builder blocks.To replace all Signal Builder blocks with equivalent Signal Editor blocks, click the associated link."
            },
            {
                "heading": "See Also",
                "content": "Signal Editor Upgrade Models Using Upgrade Advisor"
            },
            {
                "heading": "Check output dimensions of MATLAB Function blocks",
                "content": "Check ID:mathworks.simulink.MLFBOutputDimensions\n\nCheck lists all the MATLAB Function blocks that have the Interpret output column vectors as one-dimensional data property enabled. If the property is enabled, the block converts output column vectors of size N-by-1 to one-dimensional signals with a signal size equal to N."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionMATLAB Function block produces one-dimensional output data and has property enabledClicking the Fix It button does not disable the property for the MATLAB function block. To disable the property: Select the MATLAB Function block.Open the Property Inspector. In the Modeling tab, in the Design section, click Property Inspector. In the General tab, clear the Interpret output column vectors as one-dimensional data property. Check the simulation behavior of the model, as disabling the property changes the size propagation of the MATLAB function block.MATLAB Function block does not produce one-dimensional data and has property enabledClick the Fix It button to disable the property for the MATLAB function block."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor Interpret output column vectors as one-dimensional data"
            },
            {
                "heading": "Check model for RF Blockset Divider blocks using Wilkinson power divider component with broken connections",
                "content": "Check ID: mathworks.design.rfblockset.ce.checkDisconnectedDividerBlocks\n\nSearch the model and list the RF Blockset\u00e2\u0084\u00a2 Divider blocks using the Wilkinson power divider component with broken port connections on port 3."
            },
            {
                "heading": "Description",
                "content": "Starting R2021a, port positions of the RF Blockset Divider blocks using the Wilkinson power divider component are changed. This check searches and lists the Divider blocks using the Wilkinson power divider component model with broken port connections on port 3 prior to R2021a. You can then rewire the connections using the Modify button."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModels have RF Blockset Divider blocks using the Wilkinson power divider component with broken port connections on port 3.Click the Modify button to rewire the broken connections on port 3 of the RF Blockset Divider blocks."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Modify rewires the broken port connections on port 3 of the RF Blockset Divider blocks.\n\nNoteThe Modify button will attempt to automatically rewire all the broken connections at port 3 of the Divider blocks using the Wilkinson power divider component in your model. To ensure accuracy, you must subsequently: Examine the details listed under the Result pane of the Upgrade Advisor. The first list enumerates the RF Blockset Divider blocks using the Wilkinson power divider component that require manual rewiring due to model complexity. The second list enumerates the automatically rewired blocks.Fixed and unfixed Divider blocks are temporarily highlighted in colors green and red, respectively. Click the Remove all temporary block highlighting link at the bottom of the Result pane to remove the highlights."
            },
            {
                "heading": "See Also",
                "content": "Upgrade Models Using Upgrade Advisor"
            },
            {
                "heading": "Identify Environment Controller Blocks and Replace Them with Variant Source Blocks",
                "content": "Check ID:mathworks.design.ReplaceEnvironmentControllerBlk\n\nSearch for Environment Controller blocks in the model."
            },
            {
                "heading": "Description",
                "content": "Find Environment Controller blocks in the model and replace them with Variant Source blocks with the Variant control mode parameter set to 'sim codegen switching'."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains one or more Environment Controller blocks.Replace Environment Controller blocks with Variant Source blocks with the Variant control mode parameter set to 'sim codegen switching'."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your library models.You cannot use this check to identify Environment Controller blocks in referenced models and linked blocks."
            },
            {
                "heading": "See Also",
                "content": "Environment Controller block has been removedVariant Source"
            },
            {
                "heading": "Identify variant blocks with VariantActivation set to \"Inherit From Simulink.VariantControl\" but does not use Simulink.VariantControl",
                "content": "Check ID: mathworks.simulink.InheritVATFromSlVarCtrlCheck\n\nIdentify variant blocks in the model that have no variant control variables of type Simulink.VariantControl to inherit activation time."
            },
            {
                "heading": "Description",
                "content": "Identify variant blocks with Variant activation time set to inherit from Simulink.VariantControl but no variant control variables of type Simulink.VariantControl."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionVariant block with inherit from Simulink.VariantControl activation time has no variant control variables of type Simulink.VariantControl.Change the type of at least one variant control variable to Simulink.VariantControl."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "You can run this check on your library models."
            },
            {
                "heading": "See Also",
                "content": "Simulink.VariantControlTypes of Variant Activation Time in Variant Blocks and Variant Parameters"
            },
            {
                "heading": "Replacing Blocks That Will Be Removed Overview",
                "content": "Checks to identify if the model contains any blocks that have been removed or will be removed in a future release."
            },
            {
                "heading": "See Also",
                "content": "Run Model Advisor Checks"
            },
            {
                "heading": "Check for machine-parented data",
                "content": "Check ID: mathworks.stateflow.MachineParentedData.check\n\nCheck the model for instances of machine-parented data."
            },
            {
                "heading": "Description",
                "content": "Machine-parented data prevents models from reusing generated code and other code optimizations. Machine-parented data is also incompatible with many Simulink and Stateflow features. To make Stateflow data accessible to other charts and blocks in a model, use chart-parented data of scope Data Store Memory. For more information, see Access Data Store Memory from a Chart (Stateflow).\n\nNoteStarting in R2023a, Stateflow charts no longer support machine-parented data. Use the Upgrade Advisor to convert machine-parented data to chart-parented data store memory. For more information, see Upgrade Models Using Upgrade Advisor and Check for machine-parented data."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionA Simulink model contains Stateflow machine-parented data.Upgrade the model by converting machine-parented data to chart-parented data with values in the model workspace."
            },
            {
                "heading": "Action Results",
                "content": "Clicking Upgrade model creates chart-parented data in the charts that use machine-parented data.\n\nIf a machine-parented data object has a scope of Parameter, the new chart-parented data object has a scope of Parameter. The value is stored as a Simulink.Parameter object in the model workspace.If a machine-parented data object has any other scope, the new chart-parented data object has a scope of Data Store Memory. The value is stored as a Simulink.Signal object in the model workspace."
            },
            {
                "heading": "Capabilities and Limitations",
                "content": "Automatic conversion fails when:\n\nThe model workspace contains a Simulink.Parameter or Simulink.Signal object with the same name as the machine-parented data.The model contains chart-parented data, events, or messages with the same name as the machine-parented data.The machine-parented data uses Stateflow semantics that do not have an equivalent for Simulink.Parameter or Simulink.Signal objects."
            },
            {
                "heading": "Tips",
                "content": "If your model contains a library chart or an atomic subchart linked from a library, you must upgrade every model that uses the library before you upgrade the library.\n\nOpen and upgrade each top model that uses the library.Upgrading the top model creates a Simulink.Parameter or Simulink.Signal object in the model workspace for each machine-parented data in the library.Save and close the top models.Open and upgrade the library model.Upgrading the library model creates chart-parented data that replaces the machine-parented data in the library.Save and close the library model."
            },
            {
                "heading": "See Also",
                "content": "Share Parameters with Simulink and the MATLAB Workspace (Stateflow)Access Data Store Memory from a Chart (Stateflow)Best Practices for Using Data in Charts (Stateflow)Upgrade Models Using Upgrade Advisor"
            },
            {
                "heading": "Identify clones from the linked library",
                "content": "Check ID: mathworks.cloneDetection.libraryEdittime\n\nIdentify clones in the model from the linked library file."
            },
            {
                "heading": "Description",
                "content": "Clones are modeling patterns that have identical block types and connections. The Clone Detector (Simulink Check) identifies clones across the model. You can reuse components in your model by identifying clone patterns and replacing clones with links to the library blocks.\n\nThis check highlights the clones present in the model from the linked library."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains a clone pattern from the linked library.Replace the clones with links to the library file."
            },
            {
                "heading": "Capabilities",
                "content": "You can run this check to:\n\nHighlight exact clones from the linked library. For more information, see Exact Clones and Similar Clones (Simulink Check).Highlight both subsystem clones and Simulink blocks with identical patterns from the linked library. For more information, see Specify Where to Detect Clones (Simulink Check)."
            },
            {
                "heading": "Limitations",
                "content": "The check cannot identify clones in variants, Stateflow charts, and MATLAB Function blocks in the model.The check does not highlight clones if a subsystem contains a nested subsystem that is more than two levels deep."
            },
            {
                "heading": "Action Results",
                "content": "Clicking the Fix button replaces the clones with links to the linked library file."
            },
            {
                "heading": "See Also",
                "content": "Enable Component Reuse by Using Clone Detection (Simulink Check)Replace Exact Clones with Subsystem Reference (Simulink Check)"
            },
            {
                "heading": "Refactor Bus Selector and Bus Creator blocks to In Bus Element and Out Bus Element blocks",
                "content": "Check ID: mathworks.m2m_edittime.BusPortsXform\n\nRefactor Bus Selector and Bus Creator blocks to In Bus Element and Out Bus Element blocks."
            },
            {
                "heading": "Description",
                "content": "To simplify your model, it is recommended to use In Bus Element and Out Bus Element blocks instead of Bus Selector blocks for inputs and Bus Creator blocks for outputs. For more information, see Simplify Subsystem and Model Interfaces with Bus Element Ports.\n\nThis check highlights the Bus Selector and Bus Creator blocks in the model and you can transform those blocks to In Bus Element and Out Bus Element blocks."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "ConditionRecommended ActionModel contains Bus Selector and Bus Creator blocks.Replace the Bus Selector and Bus Creator blocks to In Bus Element and Out Bus Element blocks."
            },
            {
                "heading": "Capabilities",
                "content": "You can refactor the model by clicking Fix button in Model Advisor."
            },
            {
                "heading": "Action Results",
                "content": "Fix button transforms the model by replacing the suitable Bus Selector and Bus Creator blocks to In Bus Element and Out Bus Element blocks."
            },
            {
                "heading": "See Also",
                "content": "Check Model Compliance Using Edit-Time Checking (Simulink Check)Simplify Subsystem and Model Interfaces with Bus Element Ports"
            },
            {
                "heading": "Clone Detection and Model Refactoring",
                "content": "Use Clone Detection and Model Refactoring checks to improve model componentization, readability, and enable reuse. If you have a Simulink Check license, you can use edit-time checking to identify clones from the linked library file and refactor Bus Selector and Bus Creator blocks to In Bus Element and Out Bus Element blocks during the model development process."
            },
            {
                "heading": "See Also",
                "content": "Identify clones from the linked libraryCheck Model Compliance Using Edit-Time Checking"
            },
            {
                "heading": "Check if the model settings to create an export-function model are satisfied",
                "content": "Check ID: mathworks.design.CheckExpFcnMdlSpecification\n\nCheck if both the modeling style and the execution domain settings conform to export-function model design requirements.\n\nFor more information, see Designate Model as Export-Function Model and Satisfy Export-Function Model Requirements."
            },
            {
                "heading": "Description",
                "content": "This check searches for any mismatch between the execution domain setting on the Property Inspector tab and the modeling style when you create an export-function model."
            },
            {
                "heading": "Results and Recommended Actions",
                "content": "Condition Recommended ActionOn the Property Inspector tab, execution domain is set as Export function, but the modeling style does not satisfy the export-function model design requirements.Check fails. Consider changing the modeling style to satisfy the export-function model design requirements. For more information, see Designate Model as Export-Function Model and Satisfy Export-Function Model Requirements.However, if you need to keep the current modeling style, clear the Export function selection on the Property Inspector.The modeling style indicates an export-function model, but the execution domain is not set as Export function.Check fails. On the Property Inspector tab, go to the Execution tab. Select the Set execution domain parameter and, from the Domain list, select Export function."
            },
            {
                "heading": "See Also",
                "content": "Create Export-Function Model"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/slref/simulink-checks.html#bsgis28-1",
        "images": []
    },
    {
        "title": "View Signal Values Using Port Value Labels",
        "introduction": "A port value label displays the value for a signal as a label that floats over the signal line in the block diagram, similar to a tooltip or a data tip. You can add and remove port value labels throughout your model before and during simulation. Use port value labels along with other visualization options to understand, analyze, and debug your model. Port value labels access signal values by probing the data buffers used in the simulation. In some cases, the output port that produces a signal does not correspond directly with a data buffer in the simulation. Adding and removing port value labels in your model does not modify the model in any way, even to make a signal value available for display. When you add a port value label to a signal with a value the software cannot access without modifying the model, the label displays text instead of the signal value to indicate that the signal value is not accessible from that point in the model. For details, see Understand Text Displayed in Port Value Labels. You can configure settings related to port value labels, including the font size and how frequently the value updates during active simulation. Port value labels and port value label settings are not saved as part of the model. For more information about options for viewing data, see Decide How to Visualize Simulation Data.",
        "chunks": [
            {
                "heading": "Add and Remove Port Value Labels",
                "content": "When the model is not running in simulation, you can add port value labels to one signal at a time, to a selection of multiple signals, or to all signals in the current block diagram.\n\nSelect one or more signals. Then, in the Simulink\u00c2\u00ae Toolstrip, on the Debug tab, in the Tools section, in the Port Values button group, click Show port value label on selected signal .Select one or more signals. Then, on the Signal tab, click Output Value Labels.Right-click a selection of one or more signals. Then, in the context menu, select Show Port Value Label On Selected Signal.\n\nDuring simulation, by default, clicking a signal line adds or removes the port value label for that signal line.\n\nIf the port value label is visible, clicking the signal line removes the port value label.If the port value label is not visible, clicking the signal line adds the port value label.\n\nYou can control this behavior using the Value Label Display Options dialog box. To disable the single-click option for adding and removing port value labels during simulation:\n\nOn the Debug tab, in the Tools section, in the Port Values button group, click the Remove all port value labels button arrow .Select Options.In the Value Label Display Options dialog box, in the Display Values section, clear Enable by default during simulation.\n\nAfter you add port value labels to one or more signal lines, the labels appear on the signal lines. When you add a port value label before simulation or while paused in simulation, the label initially shows no data yet because the block has not executed since you added the port value label.\n\nWhen you start, continue, or advance the simulation by stepping forward, the port value label updates to display the signal value if the action caused the block that produces the signal value to execute. For example, after clicking Step Forward, the port value label from the previous image updates to display the signal value.\n\nIf the port value label displays another message, such as inaccessible, that port and signal in your model might not support port value labels. For more information, see Understand Text Displayed in Port Value Labels.\n\nWhen you remove a port value label, the software does not retain the value that was displayed. If you immediately add the port value label again, the value shows no data yet until the block that produces the signal executes again.\n\nTo remove specific port value labels in your model:\n\nRight-click a selection of one or more signals.In the context menu, clear Show Port Value Label On Selected Signal.\n\nTo remove all port value labels in a model, on the Debug tab, in the Tools section, in the Port Values button group, click Remove all port value labels .\n\nYou cannot add or remove port value labels programmatically.\n\nThese examples show how to use port value labels to analyze and debug a model:\n\nStep Through Simulations Using the Simulink EditorDebug Simulation Using Signal BreakpointsDebug Simulation of Iterator Subsystem"
            },
            {
                "heading": "Configure Port Value Label Settings",
                "content": "You can use the Value Label Display Options dialog box to configure several options related to port value labels, including the font size for the value display, an approximate update rate for the value displayed, and the display format for numeric values.\n\nTo open the Value Label Display Options dialog box, On the Debug tab, in the Tools section, in the Port Values button group, click the Remove all port value labels button arrow . Then, select Options.\n\nThe settings that you configure apply for all port value labels in the model. Port value label settings are not saved with the model. You cannot configure port value label settings programmatically.\n\nThe Approximate refresh interval setting specifies approximately how frequently the software updates the value displayed in each port value label. Often, signal values update during simulation more quickly than you can read them. By default, the Approximate refresh interval for a model is one second. Instead of updating the port value label each time the output method for the source block executes, the software updates the value approximately once per second."
            },
            {
                "heading": "Configure Port Value Labels for Buses",
                "content": "When you add a port value label to a signal line for a bus or a message that carries its payload as a bus, by default, the port value label displays the names and values for all leaf elements of the bus. For example, consider this model that creates a bus hierarchy using output signals from source blocks.\n\nWhen you add a port value label to the bus main_bus, the port value label shows no data yet.\n\nAfter you start, continue, or advance the simulation by stepping forward, the port value label updates to display the names and values for all leaf elements in the bus.\n\nYou can select which bus elements to display on the port value label.\n\nClick the port value label for the bus.In the menu that appears, select the elements to display. Selecting a bus selects all of its elements.\n\nClick anywhere outside the menu to close the menu. The port value label shows only the selected elements with the text no data yet as the value for each element. Changing the selection of bus elements to display discards the values previously displayed in the port value label.\n\nWhen you simulate the model, the port value label updates to show the values for the selected bus elements.\n\nConsider using these options when working with bus hierarchies that contain many elements:\n\nSearch for bus elements by name using the text box at the top of the menu.To reduce the items displayed in the menu, select Show only selected.Only the elements selected for display on the port value label show in the menu. To select an additional element, search for the element by name. The search results appear in the menu, where you can select them.Collapse nodes in the tree that shows the bus hierarchy."
            },
            {
                "heading": "Understand Text Displayed in Port Value Labels",
                "content": "Port value labels might show one of several messages in place of signal values. For example, port value labels on some types of signals, such as function-call signals, display a message that indicates the signal type. In other cases, a port value label might display a message when a signal value is difficult to display in the available space or when the signal value is not accessible at that point in the model.\n\nThis table summarizes port value label messages that indicate the signal type.\n\nPort Value Label MessageSignal TypeactionAction signals that control execution of action subsystems, such as if-action subsystemsfcn-callFunction-call signals that control function-call subsystemsgroundGround block output signalnot a data signalSignal that does not contain valid data, such as the output signal for a block that is commented out[m*n]Two-dimensional signalInstead of the element values, the port value label shows the signal dimensions.\n\nThis table summarizes port value label messages that indicate the software can access the signal value but cannot display the value.\n\nPort Value Label MessageContext...The number of elements in the vector signal exceeds the maximum number of elements to display configured in the Value Label Display Options dialog box.click to add signalsThe port value label on a bus has no elements selected for display. To select bus elements, click the port value label.\n\nThis table summarizes port value label messages that indicate the software is unable to access the signal value.\n\nMessageContextno data yetSignal values are not available because the output method of the source block has not executed since the port value label was added.This value also appears for port value labels in model reference instances that do not have normal mode visibility.When you remove a port value label, the software does not retain the value that was displayed. If you immediately add the port value label again, the value shows this message until the block that produces the signal executes again.no messageInsufficient simulation data available.Try starting, continuing, or advancing the simulation.inaccessibleThe software cannot access the output port value due to the structure of the model.Port value labels show this message for signals that share memory in generated code when the Signal storage reuse (Simulink Coder) model configuration parameter is selected.not usedThe software cannot access the output port value because the output port value is not used in the simulation.removedThe software cannot access the output port value because the source block was removed by block reduction. For more information, see Block reduction.optimizedThe software cannot access the signal value due to optimization.Port value labels show this message for output signals of blocks that are: Optimized out of the simulation target for accelerator mode simulationsOptimized out of the compiled model because the Conditional input branch execution model configuration parameter is selectedOptimized out of the compiled model for another reason. unavailableThe software cannot access the output port value because the data is not available.Port value labels show this message when you step back to a simulation time that occurred before you added the port value label.\n\nWhen a port value label cannot access the value you want to view, sometimes you can change the model to make the signal value available. For example, in some cases the signal value becomes available when you:\n\nView the signal value using other visualization options, such as the Display block, Scope blocks, and scope viewers.Mark the signal for logging.Designate the signal as a test point using the Signal Properties dialog box."
            },
            {
                "heading": "Additional Considerations for Using Port Value Labels",
                "content": "The table summarizes considerations related to using port value labels based on several workflows and modeling patterns.\n\nWorkflow or Modeling PatternConsiderations for Using Port Value LabelsSimulation performanceSelecting Show When Hovering or Toggle When Clicked in the Value Label Display Options dialog box can slow down simulation.Accelerator and rapid accelerator simulationsPort value labels do not show values for output signals of blocks that are optimized out of the simulation target for accelerator mode.Port value labels are not supported for rapid accelerator simulations.Programmatic simulationPort value labels are not supported for simulations started using the sim function.Fixed-point dataPort value labels display the converted double value for signals with fixed-point data types.Model referencesPort value labels display data for the model reference instance with normal mode visibility. For more information, see Simulate Multiple Referenced Model Instances in Normal Mode.Subsystem input portsBlocks that represent input ports inside subsystems are often virtual. Port value labels on input ports inside subsystems show the output value of the block that drives the port when the block that represents the input port is virtual.Variant subsystemsPort value labels cannot access the data for ports of a subsystem that is inside a variant subsystem with no input signals.Disabled subsystemsWhether port value labels display data for output ports of disabled conditionally-executed subsystems depends on the Output when disabled parameter setting for the block that represents the conditionally-executed subsystem.Port value labels do not display data for output ports of enabled subsystems that are disabled.Signal Specification blockPort value labels show the output value for the block that drives the port.Merge blockPort value labels are not supported for signals that connect to input ports of a Merge block.Simscape\u00e2\u0084\u00a2Port value labels are not supported for physical signals.Model configuration parametersPort value labels show only values produced when the output method for a block executes. When you specify a refine factor for logging, port value labels do not show values produced to refine the logged data. For more information, see Refine factor.Port value labels might not be able to access data for some signals when you enable these parameters: Block reductionConditional input branch executionSignal storage reuse (Simulink Coder)"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/displaying-block-outputs.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/port-value-labels-example-on-x1-signal-value.png",
            "https://in.mathworks.com/help/simulink/ug/show-port-value-label-for-selected-signal-button.png",
            "https://in.mathworks.com/help/simulink/ug/remove-all-port-value-labels-button-arrow.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-labels-example-on-x1-no-data.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-labels-example-on-x1-signal-value.png",
            "https://in.mathworks.com/help/simulink/ug/remove-all-port-value-labels-button.png",
            "https://in.mathworks.com/help/simulink/ug/remove-all-port-value-labels-button-arrow.png",
            "https://in.mathworks.com/help/simulink/ug/busdemo-model-port-value-label-bus-element-selection.png",
            "https://in.mathworks.com/help/simulink/ug/new-port-value-label-on-bus.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-label-on-bus-all-values.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-display-bus-element-selection.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-display-bus-elements-no-values.png",
            "https://in.mathworks.com/help/simulink/ug/port-value-display-bus-element-values.png"
        ]
    },
    {
        "title": "Limitations with Multicore Programming in Simulink",
        "introduction": "The following limitations apply when partitioning a model for concurrent execution.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/simulink/ug/limitations-with-multicore-programming-in-simulink.html",
        "images": []
    },
    {
        "title": "S-Functions for Code Reuse",
        "introduction": "You can reuse the generated code for identical subsystems that occur in multiple instances within a model and across referenced models. For more information about code generation of subsystems for code reuse, see Generate Subsystem Code as Separate Function and Files.",
        "chunks": [
            {
                "heading": "S-Function Code Reuse Requirements",
                "content": "To use S-function for code reuse for a subsystem, the S-function must meet these requirements:\n\nThe S-function must be inlined.Code generated from the S-function must not use static variables.The S-function must initialize its pointer work vector in only mdlStart and not before.The S-function must not be a sink that logs data to the workspace.The S-function must register its parameters as run-time parameters in mdlSetWorkWidths. For this purpose, the S-function must not use ssWriteRTWParameters in its mdlRTW function.The S-function must not be a device driver.\n\nYour S-function must set the SS_OPTION_WORKS_WITH_CODE_REUSE flag in the ssSetOptions function. This flag indicates that your S-function meets the requirements for subsystem code reuse. If the flag is set and your S-function does not meet the requirements, the code generator does not generate a reusable function and you see a warning."
            },
            {
                "heading": "S-Functions Reused Across Models",
                "content": "Open Script\n\nYou can place S-functions inside reusable library subsystems. In the S-function file, set both of these flags:\n\nSS_OPTION_WORKS_WITH_CODE_REUSE flag in the ssSetOptions function ssSetSupportedForCodeReuseAcrossModels set to 1 or true\n\nIf you use the legacy_code tool to generate your S-function, the S-function option supportCodeReuseAcrossModels specifies code reuse across models for the subsystem that contains the S-function.\n\nConfigure the S-function for code reuse across models only if the S-function does not access any model-specific data structures. This configuration is necessary because the generated code in _sharedutils folder is compiled separately from the generated code in model_ert_rtw folder. The reusable library subsystem code generated in the _sharedutils folder does not have access to types and macros that are declared in model.h. The reusable library subsystem code must be independent. For more information, see Generate Reusable Code from Library Subsystems Shared Across Models.\n\nIf your S-function uses custom functions defined in your external header files, add the LibAddtoSystemCustomIncludes(system, incFileName) function in your S-function's TLC file. For example, when you add LibAddtoSystemCustomIncludes(\"company_math.h\") in your .tlc file, the reusable library subsystem code in the _sharedutils folder includes the #company_math.h header file.\n\n1. Open example model SFunctionForCodeReuse. This example model uses two instances of the reusable library subsystem SFunctionForCodeReuseLibrary. The S-function sfun_mySrc inside the reusable library subsystem uses external files doubleIt.c and doubleIt.h.SFunctionForCodeReuse; 2. Generate the S-function code by using legacy code tool. Use these commands in your MATLAB Command window:def = legacy_code('initialize'); def.SFunctionName = 'sfun_mySrc'; def.SourceFiles = {'doubleIt.c'}; def.HeaderFiles = {'doubleIt.h'}; def.OutputFcnSpec = 'double y1 = doubleIt(double u1)'; 3. Specify the S-function for code reuse:def.Options.supportCodeReuseAcrossModels = true; 4. Generate the S-function code TLC block file. Then compile the S-function.legacy_code('sfcn_tlc_generate',def); legacy_code('sfcn_cmex_generate', def); legacy_code('compile', def); ### Start Compiling sfun_mySrc mex('-I/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex43633418', '-c', '-outdir', '/tmp/Bdoc24b_2855429_911544/tpe888b39b_0a15_422d_92a1_6e037dcf9edf', '/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex43633418/doubleIt.c') Building with 'gcc'. MEX completed successfully. mex('sfun_mySrc.c', '-I/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex43633418', '/tmp/Bdoc24b_2855429_911544/tpe888b39b_0a15_422d_92a1_6e037dcf9edf/doubleIt.o') Building with 'gcc'. MEX completed successfully. ### Finish Compiling sfun_mySrc ### Exit 5. The code generator creates the S-function file sfun_mySrc.c and its TLC file sfun_mySrc.tlc in your MATLAB working folder. In the sfun_mySrc.c file, the code generator adds these specifications:file = fullfile('sfun_mySrc.c'); coder.example.extractLines(file,'* All options have the form SS_OPTION_<name>', ... 'ssSetSupportedForCodeReuseAcrossModels(S, 1);',1,1); * All options have the form SS_OPTION_<name> and are documented in * matlabroot/simulink/include/simstruc.h. The options should be * bitwise or'd together as in * ssSetOptions(S, (SS_OPTION_name1 | SS_OPTION_name2)) */ ssSetOptions(S, SS_OPTION_USE_TLC_WITH_ACCELERATOR | SS_OPTION_CAN_BE_CALLED_CONDITIONALLY | SS_OPTION_EXCEPTION_FREE_CODE | SS_OPTION_WORKS_WITH_CODE_REUSE | SS_OPTION_SFUNCTION_INLINED_FOR_RTW | SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME ); ssSetSupportedForCodeReuseAcrossModels(S, 1); In the sfun_mySrc.c, the SS_OPTION_WORKS_WITH_CODE_REUSE flag is set in the ssSetOptions function and ssSetSupportedForCodeReuseAcrossModels is set to true.6. On the Simulink\u00c2\u00ae toolstrip, open the Embedded Coder or Simulink Coder app.7. Generate code for the model. On the C Code tab, click Build.evalc('slbuild(''SFunctionForCodeReuse'')'); The code generator produces a reusable function that can be reused across models in the _sharedutils folder. Models in a model reference hierarchy share this _sharedutils folder to reuse code. For this example, the reusable function is generated in the slprj/grt/_sharedutils/sfunc.c file:file = fullfile('slprj','grt','_sharedutils','sfunc.c'); coder.example.extractLines(file,'Output and update for atomic system', ... 'rtb_sfun_mySrc',1,1); % /* Output and update for atomic system: 'ReusableSubsystem' ('SFunctionForCodeReuseLibrary:60') */ void sfunc(real_T rtu_In1, B_sfunc_T *localB, DW_sfunc_T *localDW) { /* local block i/o variables */ real_T rtb_sfun_mySrc;"
            },
            {
                "heading": "S-Functions Reused Within a Model",
                "content": "Open Script\n\nBy default, S-functions inside a subsystem are not configured for code reuse within a model. You can specify the S-functions inside a subsystem for code reuse within a model. In the S-function file, set the SS_OPTION_WORKS_WITH_CODE_REUSE flag in the ssSetOptions function. This flag indicates that your S-function meets the requirements for subsystem code reuse and is configured for code reuse. If the flag is set and your S-function does not meet the requirements, the code generator does not generate a reusable function and you see a warning.\n\n1. For the example model SFunctionForCodeReuse, generate the S-function code by using legacy code tool. Do not include the S-function option supportCodeReuseAcrossModels. Use these commands in your MATLAB Command window:def = legacy_code('initialize'); def.SFunctionName = 'sfun_mySrc'; def.SourceFiles = {'doubleIt.c'}; def.HeaderFiles = {'doubleIt.h'}; def.OutputFcnSpec = 'double y1 = doubleIt(double u1)'; 2. Generate the S-function code TLC block file. Then compile the S-function.legacy_code('sfcn_tlc_generate',def); legacy_code('sfcn_cmex_generate', def); legacy_code('compile', def); ### Start Compiling sfun_mySrc mex('-I/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex69241103', '-c', '-outdir', '/tmp/Bdoc24b_2855429_911544/tpf6fe38c4_d50e_40dd_84b5_f356c8ce506b', '/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex69241103/doubleIt.c') Building with 'gcc'. MEX completed successfully. mex('sfun_mySrc.c', '-I/tmp/Bdoc24b_2855429_911544/tpcd6c5b7c/simulinkcoder-ex69241103', '/tmp/Bdoc24b_2855429_911544/tpf6fe38c4_d50e_40dd_84b5_f356c8ce506b/doubleIt.o') Building with 'gcc'. MEX completed successfully. ### Finish Compiling sfun_mySrc ### Exit 3. The code generator creates the S-function file sfun_mySrc.c and its TLC file sfun_mySrc.tlc in your MATLAB working folder.file = fullfile('sfun_mySrc.c'); coder.example.extractLines(file,'* All options have the form SS_OPTION_<name>', ... 'SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME',1,1); * All options have the form SS_OPTION_<name> and are documented in * matlabroot/simulink/include/simstruc.h. The options should be * bitwise or'd together as in * ssSetOptions(S, (SS_OPTION_name1 | SS_OPTION_name2)) */ ssSetOptions(S, SS_OPTION_USE_TLC_WITH_ACCELERATOR | SS_OPTION_CAN_BE_CALLED_CONDITIONALLY | SS_OPTION_EXCEPTION_FREE_CODE | SS_OPTION_WORKS_WITH_CODE_REUSE | SS_OPTION_SFUNCTION_INLINED_FOR_RTW | SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME In the sfun_mySrc.c file, the code generator adds SS_OPTION_WORKS_WITH_CODE_REUSE flag in the ssSetOptions function by default but does not include the ssSetSupportedForCodeReuseAcrossModels specification that prevents the S-function from being reused across models.4. On the Simulink toolstrip, open the Embedded Coder or Simulink Coder app.5. Generate code for the model. On the C Code tab, click Build.evalc('slbuild(''SFunctionForCodeReuse'')'); The code generator produces a reusable function for the subsystem in the SFunctionForCodeReuse.c file, which is outside the _sharedutils folder. This code can be reused within the model but not across the model reference hierarchy:file = fullfile('SFunctionForCodeReuse_grt_rtw','SFunctionForCodeReuse.c'); coder.example.extractLines(file,'void sfunc', ... 'localDW->UnitDelay_DSTATE = rtb_sfun_mySrc;',1,1); % void sfunc_Init(DW_sfunc_T *localDW) { /* InitializeConditions for UnitDelay: '<S1>/Unit Delay' */ localDW->UnitDelay_DSTATE = 0.0; } /* * Output and update for atomic system: * '<Root>/ReusableSubsystem' * '<Root>/ReusableSubsystem1' */ void sfunc(real_T rtu_In1, B_sfunc_T *localB, DW_sfunc_T *localDW) { /* local block i/o variables */ real_T rtb_sfun_mySrc; /* UnitDelay: '<S1>/Unit Delay' */ localB->UnitDelay = localDW->UnitDelay_DSTATE; /* S-Function (sfun_mySrc): '<S1>/sfun_mySrc' */ rtb_sfun_mySrc = doubleIt(rtu_In1); /* Update for UnitDelay: '<S1>/Unit Delay' */ localDW->UnitDelay_DSTATE = rtb_sfun_mySrc;"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/s-functions-for-code-reuse.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/SFunctionsReusedAcrossModelsExample_01.png"
        ]
    },
    {
        "title": "Highlight Signal Sources and Destinations",
        "introduction": "You can highlight a signal and its source or destination blocks in Simulink\u00c2\u00ae, and then remove the highlighting when it is not required any more. Signal highlighting crosses subsystem and model reference boundaries, allowing you to trace a signal across multiple subsystem levels. If a signal is composite, all source or destination blocks are highlighted. For more information on composite signals, see Composite Interface Guidelines. To continue the trace towards the source or destination of the signal, use the left and right arrow keys of your keyboard, respectively.",
        "chunks": [
            {
                "heading": "Highlight Signal Source",
                "content": "To begin a trace to the source blocks of a signal, select the Highlight Signal to Source option from the context menu for the signal. The badge identifies the start of the trace. This option highlights:\n\nAll branches of the signal anywhere in the modelAll virtual blocks through which the signal passesThe nonvirtual blocks that write the value of the signal\n\nTo continue tracing towards the source of the signal, press the Left arrow key."
            },
            {
                "heading": "Highlight Signal Destination",
                "content": "To begin a trace to the destination blocks of a signal, select the Highlight Signal to Destination option from the context menu for the signal. Press the Right arrow key to move the trace towards the final destination. The badge identifies the start of the trace. This option highlights:\n\nAll branches of the signal anywhere in the modelAll virtual blocks through which the signal passesThe nonvirtual blocks that read the value of the signalThe signal and destination block for all blocks that are duplicates of the Inport block for the line that you select\n\nIn this example, the selected trace shows a path of the signal from the Stick Input to the Elevator Command in the Controller subsystem of the f14 model.\n\nIn the next example, selecting the signal from In2 and choosing the Highlight Signal to Destination option highlights the signal and destination block for In2 and In1, because In1 and In2 are duplicate Inport blocks."
            },
            {
                "heading": "Choose the Path of a Trace",
                "content": "In some situations, a signal trace can take multiple viable paths in the next segment of the trace. This can be seen when a signal is combined or split through a Mux or Demux block, or if it is branched out as an input to another block. In such cases, the options are highlighted in blue and can be cycled using the Up and Down arrow keys on the keyboard. Once you have highlighted the block to which you would like to move, proceed as normal.\n\nIn the figure above, the trace to source has reached the Sum block where it can take one of three possible paths. The first option to Gain Zd is highlighted in blue."
            },
            {
                "heading": "Trace a Signal to and from Subsystems",
                "content": "When the trace reaches a subsystem, it does not automatically trace in. Instead, the trace highlights the target subsystem and you are able to see a preview of the trace within the subsystem.\n\nIn this example, the selected signal trace to destination has reached the Controller subsystem of the f14 model. You can see that the contents of the subsystem are visible and the next segment of the trace is highlighted within the preview.\n\nWhen the trace comes out of a subsystem, the subsystem preview also displays the path of the trace inside it. The next example shows the path of a trace through the Aircraft Dynamics Model subsystem from the input wGust to vertical velocity w output.\n\nNoteYou cannot jump over a subsystem or a referenced model in your trace. You need to trace the signal path through them."
            },
            {
                "heading": "Show All Possible Paths of a Trace",
                "content": "To highlight all possible paths a trace can take, press Ctrl key along with the Left (towards source) or the Right (towards destination) key. You can continue to trace as before.\n\nTo clear the highlighting, simultaneously press the Ctrl key and the arrow key in the direction opposite to the trace."
            },
            {
                "heading": "Display Port Values Along a Trace",
                "content": "After you trace the path of a signal, press the L key to display the values of a signal at the output port of each block.\n\nIf you highlight all the possible paths of the trace as described in Show All Possible Paths of a Trace, press the Ctrl + L to view the signal values at all the output ports."
            },
            {
                "heading": "Remove Highlighting",
                "content": "To remove all highlighting, right-click the model, and then select Remove Highlighting, or, on the Signal tab, click Remove Trace. You can also press Ctrl+Shift+H or click the icon at the top right corner of the editor.\n\nTo back up a trace, press the arrow key opposite to the original intent of the trace. For example, if you would like to back up a trace to the destination of the signal, press the left arrow key. To back up a trace to the source of a signal, press the right arrow key."
            },
            {
                "heading": "Resolve Incomplete Highlighting to Library Blocks",
                "content": "If the path from a source block or to a destination block includes an unresolved reference to a library block, the highlighting options highlight the path from or to the library block, respectively. To display the complete path, press Ctrl+D to update the diagram. The diagram update resolves all library references and displays the complete path to a destination block or from a source block."
            },
            {
                "heading": "Signal Highlighting in Variant Systems",
                "content": "Tracing a signal that passes through inline variant blocks such as Variant Source and Variant Sink highlights the path of the active variant choice. In this example, the selected signal trace to its source shows the path of the active variant passing through the Variant Source2 block.\n\nFor a Variant Subsystem block, the trace highlights the active choice within the subsystem by default.\n\nIf the Variant activation time parameter of the Variant Subsystem block is set to code compile, the trace highlights both the active and inactive choices within the subsystem."
            },
            {
                "heading": "Limitations",
                "content": "The signal tracing tool has the following limitations in its usage:\n\nThe signal trace does not preserve bus information when tracing into or out of a referenced model.Tracing past a Goto block changes the active level to that containing the matching From block. However, this does not guarantee that the matching From block is the active block if there are other valid blocks at the same level.Signal tracing is unsupported by certain blocks. Unsupported blocks are blocks where: You cannot trace into them to highlight their contents. Examples of such blocks include but are not limited to Stateflow\u00c2\u00ae charts, Simscape\u00e2\u0084\u00a2 subsystems, and function blocks,.You cannot cross them and continue tracing (e.g. Simscape blocks). The styling of the signal does not update with modifications to the model when signal tracing is enabled.The operation to Show All Possible Paths of a Trace does not traverse through referenced models in the same way as it does subsystems. Referenced models are treated as nonvirtual blocks and the impact region will not highlight their contents."
            },
            {
                "heading": "Bus Element Tracing and Highlighting",
                "content": "To trace the source or destination of a bus element using the Signal Hierarchy Viewer:\n\nSelect a bus in your model.In the Simulink Toolstrip, on the Signal tab, select Signal Hierarchy.The Signal Hierarchy Viewer opens, showing the signal hierarchy for the selected bus.In the Signal Hierarchy Viewer, select the element name.In the Signal Hierarchy Viewer, click Source or Destination to highlight source blocks or destination blocks, respectively.\n\nFor example, this figure traces a bus element named sine to its source blocks. The tracing highlights the currently selected bus, a Bus Assignment block, two Bus Creator blocks, a Sine Wave block, and the intermediary signals.\n\nThe Signal Hierarchy Viewer displays the signal that is currently selected. If you select a different signal line while the Signal Hierarchy Viewer is open, the Signal Hierarchy Viewer updates to the corresponding selection. If you do not select a signal, the Signal Hierarchy Viewer is blank. Thus, tracing the signal via the Signal Hierarchy Viewer requires at least one signal line selected.\n\nFor more information, see Signal Hierarchy Viewer."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/displaying-signal-sources-and-destinations.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/sourcebadge.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_to_src_new.png",
            "https://in.mathworks.com/help/simulink/ug/destinationbadge.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_to_dest_new.png",
            "https://in.mathworks.com/help/simulink/ug/duplicatedestinationhighlighting-callouts.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_options.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_subsystem.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_subsystem_exit.png",
            "https://in.mathworks.com/help/simulink/ug/trace_all.png",
            "https://in.mathworks.com/help/simulink/ug/trace_pvd.png",
            "https://in.mathworks.com/help/simulink/ug/trace_all_all_port_values.png",
            "https://in.mathworks.com/help/simulink/ug/highlight_exit.png",
            "https://in.mathworks.com/help/simulink/ug/trace_variantsource_block.png",
            "https://in.mathworks.com/help/simulink/ug/trace_variantsubsystem_block.png",
            "https://in.mathworks.com/help/simulink/ug/trace_variantsubsystem_codecompile.png",
            "https://in.mathworks.com/help/simulink/ug/bus_tracing_highlight.png"
        ]
    },
    {
        "title": "Troubleshoot Model Upgrade for R2020b",
        "introduction": "When building a pre-R2020b Simulink Real-Time models in R2020b, build errors occur. Some of the blocks in the model have the label Obsolete Simulink Real-Time Block. Troubleshoot System Upgrade for R2020b",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "For R2020b, you must upgrade the Simulink Real-Time model. A model Upgrade Advisor check is available to support this upgrade."
            },
            {
                "heading": "Try This Workaround",
                "content": "To upgrade your model for Simulink Real-Time R2020b features, use this software upgrade process:\n\nInstall Simulink Real-Time and other required products.Install the Simulink Real-Time Target Support Package by using the MATLAB Add-Ons menu.\u00e2\u0080\u008bInstall the Speedgoat I/O Blockset. Go to the Speedgoat website.Upgrade the target machine software. See Troubleshoot System Upgrade for R2020b.Open a R2020b or earlier Simulink Real-Time model.Run the Upgrade Advisor. On the Modeling tab, select Model Advisor > Upgrade Advisor.In the Upgrade Advisor dialog box, select Check model for upgradable Simulink Real-Time features. Click the Run This Check button. The advisor lists the upgrades that it can apply and the upgrades that require manual changes.After the check, click the Upgrade button. The advisor upgrades the model by applying all nonmanual changes."
            },
            {
                "heading": "Apply Manual Changes",
                "content": "When the Upgrade Advisor encounters model issues that it cannot resolve by using automated changes, the Upgrade Advisor reports these as Warning: Some of the features require manual changes. It is a good practice to copy the text of these warnings and save it for reference as you apply changes to your model."
            },
            {
                "heading": "Apply Speedgoat Utilities",
                "content": "In R2020b, Speedgoat\u00c2\u00ae software provides support for configuring interrupts and Ethernet communications.\n\nTo configure model interrupts, use a single block from the Speedgoat I/O Blockset. You can use this block for asynchronous subsystems or for triggering the base rate of the model. The list of available interrupt sources reflects the Speedgoat I/O Blockset blocks configured in the model. For more information see the block documentation in speedgoatlib_utilities.\n\nTo configure additional Ethernet ports on the target machine, the Speedgoat I/O Blockset provides a tool to configure these Ethernet ports. The configuration is specific to the target machine and reflects the labeling on the front plates of the target machine. For more information, in the MATLAB Command Window, type:\n\nspeedgoat.configureEthernet"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-model-upgrade-to-r2020b.html",
        "images": []
    },
    {
        "title": "S-Functions for Multirate Multitasking Environments",
        "introduction": "",
        "chunks": [
            {
                "heading": "About S-Functions for Multirate Multitasking Environments",
                "content": "S-functions can be used in models with multiple sample rates and deployed in multitasking target environments. Likewise, S-functions themselves can have multiple rates at which they operate. The code generator produces code for multirate multitasking models using an approach called rate grouping. In code generated for ERT-based targets, rate grouping generates separate model_step functions for the base rate task and each subrate task in the model. Although rate grouping is a code generation feature found in ERT targets only, your S-functions can use it in other contexts when you code them as explained below."
            },
            {
                "heading": "Rate Grouping Support in S-Functions",
                "content": "To take advantage of rate grouping, you must inline your multirate S-functions if you have not done so. You need to follow certain Target Language Compiler protocols to exploit rate grouping. Coding TLC to exploit rate grouping does not prevent your inlined S-functions from functioning properly in GRT. Likewise, your inlined S-functions will still generate valid ERT code even if you do not make them rate-grouping-compliant. If you do so, however, they will generate more efficient code for multirate models.\n\nFor instructions and examples of Target Language Compiler code illustrating how to create and upgrade S-functions to generate rate-grouping-compliant code, see Rate Grouping Compliance and Compatibility Issues (Embedded Coder).\n\nFor each multirate S-function that is not rate grouping-compliant, the code generator issues the following warning when you build:\n\nWarning: Simulink Coder: Code of output function for multirate block '<Root>/S-Function' is guarded by sample hit checks rather than being rate grouped. This will generate the same code for all rates used by the block, possibly generating dead code. To avoid dead code, you must update the TLC file for the block.\n\nYou will also find a comment such as the following in code generated for each noncompliant S-function:\n\n/* Because the output function of multirate block \u00c2 \u00c2 \u00c2 <Root>/S-Function is not rate grouped, \u00c2 \u00c2 \u00c2 the following code might contain unreachable blocks of code. \u00c2 \u00c2 \u00c2 To avoid this, you must update your block TLC file. */\n\nThe words \u00e2\u0080\u009cupdate function\u00e2\u0080\u009d are substituted for \u00e2\u0080\u009coutput function\u00e2\u0080\u009d in these warnings."
            },
            {
                "heading": "Create Multitasking, Multirate, Port-Based Sample Time S-Functions",
                "content": "The following instructions show how to support both data determinism and data integrity in multirate S-functions. They do not cover cases where there is no determinism nor integrity. Support for frame-based processing does not affect the requirements.\n\nNoteThe slow rates must be multiples of the fastest rate. The instructions do not apply when two rates being interfaced are not multiples or when the rates are not periodic."
            },
            {
                "heading": "Rules for Properly Handling Fast-to-Slow Transitions",
                "content": "The rules that multirate S-functions should observe for inputs are\n\nThe input should only be read at the rate that is associated with the input port sample time. Generally, the input data is written to DWork, and the DWork can then be accessed at the slower (downstream) rate.\n\nThe input can be read at every sample hit of the input rate and written into DWork memory, but this DWork memory cannot then be directly accessed by the slower rate. DWork memory that will be read by the slow rate must only be written by the fast rate when there is a special sample hit. A special sample hit occurs when both this input port rate and rate to which it is interfacing have a hit. Depending on their requirements and design, algorithms can process the data in several locations.\n\nThe rules that multirate S-functions should observe for outputs are\n\nThe output should not be written by a rate other than the rate assigned to the output port, except in the optimized case described below. The output should always be written when the sample rate of the output port has a hit.\n\nIf these conditions are met, the S-Function block can specify that the input port and output port can both be made local and reusable.\n\nYou can include an optimization when little or no processing needs to be done on the data. In such cases, the input rate code can directly write to the output (instead of by using DWork) when there is a special sample hit. If you do this, however, you must declare the outport port to be global and not reusable. This optimization results in one less memcpy but does introduce nonuniform processing requirements on the faster rate.\n\nWhether you use this optimization or not, the most recent input data, as seen by the slower rate, is the value when both the faster and slower rate had their hits (and possible earlier input data as well, depending on the algorithm). Subsequent steps by the faster rate and the associated input data updates are not seen by the slower rate until the next hit for the slow rate occurs."
            },
            {
                "heading": "Pseudocode Examples of Fast-to-Slow Rate Transition",
                "content": "The pseudocode below abstracts how you should write your C MEX code to handle fast-to-slow transitions, illustrating with an input rate of 0.1 second driving an output rate of one second. A similar approach can be taken when inlining the code. The block has following characteristics:\n\nFile: sfun_multirate_zoh.c, Equation: y = u(tslow)Input: local and reusableOutput: local and reusableDirectFeedthrough: yesOutputFcn if (ssIsSampleHit(\".1\")) { if (ssIsSepcialSampleHit(\"1\")) { DWork = u; } } if (ssIsSampleHit(\"1\")) { y = DWork; }\n\nAn alternative, slightly optimized approach for simple algorithms:\n\nInput: local and reusableOutput: global and not reusable because it needs to persist between special sample hitsDirectFeedthrough: yesOutputFcn if (ssIsSampleHit(\".1\")) { if (ssIsSpecialSampleHit(\"1\")) { y = u; } }\n\nExample adding a simple algorithm:\n\nFile: sfun_multirate_avg.c; Equation: y = average(u)Input: local and reusableOutput: local and reusableDirectFeedthrough: yes(Assume DWork[0:10] and DWork[mycounter] are initialized to zero)OutputFcn if (ssIsSampleHit(\".1\")) { /* In general, processing on 'u' could be done here, it runs on every hit of the fast rate. */ DWork[DWork[mycounter]++] = u; if (ssIsSpecialSampleHit(\"1\")) { /* In general, processing on DWork[0:10] can be done here, but it does cause the faster rate to have nonuniform processing requirements (every 10th hit, more code needs to be run).*/ DWork[10] = sum(DWork[0:9])/10; DWork[mycounter] = 0; } } if (ssIsSampleHit(\"1\")) { /* Processing on DWork[10] can be done here before outputing. This code runs on every hit of the slower task. */ y = DWork[10]; }"
            },
            {
                "heading": "Rules for Properly Handling Slow-to-Fast Transitions",
                "content": "When output rates are faster than input rates, input should only be read at the rate that is associated with the input port sample time, observing the following rules:\n\nAlways read input from the update function.Use no special sample hit checks when reading input.Write the input to a DWork.When there is a special sample hit between the rates, copy the DWork into a second DWork in the output function.Write the second DWork to the output at every hit of the output sample rate.\n\nThe block can request that the input port be made local but it cannot be set to reusable. The output port can be set to local and reusable.\n\nAs in the fast-to-slow transition case, the input should not be read by a rate other than the one assigned to the input port. Similarly, the output should not be written to at a rate other than the rate assigned to the output port.\n\nAn optimization can be made when the algorithm being implemented is only required to run at the slow rate. In such cases, you use only one DWork. The input still writes to the DWork in the update function. When there is a special sample hit between the rates, the output function copies the same DWork directly to the output. You must set the output port to be global and not reusable in this case. This optimization results in one less memcpy operation per special sample hit.\n\nIn either case, the data that the fast rate computations operate on is always delayed, that is, the data is from the previous step of the slow rate code."
            },
            {
                "heading": "Pseudocode Examples of Slow-to-Fast Rate Transition",
                "content": "The pseudocode below abstracts what your S-function needs to do to handle slow-to-fast transitions, illustrating with an input rate of one second driving an output rate of 0.1 second. The block has following characteristics:\n\nFile: sfun_multirate_delay.c, Equation: y = u(tslow-1)Input: Set to local, will be local if output/update are combined (ERT) otherwise will be global. Set to not reusable because input needs to be preserved until the update function runs.Output: local and reusableDirectFeedthrough: noOutputFcn if (ssIsSampleHit(\".1\") { if (ssIsSpecialSampleHit(\"1\") { DWork[1] = DWork[0]; } y = DWork[1]; } UpdateFcn if (ssIsSampleHit(\"1\")) { DWork[0] = u; }\n\nAn alternative, optimized approach can be used by some algorithms:\n\nInput: Set to local, will be local if output/update are combined (ERT) otherwise will be global. Set to not reusable because input needs to be preserved until the update function runs.Output: global and not reusable because it needs to persist between special sample hits. DirectFeedthrough: noOutputFcn if (ssIsSampleHit(\".1\") { if (ssIsSpecialSampleHit(\"1\") { y = DWork; } } UpdateFcn if (ssIsSampleHit(\"1\")) { DWork = u; }\n\nExample adding a simple algorithm:\n\nFile: sfun_multirate_modulate.c, Equation: y = sin(tfast) + u(tslow-1)Input: Set to local, will be local if output/update are combined (an ERT feature) otherwise will be global. Set to not reusable because input needs to be preserved until the update function runs.Output: local and reusableDirectFeedthrough: noOutputFcn if (ssIsSampleHit(\".1\") { if (ssIsSpecialSampleHit(\"1\") { /* Processing not likely to be done here. It causes * the faster rate to have nonuniform processing * requirements (every 10th hit, more code needs to * be run).*/ DWork[1] = DWork[0]; } /* Processing done at fast rate */ y = sin(ssGetTaskTime(\".1\")) + DWork[1]; } UpdateFcn if (ssIsSampleHit(\"1\")) { /* Processing on 'u' can be done here. There is a delay of one slow rate period before the fast rate sees it.*/ DWork[0] = u;}"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/s-functions-for-multirate-multitasking-environments.html",
        "images": []
    },
    {
        "title": "Troubleshoot System Upgrade for R2020b",
        "introduction": "After upgrading Simulink Real-Time software to R2020b and installing the Simulink Real-Time Target Support Package, the system cannot download real-time applications to the target computer.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "The upgrade for release R2020b requires software upgrades to the Simulink Real-Time software and the Speedgoat Target Machine software."
            },
            {
                "heading": "Try This Workaround",
                "content": "In R2020b, the change to a 64-bit POSIX compliant real-time operating system on the target computer requires a software upgrade for your Speedgoat\u00c2\u00ae real-time target machine. For this upgrade, the Speedgoat I/O Blockset provides an interactive tool. To retain compatibility with previous versions of MATLAB, you can choose to upgrade the target machine to a dual-boot system where you can select the operating system at startup. Or, you can upgrade the target machine to use only the new operating system. For the upgrade, you need a USB drive and the target machine needs a keyboard and a monitor.\n\nTo upgrade your software:\n\nInstall Simulink Real-Time and other required products.Install the Simulink Real-Time Target Support Package by using the MATLAB Add-Ons menu.\u00e2\u0080\u008bInstall the Speedgoat I/O Blockset. Go to the Speedgoat customer portal.To start the target machine upgrade, in the MATLAB Command Window, type:speedgoat.migrateTarget\n\nFor more information, go to the Speedgoat website."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-system-upgrade-to-r2020b.html",
        "images": []
    },
    {
        "title": "Set Up and Configure Simulink Real-Time",
        "introduction": "For this tutorial, you must have this configuration: Targets",
        "chunks": [
            {
                "heading": "Configure Link Between Development and Target Computers",
                "content": "To run a Simulink Real-Time model on a target computer, you must connect the development and target computers in a network.\n\nThe target network setting values are representative only. Consult your network administrator for actual values. For more information about network configuration, see Target Computer Settings.\n\nSelect the Simulink Real-Time template from the Simulink start page and create the exampleSlrtApp model. In the MATLAB Command Window, type:simulinkIn the Simulink Editor, open the Simulink Real-Time Explorer. In the Real-Time tab, from the targets list, click SLRT Explorer.From the Target Computers list, select the target computer node.To add a node representing another target computer, in the Targets pane, click the Add target button.To remove a node representing a target computer, select the node and click the Remove target button.If not previously configured, select the Target Configuration tab and set the target computer IP address for the target computer definition by using the Change IP Address button. For example, Speedgoat target machines are preconfigured to address 192.168.7.5. Check that you have started the target computer and wait until the target computer boots the RTOS.To connect Simulink Real-Time to the target computer, click Disconnected to toggle to Connected.\n\nNoteIf Simulink Real-Time reports a connection issue, contact MathWorks\u00c2\u00ae support. For more information, see the MathWorks Support website MathWorks Help Center website."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/gs/set-up-and-configure-simulink-real-time.html",
        "images": []
    },
    {
        "title": "Configure Your Model for Concurrent Execution",
        "introduction": "Follow these steps to configure your Simulink\u00c2\u00ae model to take advantage of concurrent execution. Once you have a model that executes concurrently on your computer, you can further configure your model in the following ways:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/simulink/ug/configure-your-model.html",
        "images": []
    },
    {
        "title": "C Data Code Interface Configuration for Model Interface Elements",
        "introduction": "Configure a model to use a data code interface if you are deploying C code as an application. Code generated for application deployment is optimized to a specific scheduler (single-tasking, rate-monotonic, or concurrent) based on your model configuration. Model Code Interfaces (Embedded Coder) lists modeling elements that you can use to represent interfaces for interacting with target environment resources. To configure the modeling elements for code generation, in the Code Mappings editor or by using the code mappings programming interface (coder.mapping.api.CodeMapping), you map model interface elements to code definitions. When configuring a data code interface, you can: Code Mappings Editor \u00e2\u0080\u0093 C | coder.mapping.api.CodeMapping",
        "chunks": [
            {
                "heading": "Migration",
                "content": "When you open a model created in a release before R2020b, Simulink\u00c2\u00ae migrates code definitions, such as embedded signal and parameter objects in the model workspace, to the model code mappings.\n\nFor a model configured to use an ERT-based system target file for code generation, if necessary, as part of the migration, Simulink configures the Embedded Coder Dictionary that the model uses. When you save the model, the code mappings are saved as part of the model.\n\nFor more information, such as effects of migration and what to consider before migrating, see Migration of Model Data Configurations to Code Mappings."
            },
            {
                "heading": "Code Definitions",
                "content": "For a data code interface configuration, code definitions include storage classes. A storage class defines properties, such as appearance and location, that the code generator uses when producing code for the associated data.\n\nThe code generator provides predefined code definitions for data elements. If you have Embedded Coder\u00c2\u00ae, you can use the Embedded Coder Dictionary to create and share code definitions, for example, to standardize code that you generate from multiple models or to create definitions for different application run-time environments. Creating custom definitions enables you to achieve code generation objectives that predefined definitions cannot satisfy. For data elements, you also have the option of creating code definitions created in packages by using Embedded Coder Custom Storage Class Designer.\n\nCode definitions appear in the Code Mappings editor and are accessible by using the code mappings programming interface."
            },
            {
                "heading": "Data Interface Code Mapping Options",
                "content": "Associate elements of a model that represent interfaces with code definitions by using the Code Mappings editor or the code mappings programming interface. The code generator uses the mapped code definitions to determine what the generated interface code should look like and how the code should be packaged.\n\nSimplify the effort of configuring code interfaces by specifying default configurations for the code generator. For data interface configurations, you specify default configurations in the Code Mappings editor on the Data Defaults and Function Defaults tabs or by calling the setDataDefault and setFunctionDefault functions. You can let the code generator establish the default configuration by setting the storage class or function customization template to Default or you can specify a named storage class or function customization template. When you specify Default, the code generator determines how data elements and function prototypes appear in the generated code. When you specify a named storage class or function customization template the code generator applies the settings specified for that code definition.\n\nFor individual model elements, you can override the default category code configuration setting. Select the tab that corresponds to the element category or call the corresponding element category setElementCategory function (for example, setInport or setState). For an individual element, you have three configuration options:\n\nLet the code generator handle the configuration. For data elements, select or specify Auto. For Auto the data element is subject to code generation optimizations, which can eliminate the element from the code or change the representation of the element. If optimizations do not eliminate the data element, the element acquires the default configuration for the corresponding data category. If a default is not configured for the category (on the Data Defaults tab, category is set to Default), the element appears as a field of a standard data structure in the generated code.For functions, select or specify Default. Map the data or function element to the code definition that is configured as the default for the relevant data or function element category for this model. Specify Model default: storage class or Model default: function-template. Map the data or function element to a named storage class or function customization template that is not labeled as the model default.\n\nThis figure summarizes the relationship between default and individual configuration settings and available choices."
            },
            {
                "heading": "Data Default Configurations",
                "content": "Reduce the effort of preparing a model for C code generation by specifying default configurations for categories of data elements, for example inports or model workspace parameters, across a model. Applying default configurations can save time and reduce the risk of introducing errors in code, especially for larger models and models from which you generate multi-instance code.\n\nDefault configurations apply throughout a model, excluding referenced models. Simulink saves a separate set of code mappings as part of each model in a model reference hierarchy.\n\nIf a model includes a significant number of elements of a given category (for example, more than 10), it is more efficient to configure the category by using a default setting, and then override that setting for special cases.\n\nThe default settings can help you to reduce manual data entry.\n\nAs you add blocks to a model, new data elements inherit the default settings.To change code generation settings for many data elements at once, make the changes in one place\u00e2\u0080\u0094the default settings.For efficiency, use naming rules as you make changes elsewhere in the model.\n\nYou configure data defaults by using the Code Mappings Editor \u00e2\u0080\u0093 C Data Defaults tab or the setDataDefault function."
            },
            {
                "heading": "Model Data Categories",
                "content": "You configure data defaults by using the Code Mappings Editor \u00e2\u0080\u0093 C Data Defaults tab or the setDataDefault function. In the Data Defaults tab or function call, you can select or specify these categories of data elements.\n\nModel Element CategoryDescriptionInportsRoot-level input ports of a model, such as Inport and In Bus Element blocks.OutportsRoot-level output ports of a model, such as Outport and Out Bus Element blocks. Signals, states, and internal dataData elements that are internal to the model, such as block output signals, discrete block states, data stores, and zero-crossing signals.Shared local data storesData Store Memory blocks that have the block parameter Share across model instances set. These data stores are accessible only in the model where they are defined. The data store value is shared across instances of the model.Global data storesData stores that are defined by a signal object in the base workspace or in a data dictionary. Multiple models in an application can use these data stores. To view and configure these data stores in the Code Mappings editor, click the Refresh link to the right of the category name. Clicking this link updates the model diagram.Model parametersParameters that are defined within a model, such as parameters in the model workspace. Excludes model arguments.External parametersParameters that you define as objects in the base workspace or in a data dictionary. Multiple models in an application can use these parameters. To view and configure these parameters in the Code Mappings editor, click the Refresh link to the right of the category name. Clicking this link updates the model diagram."
            },
            {
                "heading": "Considerations for Configuring Default Code Generation Settings for Data",
                "content": "Before configuring default code generation settings for data elements, take into account the considerations listed in this table.\n\nConsiderationMore InformationWhat categories are relevant to your model?The data element categories in the preceding tableDoes the model use several instances of data that is in a category? If the answer is yes, applying default mappings is beneficial. Otherwise, consider configuring code generation for each data element individually. Configure Root-Level Inport Blocks for C Code GenerationConfigure Root-Level Outport Blocks for C Code GenerationConfigure Signal Data for C Code GenerationConfigure Parameters for C Code GenerationConfigure Block States for C Code GenerationConfigure Data Stores for C Code Generation Which storage class aligns with your code generation requirements for each category? Choose Storage Class for Controlling Data Representation in Generated CodeDo you want to prevent optimizations from eliminating specific data from the code? Elimination of Categories of Data by Optimizations\n\nAfter you configure one or more categories of model elements, setting memory sections and Shared utilities identifier format model configuration parameters has no effect on the model configuration. When you open a coder app, Simulink migrates the model configuration parameter settings to the Code Mappings editor. As part of the migration, Simulink configures the Embedded Coder Dictionary that the model uses, as described in Migration of Memory Section and Shared Utility Settings from Configuration Parameters to Code Mappings (Embedded Coder)."
            },
            {
                "heading": "Elimination of Categories of Data by Optimizations",
                "content": "Code generation optimizations can eliminate data from the code, which means your application code cannot interact with the data. For general information about data elimination by optimizations, see How Generated Code Stores Internal Signal, State, and Parameter Data (Embedded Coder).\n\nThe optimizations can eliminate data in these categories only:\n\nModel parametersModel parameter argumentsExternal parametersInternal data\n\nAfter eliminating data with optimizations, the code generator applies the default code generation settings in the code mappings to the remaining data. For parameters and signal lines, optimizations can eliminate data for an entire category. If this elimination occurs, default settings that you specify for that category do not apply to data.\n\nTo prevent optimizations from eliminating individual data elements, explicitly apply a storage class to the individual element. The storage class controls the appearance of the data in the generated code. To force a data element to use the default storage class that you specify, explicitly apply the storage class Model default. See Choose Storage Class for Controlling Data Representation in Generated Code."
            },
            {
                "heading": "Shared Dictionary Data Defaults",
                "content": "If you link a model to a Simulink data dictionary, which includes a coder dictionary that configures default code definitions for categories of data, you can use the Code Mappings editor to apply the dictionary defaults. In the Code Mappings editor, on the Data Defaults tab, select a category and set the storage class to Dictionary Default. If someone makes a change to the default settings in the shared coder dictionary, the code generator applies the updated default settings when producing code for your model. See Configure Default Code Mapping in a Shared Dictionary (Embedded Coder)."
            },
            {
                "heading": "Configurations for Individual Data Elements",
                "content": "After you configure model-wide default settings, you can override the defaults for individual data elements. An individual data element configuration applies to a specific data element in a model. Configure data elements individually when:\n\nThe model includes a few elements of a given category that have unique source, naming, or placement requirements.You configured default settings and you want to override the default setting for an individual element.\n\nFor individual data elements, initially the storage class is set to Auto, which means that the code generator might eliminate or change the representation of relevant code for optimization purposes. If optimizations are not possible, the code generator applies the model default configuration.\n\nTo avoid optimizations and force the code generator to use the default configuration, set the storage class to Model default.To override the default configuration, specify the storage class that meets the code generation requirements for that data element."
            },
            {
                "heading": "Configure Data",
                "content": "Open the Simulink Coder\u00e2\u0084\u00a2 app.Configure default mappings for categories of data elements. Select Code Interface > Default Code Mappings. In the Code Mappings editor, on the Data Defaults tab,select a model element category and set the storage class. In the Property Inspector, set storage class properties to align with model requirements.Decide whether to override default configuration settings for individual data elements. If you choose not to override settings, go to step 8.Identify MATLAB variables that you want to configure individually and store the configurations in the model file. In the Model Explorer, convert the variables to Simulink.Parameter objects. The resulting data objects appear in the Code Mappings editor as model parameters.Identify signals representing algorithm data that you want to monitor while the generated code executes and configure those signals individually. For each signal that you identify, do one of the following:For signal data that is specific to a model (not shared), add the signals to the Code Mappings editor.For shared signal data, create and configure Simulink.Signal objects. Configure individual data elements. In the Code Mappings editor, click a category tab, select a data element, and set the storage class. In the Property Inspector, set storage class property values. To change the setting of model configuration parameter Default parameter behavior, click the link indicating the behavior when the storage class is set to Auto. In the Model Configuration Parameters dialog box, change the parameter setting to Tunable or Inline.To view and configure external data objects that are stored in the base workspace or a data dictionary, in the Code Mappings editor, on the Data Defaults tab, click the Refresh link to the right of the category name. Generate and review code.\n\nFor more details and examples, see:\n\nCode Mappings Editor \u00e2\u0080\u0093 CConfigure Root-Level Inport Blocks for C Code GenerationConfigure Root-Level Outport Blocks for C Code GenerationConfigure Signal Data for C Code GenerationConfigure Parameters for C Code GenerationConfigure Block States for C Code GenerationConfigure Data Stores for C Code Generation"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/c-data-code-interface-configuration-for-model-interface-elements.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/defaults_modeldefaults_auto_relationship.png"
        ]
    },
    {
        "title": "Development Computer Requirements",
        "introduction": "To install and run Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2, MATLAB\u00c2\u00ae, Simulink, and other required and optional software, the development computer must be a 64-bit, PC-compatible system. In the Simulink Real-Time software environment, the MATLAB development computer is usually your desktop computer. A notebook computer is also a viable development computer. For more information see Simulink Real-Time Product Requirements.",
        "chunks": [
            {
                "heading": "Communication with Target Computer",
                "content": "For communicating with the Speedgoat\u00c2\u00ae target computer, the development computer requires one available Ethernet interface (PCI or USB) connected to a network. Configure the development computer Ethernet port to use Internet Protocol Version 4 (TCP/IPv4) only. Specify a nonroutable static IP address of the form 192.168.x.x."
            },
            {
                "heading": "Security for Development-to-Target Computer Communication",
                "content": "Ensure that access to your development computer and the target computer is secure.\n\nProvide a secure communication channel between your development computer and the real-time application on the target computer by applying the security measures listed in this table.\n\nCommunication ProtocolSecurity MeasureXCP on TCP/IP, TCP/IP Run your development computer and target computer within a trusted private network or virtual private network (VPN)."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/gs/development-computer-requirements.html",
        "images": []
    },
    {
        "title": "Nonvirtual and Virtual Blocks",
        "introduction": "Simulink\u00c2\u00ae blocks fall into two basic categories: nonvirtual blocks and virtual blocks. Some Simulink blocks are virtual in some circumstances and nonvirtual in others. Such blocks are called conditionally virtual blocks. The table lists Simulink virtual and conditionally virtual blocks.",
        "chunks": [],
        "link": "https://in.mathworks.com/help/simulink/ug/nonvirtual-and-virtual-blocks.html",
        "images": []
    },
    {
        "title": "Troubleshooting Basics",
        "introduction": "For questions or issues about your installation of the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 product, refer to these guidelines and tips. For more specific troubleshooting solutions, go to the MathWorks\u00c2\u00ae Support website MathWorks Help Center website. The troubleshooting suggestions address these areas:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshooting-basics.html",
        "images": []
    },
    {
        "title": "Establish Message Send and Receive Interfaces Between Software Components - MATLAB &amp; Simulink\n",
        "introduction": "Sine Wave | Send | Receive | Queue | Sequence Viewer",
        "chunks": [
            {
                "heading": "Send Component",
                "content": "The algorithm in the Send Component can contain logic of any complexity. In the example, a simple Sine Wave block is used in a subsystem as the signal source. The Sample time parameter of the block is set to 0.1.\n\nTo prepare the Send Component for message-based communication, a Send block is connected to the root-level Outport block. The Send block converts data signals and send messages.\n\nTo prepare the Send Component for code generation, in the Model Configuration Parameters:\n\nIn the Solver pane, in the Solver selection section, the Type is set to Fixed-step.The Fixed-step size is set to 0.1.In the Code Generation pane, the System target file is set to ert.tlc and Language to C++.The model is saved as mSend."
            },
            {
                "heading": "Receive Component",
                "content": "In the Receive Component, a Scope block is used to represent the algorithm that receives messages.\n\nTo prepare the Receive Component, the Inport block is connected to a Receive block. The Receive block receives messages and converts them to signal data. By default, the Sample time parameter of the Receive block is -1.\n\nTo prepare the Receive Component for code generation, in the Model Configuration Parameters:\n\nIn the Solver pane, in the Solver selection section, the Type is set to Fixed-step.The Fixed-step size is set to 0.1.In the Code Generation pane, the System target file is set to ert.tlc and Language to C++.The model is saved as mReceive."
            },
            {
                "heading": "Visualize Message Transitions Between Components Using the Sequence Viewer Block",
                "content": "This is a composition model with Send and Receive components. The Model blocks, Send Component and Receive Component, refer to models mSend and mReceive, respectively.\n\nSimulate the model. Observe the queue inserted by default. An icon above the message line represents the default queue. The capacity of the default queue is 1 and the message overwriting policy is enabled. You can customize the queue by using a Queue block between components. For more information, see Use a Queue Block to Manage Messages.\n\nOpen the Sequence Viewer block. The block allows you to visualize message transition events and the data that the messages carry.\n\nThe Sequence Viewer block window shows the simulation time in the left vertical bar. Each time grid row contains events that occur at the same simulation time. Each message transition event is represented by an arrow that is labeled with the message data value. For more information about the Sequence Viewer block, see Use the Sequence Viewer to Visualize Messages, Events, and Entities.\n\nIn the Sequence Viewer block, scroll up or click Go to first event icon on the left. Observe that at time zero the Send block sends a message with data value 0 to the Receive block, and at time 0.1 the block sends another message with data value 0.0998. The block sends a message in every 0.1 simulation time."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/message-based-communication-between-software-components.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/MessageBasedCommunicationBetweenSoftwareComponentsExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_sendreceive_basicmodel1.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_sendreceive_basicmodel4.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_sendreceive_defaultqueue.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_sendreceive_seqviewer.png"
        ]
    },
    {
        "title": "Schedule the Partitions",
        "introduction": "These two examples walk through the workflow of partitioning a model, scheduling the partitions and analyzing the simulations before and after editing the schedule of the partitions. Schedule Editor",
        "chunks": [
            {
                "heading": "Schedule an Export-Function Model Using the Schedule Editor",
                "content": "Open Script\n\nThis example shows how to view and edit the order of function-calls in an export-function model using the Schedule Editor. As in all export-function models, the desired functionality is modeled as function-call subsystems. These function-call subsystems define the partitions that are scheduled by the Schedule Editor.\n\nWith the Schedule Editor, you can easily view and edit the schedule of the function-calls. The behavior of the system depends on the order of these partitions. In this example, we change the order and observe its effects on the behavior of the system by simulating the model. To see the impact of editing the schedule on the simulation, we compare the model simulations before and after scheduling.\n\nCreate Partitions from Referenced Export-Function ModelTo view and edit the schedule of the export-function model, reference the model.open_system('ThrottlePositionControlTop.slx'); ThrottlePositionControl is the referenced export-function model. By default, each function has an input port that can be used to trigger these functions. The Schedule Editor automatically handles these ports. To use the Schedule Editor, set the Schedule Rates With parameter to Schedule Editor.set_param('ThrottlePositionControlTop/ThrottleControl','ScheduleRatesWith','Schedule Editor'); Establish a Simulation BaselineTo observe the impact of scheduling on the model behavior, establish a baseline by simulating the model before editing the schedule. Simulate the model.sim('ThrottlePositionControlTop'); Open the Schedule EditorTo open the Schedule Editor, click Schedule Editor in the Design section of the Modeling tab. In the Schedule Editor, different components of the model are represented as partitions. Update the diagram to see the partitions. Partitions are the entry-points in the model. The Schedule Editor shows the order and data communications of these partitions. The arrows are data connections between the partitions that show the data flow. The dashed lines indicate that there is a delay because the source runs after the destination. The solid lines indicate that there is no delay as the source runs before the destination. Edit Partition ScheduleThe Order pane shows the order the partitions run in at a given time step. Assume that the order of the partitions is in an imperfect state. In this case, to remove the delay, you want to run the ThrottleControl.ActuatorRun5ms partition after the ThrottleControl.ControllerRun5ms partition.Drag ThrottleControl.ActuatorRun5ms after the ThrottleControl.ControllerRun5ms in the Order pane. Observe that the delay between the ThrottleControl.ControllerRun5ms and the ThrottleControl.ActuatorRun5ms partitions changes to a dependency. Observe that now there is no delay between the executions of ThrottleControl.ControllerRun5ms and ThrottleControl.ActuatorRun5ms. Schedule the Execution of Aperiodic PartitionsThe export-function model contains an unconstrained partition, AccelerationPedalPositionSensor. Suppose you want to schedule an unconstrained partition to simulate as if it were discrete. Schedule ThrottleControl.AppSnsrRun partition to run at [0:0.02:100] to observe its behavior at different instances of time. Click the unconstrained partition and enter [(1:5000)*.02] for Trigger in the Property Inspector. Compare the Runs in Simulation Data InspectorNow, simulate the model with the changed schedule.Open the Simulation Data Inspector. Select the two runs and compare. You can see how changing the schedule impacts the model behavior. Copyright 2018-2022 The MathWorks, Inc."
            },
            {
                "heading": "Schedule a Rate-Based Model Using the Schedule Editor",
                "content": "Open Script\n\nThis example shows how to partition a rate-based model using the Schedule Editor. Partitions are the components of the model that can execute independently. In this example, we convert the subsystems into partitions and view and edit their schedule.\n\nWith the Schedule Editor, you can easily view and edit the schedule of the partitions. The behavior of the system depends on the order of these partitions. In this example, we observe the effects of scheduling this model on the simulation. To see the impact of partitioning and scheduling the model, we compare the model simulations before and after creating partitions and scheduling them.\n\nOpen the Model and Establish a Simulation BaselineOpen the model of a Throttle Position Control system and simulate it to establish a baseline for comparisonopen_system('ScheduleEditorWithSubsystemPartitions'); sim('ScheduleEditorWithSubsystemPartitions'); Open the Schedule Editor and Create PartitionsTo open the Schedule Editor, click Schedule Editor in the Design section of the Modeling tab. Use Manage Partitions to create partitions from the subsystems in your model. Select all the subsystems in ThrottlePositionControl, and click the Create Partitions icon on the top of the Manage Partitions panel. Specify the names for the partitions and their sample time. Update the diagram to see the partitions in the Schedule Editor.The arrows are data connections between the partitions that show the data flow. The dashed lines always indicate that there is a delay as the source runs after the destination. The solid lines indicate that there is no delay as the source runs before the destination. Edit Partition ScheduleThe Order shows the order the partitions run at a given time step. Assume that the order of the partitions is in an imperfect state. In this case, you want to run the ActuatorRun5ms partition before the ControllerRun5ms partition. Drag ActuatorRun5ms before the ControllerRun5ms in the order. Observe that the dependency between the ControllerRun5ms and the ActuatorRun5ms partitions changes to a delay. Compare Runs in Simulation Data InspectorNow, simulate the model with the changed schedule.Open the Simulation Data Inspector. Select the two runs and compare. You can see how changing the schedule impacts the model behavior."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/schedule-partitions.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ScheduleEditorWithExportFunctionExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithExportFunctionOpenScheduleEditor.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithExportFunctionEditSchedule.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithExportFunctionUnconstrainedPartition.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithExportFunctionSdiCompare.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ScheduleEditorWithSubsystemPartitionsExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithSubsystemPartitionsCreatePartitions.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithSubsystemPartitionsEditSchedule.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxScheduleEditorWithSubsystemPartitionsRunCompare.png"
        ]
    },
    {
        "title": "Troubleshoot S-Function Build Upgrade for R2020b",
        "introduction": "A pre-R2020b model uses S-Functions. When migrating this model to the current release, this S-Function related message appears in the build log:",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "In R2020b, the compiler for model builds changed from a Windows\u00c2\u00ae compatible C compiler to the QNX\u00c2\u00ae Neutrino\u00c2\u00ae C++ compiler. To accommodate this change, update S-Function code for C++ compatibility.\n\nTipFortran S-Functions are not supported in R2020b and later releases of Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2."
            },
            {
                "heading": "Try This Workaround",
                "content": "To update S-Function code for C++ compatibility, modify the declaration of the S-Function in the header file.\n\nFor example, update this C S-Function declaration:\n\nvoid getAllDataMyFunction(short); void myfunction_initialize(short, unsigned char*, short*); void myfunction_terminate(short, int);\n\nUpdated the code to this C++ S-Function declaration:\n\n#ifdef __cplusplus extern \"C\" { #endif void getAllDataMyFunction(short); void myfunction_initialize(short, unsigned char*, short*); void myfunction_terminate(short, int); #ifdef __cplusplus } #endif\n\nBefore building the updated code, remember to remove all artifacts from previous model builds."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug_upgrade/troubleshoot-s-function-build-upgrade-for-r2020b.html",
        "images": []
    },
    {
        "title": "Real-Time Application and Target Computer Modes",
        "introduction": "At startup, the Speedgoat\u00c2\u00ae target machine (target computer) boots the QNX\u00c2\u00ae Neutrino\u00c2\u00ae RTOS. After the boot process is complete, you can deploy a real-time application to the target computer and run the application in one of these target computer modes:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/target-computer-operating-modes.html",
        "images": []
    },
    {
        "title": "Choosing a Simulation Mode",
        "introduction": "",
        "chunks": [
            {
                "heading": "Simulation Mode Tradeoffs",
                "content": "In general, you must trade off simulation speed against flexibility when choosing either accelerator mode or rapid accelerator mode instead of normal mode.\n\nNormal mode offers the greatest flexibility for making model adjustments and displaying results, but it runs the slowest.\n\nAccelerator mode lies between normal and rapid accelerator modes in performance and in interaction with your model. Accelerator mode does not support most runtime diagnostics.\n\nRapid accelerator mode runs the fastest, but this mode does not support the debugging utilities or the Simulink\u00c2\u00ae Profiler, and works only with those models for which C code or MEX file is available for all of the blocks in the model.\n\nNoteAn exception to this rule occurs when you run multiple simulations, each of which executes in less than one second in normal mode. For example:for i=1:100 sim(model); % executes in less than one second in Normal mode endFor this set of conditions, you will typically obtain the best performance by simulating the model in normal mode.\n\nTipTo gain additional flexibility, consider using model referencing to componentize your model. If the top model uses normal mode, then you can simulate a referenced model in a different simulation mode than you use for other portions of a model. During the model development process, you can choose different simulation modes for different portions of a model. For details, see Choose Simulation Modes for Model Hierarchies."
            },
            {
                "heading": "Comparing Modes",
                "content": "The following table compares the characteristics of normal mode, accelerator mode, and rapid accelerator mode.\n\nIf you want to...Then use this mode...NormalAcceleratorRapid AcceleratorPerformanceRun your model in a separate address space\u00c2 \u00c2 Efficiently run batch and Monte Carlo simulations\u00c2 \u00c2 Model AdjustmentChange model parameters such as solver, stop time without rebuildingChange block tunable parameters such as gainFor more information on configuration set parameters which can be modified without requiring rebuild, see Code Regeneration in Accelerated ModelsModel RequirementAccelerate your model even if C code or MEX file are not used for all blocks\u00c2 \u00c2 Support Interpreted MATLAB Function blocks\u00c2 Support Non-Inlined MATLAB\u00c2\u00ae language or Fortran S-Functions\u00c2 Permit algebraic loops in your models\u00c2 Use debugging options or the Simulink Profiler\u00c2 Have your model include C++ code\u00c2 Data DisplayUse scopes and signal viewersSee Behavior of Scopes and Viewers with Rapid Accelerator ModeUse scopes and signal viewers when simulating your model programmatically\u00c2\n\nNoteScopes and viewers do not update if you run your model programmatically in rapid accelerator mode."
            },
            {
                "heading": "Decision Tree",
                "content": "Use this decision tree to select between accelerator mode and rapid accelerator mode.\n\nSee Comparing Performance to understand how effective acceleration will be in improving the performance of your model."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/choosing-a-simulation-mode.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/choosingsimmodecomparisongraph.png",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/checkmark.gif",
            "https://in.mathworks.com/help/simulink/ug/choosingsimulationmodeupdated.png"
        ]
    },
    {
        "title": "Real-Time Signal Logging and Streaming Basics",
        "introduction": "Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 signal logging with a File Log block or signal streaming from a real-time application differs from non-real-time Signal logging in Simulink. The differences include: This graphic shows the signal data flow for visualizing signals by using real-time signal logging and streaming. File Log | Enable File Log | import | start | stop | startRecording | stopRecording",
        "chunks": [
            {
                "heading": "Retain Real-Time Signal Data for Post-Processing",
                "content": "You can visualize and analyze real-time signal data in the Simulation Data Inspector after running the real-time application. To select these signals in the model before building the real-time application:\n\nMark signals for logging to the Simulation Data Inspector. The streamed signal data for these signals is visible while the real-time application is running and available in the Simulation Data Inspector after the real-time application stops.Connect signals to File Log blocks for logging to a file on the target computer. After the real-time application stops writing the log file, the signal data is imported into the Simulation Data Inspector.\n\nWith regards to file logging:\n\nReal-time signal logging to a log file samples at the base sample time by default.You can observe signals that are present in the real-time application. Some signals are not observable.Simulink Real-Time Explorer works with multidimensional signals in column-major format."
            },
            {
                "heading": "Display Real-Time Signal Data without Retaining for Post-Processing",
                "content": "Most types of signal streaming permit viewing signal data only during a real-time application run on the target computer. For these run-time-only viewers, signal streaming can use a viewer that you add to the model before building the real-time application, use an instrument that you add to the real-time application, or use a viewer\u00e2\u0080\u0094such as an App Designer instrument panel\u00e2\u0080\u0094that connects to the real-time application. Types of run-time-only signal viewers include:\n\nAdding a Scope block or other viewer to the model for viewing signals in a Scope window during external mode simulation with the model connected to the real-time application.Adding signals to an instrument in the real-time application by using selections from the Real-Time tab in the Simulink Editor or by selecting signals for streaming in the Simulink Real-Time Explorer. You can view these signals in the Simulation Data Inspector or on an Axes tab in the Simulink Real-Time Explorer.Connecting signals to an Axes component or other viewer in an App Designer instrument panel for viewing signals in the app while the real-time application runs."
            },
            {
                "heading": "Real-Time Signal Logging is Affected by How Application is Run",
                "content": "The Run on Target button provides slightly different data logging support than running the real-time application by using the start(tg) function:\n\nWhen you run the real-time application by using the start(tg) function, only signals marked for signal logging or connected to a File Log block are logged to the Simulation Data Inspector.When you run the real-time application by using the Run on Target button on the real-time tab in the Simulink Editor or the Start button in the Simulink Real-Time Explorer, signals marked for logging, signals connected to File Log blocks, and signals connected to Scope blocks are logged to the Simulation Data Inspector."
            },
            {
                "heading": "Signal Triggering for External Mode Simulation",
                "content": "When setting up signal triggering (Source set to signal), explicitly specify the element number of the signal in the Trigger signal:Element box. If the signal is a scalar, enter a value of 1. If the signal is a wide signal, enter a value from 1 to 10. When uploading Simulink Real-Time signals to Simulink scopes, do not enter Last or Any in this box.\n\nThe Direction:Holdoff value does not affect the Simulink Real-Time signal uploading feature.\n\nFor more information about external mode, see Simulink External Mode Interface."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/real-time-signal-logging-and-streaming-basics.html#mw_5565cf5a-d275-432c-8e46-878bba001c8d",
        "images": []
    },
    {
        "title": "Manage Code in App Designer Code View",
        "introduction": "Code View provides most of the same programming features that the MATLAB\u00c2\u00ae Editor provides. It also provides a rich set of features that help you to navigate your code and avoid many tedious tasks. For example, you can search for a callback by typing part of its name in a search bar. Clicking a search result scrolls the editor to the definition of that callback. And if you change the name of a callback, App Designer automatically updates all references to it in your code.",
        "chunks": [
            {
                "heading": "Manage Components, Functions, and Properties",
                "content": "Code View has three panes to help you manage different aspects of your code. This table describes each of them.\n\nPane NamePane AppearancePane FeaturesComponent Browser Context menu \u00e2\u0080\u0094 Right-click a component in the list to display a context menu that has options for deleting or renaming the component, adding a callback, or displaying help. Select the Include Component Labels in Component Browser option to display grouped component labels.Search bar \u00e2\u0080\u0094Quickly locate a component by typing part of its name in the search bar.Component tab \u00e2\u0080\u0094 Use this tab to view or change property values for the component that is currently selected. You can also search for a property by typing part of the name in the search bar at the top of this tab.Callbacks tab \u00e2\u0080\u0094 Use this tab to manage the callbacks for the component that is selected. Code Browser Callbacks, Functions, and Properties tabs \u00e2\u0080\u0094 Use these tabs to add, delete, or rename any of the callbacks, helper functions, or custom properties in your app. Clicking an item in the Callbacks or Functions tab scrolls the editor to the corresponding section in your code. Rearrange the order of callbacks by selecting the callback you want to move and then, drag and drop the callback into its new position in the list. This also repositions the callback in the editor.Search bar \u00e2\u0080\u0094 Quickly locate a callback, helper function, or property by typing part of its name in the search bar. App Layout App thumbnail \u00e2\u0080\u0094 Use the thumbnail image to locate components in large, complex apps that have many components. Selecting a component in the thumbnail selects the component in the Component Browser."
            },
            {
                "heading": "Identify Editable Sections of Code",
                "content": "In the Code View editor, some sections of code are editable and some are not. Uneditable sections are generated and managed by App Designer, whereas editable sections correspond to:\n\nThe body of functions you define (e.g., callbacks and helper functions)Custom property definitions\n\nIn the default color scheme, uneditable sections of code are gray and editable sections of code are white."
            },
            {
                "heading": "Program Your App",
                "content": "App Designer defines your app as a MATLAB class. You do not need to understand classes or object-oriented programming to create an app because App Designer manages those aspects of the code. However, programming in App Designer requires a different workflow than working strictly with functions. You can review a summary of this workflow at any time by clicking the Show Tips button in the Resources tab of the toolstrip."
            },
            {
                "heading": "Manage UI Components",
                "content": "When you add a UI component to your app, App Designer assigns a default name to the component. Use that name (including the app prefix) to refer to the component in your code. You can change the name of a component by double-clicking the name in the Component Browser and typing a new name. App Designer automatically updates all references to that component when you change its name.\n\nTo use the name of a component in your code, you can save some time by copying the name from the Component Browser. Place your cursor in an editable area of the code where you want to add the component name. Then, from the Component Browser, right-click the component name and select Insert at Cursor. Alternatively, you can drag the component name from the list into your code.\n\nTo delete a component, select its name in the Component Browser and press the Delete key."
            },
            {
                "heading": "Manage Callbacks",
                "content": "To make a component respond to user interactions, add a callback. Right-click the component in the Component Browser and select Callbacks > Add (callback property) callback.\n\nIf you delete a component from your app, App Designer deletes the associated callback only if the callback has not been edited and is not shared with other components.\n\nTo delete a callback manually, select the callback name in the Callbacks tab of the Code Browser and press the Delete key.\n\nFor more information about callbacks, see Callbacks in App Designer."
            },
            {
                "heading": "Share Data Within Your App",
                "content": "To store data, and share it among different callbacks, create a property. For example, if want your app to read a data file and allow different callbacks in your app to access that data, store the data in a property when you load the file.\n\nTo create a property, expand the Property drop-down in the Editor tab, and select Private Property or Public Property. App Designer creates a template property definition and places your cursor next to that definition. Change the name of the property as desired.\n\nproperties (Access = public) X % Average cost end\n\nTo reference the property in your code, use the syntax app.PropertyName. For example, app.X references the property named X.\n\nFor more information about creating and using properties, see Share Data Within App Designer Apps."
            },
            {
                "heading": "Single-Source Code that Runs in Multiple Places",
                "content": "If you want to execute a block of code in multiple parts of your app, create a helper function. For example, you might create a helper function to update a plot after the user changes a number in an edit field or selects an item in a drop-down list. Creating a helper function allows you to single-source the common commands and avoid having to maintain redundant sets of code.\n\nTo add a helper function, expand the Function drop-down in the Editor tab, and select Private Function or Public Function. App Designer creates a template function and places your cursor in the body of that function.\n\nTo delete a helper function, select the function name in the Functions tab of the Code Browser and press the Delete key.\n\nFor more information about writing helper functions, see Reuse Code in Apps Using Helper Functions."
            },
            {
                "heading": "Create Input Arguments",
                "content": "To add input arguments to your app, click App Input Arguments in the Editor tab. Input arguments are commonly used for creating apps that have multiple windows. For more information, see Startup Tasks and Input Arguments in App Designer."
            },
            {
                "heading": "Add Help Text for Your App",
                "content": "Add an app summary and description to provide information about your app to users. To add help text or to edit existing help text, click App Help Text . Use the App Help Text dialog box to specify a short summary of the app and a more detailed explanation of what the app does and how to use it. App Designer adds this help text as a comment under the app definition statement.\n\nTo display app help text in the MATLAB Command Window, call the help function and specify the app name. In addition, app help text appears at the top of the documentation page for your app. You can view the documentation page for your app by calling the doc function and specifying the app name."
            },
            {
                "heading": "Limit Your App to Only One Running Instance at a Time",
                "content": "When you create an app in App Designer you have the option to select between two run behaviors for the app:\n\nAllow only a single running instance of the app at a time.Allow multiple instances of the app to run at the same time. This is the default behavior.\n\nTo change the run behavior of your app, select the app node from the Component Browser. Then, from the Code Options section of the App tab, select or clear Single Running Instance.\n\nWhen Single Running Instance is selected and you run the app multiple times, MATLAB reuses the existing instance and brings it to the front rather than creating a new one. When this option is cleared, MATLAB creates a new app instance each time you run it and continues to run the existing instances. These run behaviors apply to apps that you run from the Apps tab on the MATLAB Toolstrip or from the Command Window.\n\nWhen you run apps from App Designer their behavior doesn't change whether this option is selected or cleared. App Designer always closes the existing app instance before creating a new one."
            },
            {
                "heading": "Fix Code Problems and Run-Time Errors",
                "content": "Like the MATLAB Editor, the Code View editor provides Code Analyzer messages to help you discover errors in your code.\n\nIf you run your app directly from App Designer (by clicking Run ), App Designer highlights the source of errors in your code, should any errors occur at run time. To hide the error message, click the error indicator (the red circle). To make the error indicator disappear, fix your code and save your changes.\n\nYou can also diagnose problems in your code by debugging your app code interactively in App Designer. For more information, see Debug MATLAB Code Files."
            },
            {
                "heading": "Personalize Code View Appearance",
                "content": "You can customize how your code appears in the Code View editor. To change your code view preferences, go to the Home tab of the MATLAB Desktop. In the Environment section, click Preferences."
            },
            {
                "heading": "Change Color Settings",
                "content": "To change the color settings for editable sections of code and to customize syntax highlighting, select MATLAB > Colors and adjust the desktop tool colors and the MATLAB syntax highlighting colors. These settings affect both the App Designer Code View editor and the MATLAB Editor. For more information, see Change Desktop Colors.\n\nTo change the background color of uneditable sections of code, select MATLAB > App Designer and adjust the read-only background color. This setting can be changed only if the Use system colors option in MATLAB > Color Preferences is unchecked."
            },
            {
                "heading": "Change Tab Preferences",
                "content": "To specify the size of tabs and indents in the Code View editor, select MATLAB > Editor/Debugger > Tab. From here, you can specify the size of tabs and indents, as well as details about how tabs behave. These preferences affect both the App Designer Code View editor and the MATLAB Editor. For more information, see Editor/Debugger Tab Preferences."
            }
        ],
        "link": "https://in.mathworks.com/help/matlab/creating_guis/app-designer-code-generation.html",
        "images": [
            "https://in.mathworks.com/help/matlab/creating_guis/component_browser_appearance21b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/code_browser_appearance.png",
            "https://in.mathworks.com/help/matlab/creating_guis/app_layout_appearance.png",
            "https://in.mathworks.com/help/matlab/creating_guis/codeview_editable_sections19a.png",
            "https://in.mathworks.com/help/matlab/creating_guis/code_view_tips.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_browser_rename20b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/code_browser_insert_atcursor20b.png",
            "https://in.mathworks.com/help/matlab/creating_guis/add_property_toolstrip_icon.png",
            "https://in.mathworks.com/help/matlab/creating_guis/add_function_toolstrip_icon.png",
            "https://in.mathworks.com/help/matlab/creating_guis/input_args_button.png",
            "https://in.mathworks.com/help/matlab/creating_guis/add-help-text-icon.png",
            "https://in.mathworks.com/help/matlab/creating_guis/component_browser_appnode_singleton.png",
            "https://in.mathworks.com/help/matlab/creating_guis/codeanalyzer_warning.png",
            "https://in.mathworks.com/help/matlab/creating_guis/run.png",
            "https://in.mathworks.com/help/matlab/creating_guis/codeview_runtime_errors.png",
            "https://in.mathworks.com/help/matlab/creating_guis/preferences_icon.png"
        ]
    },
    {
        "title": "Troubleshoot Build Error for Accelerator Mode",
        "introduction": "A build error occurs when building a model in accelerator mode or rapid accelerator mode when the model contains Simulink Real-Time blocks (for example, model blocks that represent hardware).",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "Simulink Real-Time does not support accelerator mode or rapid accelerator mode simulation of models with blocks that represent hardware. For example, open the slrt_ex_serialasciitest model.\n\nopenExample('slrt_ex_serialasciitest').\n\nChange the Simulink mode to rapid accelerator, and run the model, Simulink displays this error:\n\nUnable to build a standalone executable to simulate the model 'slrt_ex_serialasciitest' in rapid accelerator mode.\n\nThis error occurs because accelerator mode and rapid accelerator mode produce compiled code that runs on the development computer, not on the Speedgoat\u00c2\u00ae target computer. Any blocks that access hardware report a build error if you compile the model by using accelerator mode or rapid accelerator mode."
            },
            {
                "heading": "Try This Workaround",
                "content": "Change the simulation mode to normal mode or external mode."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-build-error-for-accelerator-mode.html",
        "images": []
    },
    {
        "title": "Unbounded Variable-Size Signals",
        "introduction": "In Simulink\u00c2\u00ae, variable-size signals are signals whose size (the number of elements in a dimension), in addition to its values can change during model simulation. For example, a variable-size signal with dimensions [2 5] allows the first dimension to vary in the range of [0 2] and the second dimension to vary in the range of [0 5]. Unbounded variable-size signals or dynamic arrays extend the functionality of variable-size signals by modeling data whose sizes are unknown during model compilation. You can configure an unbounded variable-size signal by specifying the size of a variable-size signal as Inf. For example, an unbounded variable-size signal with dimension [2 Inf] allows the first dimension to vary in the range of [0 2] and the second dimension in the range of [0 intmax(\"int32\")]. intmax(\"int32\") indicates the maximum allowable size limit. For more information, see Maximum Size Limits of Simulink Models. Unbounded variable-size signals use dynamic memory allocation and deallocation to react to varying signal sizes during model simulation. This functionality allows efficient storage and management of signal data. Unbounded variable-size signals can be beneficial in these scenarios: This table describes the differences between bounded and unbounded variable-size signals.",
        "chunks": [
            {
                "heading": "Using Unbounded Variable-Size Signals",
                "content": "Follow these steps to use unbounded variable-size signals in a model."
            },
            {
                "heading": "Determine Whether Model Meets Requirements",
                "content": "Determine whether your model meets the requirements to use unbounded variable-size signals.\n\nFor each model component and for component interfaces, identify the signals whose sizes are unknown at model compilation.Check if the source and sink blocks for the signals support unbounded variable-size signals: If the blocks are not supported, you must define finite values for all the dimensions of such signals. In this case, the next steps and sections do not apply to your model.If the blocks are supported, proceed to the next step. For more information about the blocks supported, see Supported Blocks. If the blocks are supported but the model features are not supported, you must change to supported model features. For more information, see Supported Features."
            },
            {
                "heading": "Configure Model Components",
                "content": "Configure the model based on whether signals are associated with blocks or contained in signal or bus objects.\n\nThese are four typical configuration scenarios:\n\nUnbounded variable-size signals associated with the Inport blockUnbounded variable-size signals associated with the input or output port of the MATLAB Function blockUnbounded variable-size Simulink.BusElement objects contained in Simulink.Bus objectUnbounded variable-size Simulink.Signal object\n\nFor more information, see Unbounded Variable-Size Signal Basic Operations."
            },
            {
                "heading": "Compile Model and Verify Signal Dimensions",
                "content": "Verify if the model is configured to handle unbounded variable-size signals.\n\nUpdate the block diagram (Ctrl+D).In the Simulink Editor, on the Debug tab, select Information Overlays and click Signal Dimensions. Each signal is labeled with its dimensions, so you can check that the signals are properly configured to carry unbounded size data."
            },
            {
                "heading": "Prepare Model for Simulation",
                "content": "To prepare the model for simulation, in the Configuration Parameters dialog box:\n\nIn the Solver pane, in the Solver Selection section, check that Solver is set to the default auto option. Otherwise, select auto(Automatic Solver Selection) or discrete(no continuous states). Unbounded variable-size signals only support discrete solvers.In the Data Import/Export pane, check that the data logging Format is set to Dataset (default).\n\nNoteYou will need additional configuration settings when you use MATLAB Function block or plan to generate C++ code from the model. For the MATLAB Function block, see Unbounded Variable-Size Arrays in MATLAB Function Block. For code generation, see Unbounded Variable-Size Signals in C++ Code Generation."
            },
            {
                "heading": "Set Up Data Logging",
                "content": "You can log unbounded variable-size signals using any of the mechanism described in View the Signal Logging Configuration. Logging non-virtual buses that contain unbounded variable-size signals is not supported."
            },
            {
                "heading": "Unbounded Variable-Size Signals in C++ Code Generation",
                "content": "Configure the model for code generation. In the Code Generation pane:\n\nSet the target language to C++.In the Interface section, select Support: variable-size signals and set Array Layout to Column-major.\n\nFor more information about code generation, see Variable-Size Signals in Generated Code (Simulink Coder)."
            },
            {
                "heading": "Unbounded Variable-Size Arrays in MATLAB Function Block",
                "content": "You must use MATLAB Function blocks to implement math operations for unbounded variable-size signals, because nonvirtual mathematical operation blocks are not supported.\n\nWhen using a MATLAB Function block, in the Simulation Target pane:\n\nIn Advanced parameters section, check that Dynamic memory allocation in MATLAB functions is selected. This option is selected by default. For more information, see Declare Variable-Size MATLAB Function Block Variables.Set Language as C++.\n\nWhen using unbounded variable-size signals, MATLAB Function blocks use dynamic memory allocation. For more information, see Use Dynamic Memory Allocation for Variable-Size Arrays in a MATLAB Function Block.\n\nFor an example that has a MATLAB Function block which uses unbounded variable-size arrays, see Unbounded Variable-Size Signal Basic Operations."
            },
            {
                "heading": "Supported Blocks and Features for Simulation",
                "content": "This section lists blocks and features that you can use with unbounded variable-size signals. Any block or feature not listed in this section is not supported."
            },
            {
                "heading": "Supported Blocks",
                "content": "These Simulink blocks support unbounded variable-size signals. The list below shows the blocks based on the Simulink library they belong to. To access the Simulink Library Browser, in the Simulink Toolstrip, on the Simulation tab, click Library Browser.\n\nSimulink / Port & SubsystemsSubsystemSwitch Case Action SubsystemIf Action SubsystemFor Iterator SubsystemWhile Iterator SubsystemFunction-Call SubsystemEnabled SubsystemEnabled and Triggered SubsystemTriggered SubsystemResettable SubsystemVariant SubsystemModelSimulink / Signal AttributesProbeSignal SpecificationSignal ConversionSimulink / User-Defined FunctionsSimulink FunctionMATLAB FunctionS-FunctionFunction CallerSimulink / Signal RoutingSelectorBus SelectorBus AssignmentBus CreatorMultiport SwitchData Store MemoryVector ConcatenateMatrix ConcatenateSimulink / SourcesGroundInportSimulink / SinksOutportTerminatorTo WorkspaceRecordSimulink / Math OperationsAssignment"
            },
            {
                "heading": "Supported Features",
                "content": "Normal simulation mode for top-level model in a model hierarchyBoth normal and accelerator simulation modes for referenced modelsAll data types except string"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/unbounded-variable-size-signals.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/unbounded_varsize_signal_blocks.png",
            "https://in.mathworks.com/help/simulink/ug/unbounded_varsize_bus.png",
            "https://in.mathworks.com/help/simulink/ug/unbounded_varsize_simulinksignal.png",
            "https://in.mathworks.com/help/simulink/ug/unbounded_varsize_signal_model.png"
        ]
    },
    {
        "title": "Execute Target Computer RTOS Commands at Target Computer Command Line",
        "introduction": "To enter target computer RTOS commands, type the commands by using a keyboard attached to the target computer or by using an SSH utility (such as PuTTY) to send commands to the target computer from a MATLAB\u00c2\u00ae development computer. The target computer commands are case-sensitive. For more information, see Target Computer Command-Line Interface. The command examples use the PuTTy SSH utility. You can download and install this utility from www.putty.org. Targets",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/execute-target-computer-rtos-commands-at-target-computer-command-line.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/window-target-computer-commands-putty.png"
        ]
    },
    {
        "title": "Real-Time Signal Logging and Parameter Tuning - MATLAB &amp; Simulink\n",
        "introduction": "slrtTETMonitor",
        "chunks": [
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Open, Build, and Download Model to the Target Computer",
                "content": "Open the model, slrt_ex_param_tuning. The model configuration parameters select the system target file (STF) that corresponds to the connected target computer, tg. Building the model creates a real-time application, slrt_ex_param_tuning.mldatx, that runs on the target computer.\n\nmodel = 'slrt_ex_param_tuning'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model,'RTWVerbose','off'); set_param(model,'StopTime','0.2');\n\nBuild the model and download the real-time application, slrt_ex_param_tuning.mldatx, to the target computer.\n\nConfigure for a non-Verbose build.Build and download application.\n\nevalc('slbuild(model)'); load(tg,model);"
            },
            {
                "heading": "Run Model, Sweep 'Gain' Parameter, Plot Logged Data",
                "content": "This code accomplishes several tasks.\n\nTask 1: Create Target Object\n\nCreate the MATLAB\u00c2\u00ae variable, tg, that contains the Simulink Real-Time target object. This object lets you communicate with and control the target computer.\n\nCreate a Simulink Real-Time target object.Set stop time to 0.2s.\n\nTask 2: Run the Model and Plot Results\n\nRun the model, sweeping through and changing the gain (damping parameter) before each run. Plot the results for each run.\n\nIf no plot figure exist, create the figure.If the plot figure exist, make it the current figure.\n\nTask 3: Loop over damping factor z\n\nSet damping factor (Gain1/Gain).Start run of the real-time application.Store output data in outp, y, and t variables.Plot data for current run.\n\nTask 4: Create 3-D Plot (Oscillator Output vs. Time vs. Gain)\n\nLoop over damping factor.Create a plot of oscillator output versus time versus gain.Create 3-D plot.\n\nfigh = findobj('Name', 'parsweepdemo'); if isempty(figh) figh = figure; set(figh, 'Name', 'parsweepdemo', 'NumberTitle', 'off'); else figure(figh); end y = []; flag = 0; for z = 0.1 : 0.05 : 0.7 if isempty(find(get(0, 'Children') == figh, 1)) flag = 1; break; end load(tg,model); tg.setparam([model '/Gain1'],'Gain',2 * 1000 * z); tg.start('AutoImportFileLog',true, 'ExportToBaseWorkspace', true); pause(0.4); outp = logsOut{1}.Values; y = [y,outp.Data(:,1)]; t = outp.Time; plot(t,y); set(gca, 'XLim', [t(1), t(end)], 'YLim', [-10, 10]); title(['parsweepdemo: Damping Gain = ', num2str(z)]); xlabel('Time'); ylabel('Output'); drawnow; end if ~flag delete(gca); surf(t(1 : 200), 0.1 : 0.05 : 0.7, y(1 : 200, :)'); colormap cool shading interp h = light; set(h, 'Position', [0.0125, 0.6, 10], 'Style', 'local'); lighting gouraud title('parsweepdemo: finished'); xlabel('Time'); ylabel('Damping Gain'); zlabel('Output'); end\n\nImporting Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ... Importing Log file 1 of 1 ..."
            },
            {
                "heading": "Close Model",
                "content": "When done, close the model.\n\nbdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/parameter-tuning-and-data-logging.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtParameterTuningAndDataLoggingExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtParameterTuningAndDataLoggingExample_02.png"
        ]
    },
    {
        "title": "Multicore Programming with Simulink",
        "introduction": "Using the process of partitioning, mapping, and profiling in Simulink\u00c2\u00ae, you can address common challenges of designing systems for concurrent execution. Partitioning enables you to designate regions of your model as tasks, independent of the details of the embedded multicore processing hardware. This independence enables you to arrange the content and hierarchy of your model to best suit the needs of your application. In a partitioned system, mapping enables you to assign partitions to processing elements in your embedded processing system. Use the Simulink mapping tool to represent and manage the details of executing threads, HDL code on FPGAs, and the work that these threads or FPGAs perform. While creating your model, you do not need to track the partitions or data transfer between them because the tool does this work. Also, you can reuse your model across multiple architectures. Profiling simulates deployment of your application under typical computational loads. It enables you to determine the partitioning and mapping for your model that gives the best performance, before you deploy to your hardware. Simulink tries to optimize the host computer performance regardless of the modeling method you use. For more information on the ways that Simulink helps you to improve performance, see Optimize Performance.",
        "chunks": [
            {
                "heading": "Basic Workflow",
                "content": "To deploy your model to the target.\n\nSet up your model for concurrent execution.For more information about configuring your model for concurrent execution, see Configure Your Model for Concurrent Execution. With these settings, Simulink partitions your model based on the sample time of blocks at the root level, with each sample time in your model corresponding to a partition, and all blocks of a single rate or sample time belonging to the same partition.If you want to specify how to partition your model, use explicit partitioning. With explicit partitioning, you must specify a target architecture, and then explicitly partition your model. For more information, see Specify a Target Architecture, and Partition Your Model Using Explicit Partitioning.Generate code and deploy it to your target. You can choose to deploy onto multiple targets. To build and deploy on a desktop target, see Build on Desktop.To deploy onto embedded targets using Embedded Coder\u00c2\u00ae, see Deploy Generated Software (Embedded Coder).To build and deploy on a real-time target using Simulink Real-Time\u00e2\u0084\u00a2, see Standalone Operation (Simulink Real-Time). To deploy onto FPGAs using HDL Coder\u00e2\u0084\u00a2, see Deployment (HDL Coder).NoteDeployment onto FPGAs is supported only for explicitly partitioned models. Optimize your design. This step is optional, and includes iterating over the design of your model and mapping to get the best performance, based on your metrics. One way to evaluate your model is to profile it and get execution times.ProductInformationDesktop targetProfile and Evaluate Explicitly Partitioned Models on a Desktop Simulink Real-TimeExecution Profiling for Real-Time Applications (Simulink Real-Time)Embedded CoderCode Execution-Time Profiling (Embedded Coder)HDL CoderSpeed and Area Optimization (HDL Coder)"
            },
            {
                "heading": "How Simulink Helps You to Overcome Challenges in Multicore Programming",
                "content": "Manually programming your application for concurrent execution poses challenges beyond the typical challenges with manual coding. With Simulink, you can overcome the challenges of portability across multiple architectures, efficiency of deployment for an architecture, and cyclic data dependencies between application components. For more information on these challenges, see Challenges in Multicore Programming."
            },
            {
                "heading": "Portability",
                "content": "Simulink enables you to determine the content and hierarchical needs of the modeled system without considering the target system. While creating model content, you do not need to keep track of the number of cores in your target system. Instead, you select the partitioning methods that enable you to create model content. Simulink generates code for the architecture you specify.\n\nYou can select an architecture from the available supported architectures or add a custom architecture. When you change your architecture, Simulink generates only the code that needs to change for the second architecture. The new architecture reuses blocks and functions. For more information, see Supported Targets for Multicore Programming and Specify a Target Architecture."
            },
            {
                "heading": "Deployment Efficiency",
                "content": "To improve the performance of the deployed application, Simulink allows you to simulate it under typical computational loads and try multiple configurations of partitioning and mapping the application. Simulink compares the performance of each of these configurations to provide the optimal configuration for deployment. This is known as profiling. Profiling helps you to determine the optimum partition configuration before you deploy your system to the desired hardware.\n\nYou can create a mapping for your application in which Simulink maps the application components across different processing nodes. You can also manually assign components to processing nodes. For any mapping, you can see the data dependencies between components and remap accordingly. You can also introduce and remove data dependencies between different components."
            },
            {
                "heading": "Cyclic Data Dependency",
                "content": "Some tasks of a system depend on the output of other tasks. The data dependency between tasks determines their processing order. Two or more partitions containing data dependencies in a cycle creates a data dependency loop, also known as an algebraic loop. Simulink does not allow algebraic loops to occur across potentially parallel partitions because of the high cost of solving the loop using parallel algorithms.\n\nIn some cases, the algebraic loop is artificial. For example, you can have an artificial algebraic loop because of Model-block-based partitioning. An algebraic loop involving Model blocks is artificial if removing the use of Model partitioning eliminates the loop. You can minimize the occurrence of artificial loops. In the Configuration Parameter dialog boxes for the models involved in the algebraic loop, select Model Referencing > Minimize algebraic loop occurrences.\n\nEnsuring deterministic delay for periodic signals can also help break algebraic loops. To configure this setting, open Model Settings> Solver > Additional parameters > Configure Tasks. In the Data Transfer pane, set the default option for Periodic Signals to Ensure deterministic transfer (maximum delay).\n\nAdditionally, if the model is configured for the Generic Real-Time target (grt.tlc) or the Embedded Real-Time target (ert.tlc) in the Configuration Parameters dialog box, clear the Single output/update function check box.\n\nIf the algebraic loop is a true algebraic condition, you must either contain all the blocks in the loop in one Model partition, or eliminate the loop by introducing a delay element in the loop.\n\nThe following examples show how to implement different types of parallelism in Simulink. These examples contain models that are partitioned and mapped to a simple architecture with one CPU and one FPGA."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/solving-embedded-performance-problems-using-multicore-processors-and-fpgas.html",
        "images": []
    },
    {
        "title": "ETAS Inca Limitations",
        "introduction": "For ETAS\u00c2\u00ae Inca, the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 software does not support: Event mode data acquisition has the following limitations:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/etas-inca-limitations-and-troubleshooting.html",
        "images": []
    },
    {
        "title": "Apply Simulink Real-Time Model Template to Create Real-Time Application - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Create Simulink Model from Template",
                "content": "To create a Simulink model from the Simulink start page, in the MATLAB\u00c2\u00ae Command Window, type:\n\nsimulink\n\nSelect the Simulink Real-Time template from the start page and create the exampleSlrealtimeApp model. Or, in the Command Window, use the Simulink.createFromTemplate command. See code for this script for full syntax."
            },
            {
                "heading": "Blocks, Connections, and Data Logging in the Model",
                "content": "The Simulink Real-Time model template contains a Gain block that connects a Signal Generator to a Scope block. The Gain block output is marked for logging with the Simulation Data Inspector (SDI)."
            },
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer."
            },
            {
                "heading": "Simulate Real-Time Application and View Logged Data",
                "content": "Build the real-time application, run it on the target computer, and view the logged data:\n\n1. Make sure that the development computer has a connection to the target computer.\n\n2. Build the model and download the real-time application to the target computer. On the Real-Time tab, click Run on Target. Or, use the slbuild command and the load command.\n\n3. Run the real-time application and log data by using the Run on Target button.\n\n4. Open the Simulation Data Inspector by double-clicking the Simulation Data Inspector icon on the Gain block output signal or by using the Simulink.sdi.view command."
            },
            {
                "heading": "More Information",
                "content": "Create and Run Real-Time Application from Simulink Model Configure and Control Real-Time Application by Using Simulink Real-Time Explorer Simulation Data Inspector"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/apply-simulink-real-time-model-template-to-create-real-time-application.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/ApplySlrealtimeModelTemplateToCreateRtAppExample_01.png"
        ]
    },
    {
        "title": "Access Block Data During Simulation",
        "introduction": "",
        "chunks": [
            {
                "heading": "About Block Run-Time Objects",
                "content": "Simulink\u00c2\u00ae provides an application programming interface, called the block run-time interface, that enables programmatic access to block data, such as block inputs and outputs, parameters, states, and work vectors, while a simulation is running. You can use this interface to access block run-time data from the MATLAB\u00c2\u00ae command line, the Simulink Debugger, and from Level-2 MATLAB S-functions (see Write Level-2 MATLAB S-Functions).\n\nNoteYou can use this interface even when the model is paused or is running or paused in the debugger.\n\nThe block run-time interface consists of a set of Simulink data object classes (see Data Objects) whose instances provide data about the blocks in a running model. In particular, the interface associates an instance of Simulink.RunTimeBlock, called the block's run-time object, with each nonvirtual block in the running model. A run-time object's methods and properties provide access to run-time data about the block's I/O ports, parameters, sample times, and states."
            },
            {
                "heading": "Access a Run-Time Object",
                "content": "Every nonvirtual block in a running model has a RuntimeObject parameter whose value, while the simulation is running, is a handle for the run-time object of the block. This allows you to use get_param to obtain a block's run-time object. For example, the following statement\n\nrto = get_param(gcb,'RuntimeObject');\n\nreturns the run-time object of the currently selected block. Run-time object data is read-only. You cannot use run-time objects to change a block\u00e2\u0080\u0099s parameters, input, output, and state data.\n\nNoteVirtual blocks (see Nonvirtual and Virtual Blocks) do not have run-time objects. Blocks eliminated during model compilation as an optimization also do not have run-time objects (see Block reduction). A run-time object exists only while the model containing the block is running or paused. If the model is stopped, get_param returns an empty handle. When you stop a model, all existing handles for run-time objects become empty."
            },
            {
                "heading": "Listen for Method Execution Events",
                "content": "One application for the block run-time API is to collect diagnostic data at key points during simulation, such as the value of block states before or after blocks compute their outputs or derivatives. The block run-time API provides an event-listener mechanism that facilitates such applications. For more information, see the documentation for the add_exec_event_listener command. For an example of using method execution events, open sldemo_msfcn_lms. This Simulink model contains the S-function adapt_lms.m which performs a system identification to determine the coefficients of an FIR filter. The S-function's PostPropagationSetup method initializes the block run-time object's DWork vector such that the second vector stores the filter coefficients calculated at each time step.\n\nIn the Simulink model, double-clicking on the annotation below the S-function block executes its OpenFcn. This function first opens a figure for plotting the FIR filter coefficients. It then executes the function to add a PostOutputs method execution event to the S-function's block run-time object for example:\n\n% Add a callback for PostOutputs event blk = 'sldemo_msfcn_lms/LMS Adaptive'; h = add_exec_event_listener(blk, ... 'PostOutputs', @plot_adapt_coefs);\n\nThe function plot_adapt_coefs.m is registered as an event listener that is executed after every call to the S-function's Outputs method. The function accesses the block run-time object's DWork vector and plots the filter coefficients calculated in the Outputs method. The calling syntax used in plot_adapt_coefs.m follows the standard needed for any listener. The first input argument is the S-function's block run-time object, and the second argument is a structure of event data, as shown below.\n\nfunction plot_adapt_coefs(block, ei) %#ok<INUSD> % % Callback function for plotting the current adaptive filtering % coefficients. stemPlot = get_param(block.BlockHandle,'UserData'); est = block.Dwork(2).Data; set(stemPlot(2),'YData',est); drawnow('expose');"
            },
            {
                "heading": "Synchronizing Run-Time Objects and Simulink Execution",
                "content": "You can use run-time objects to obtain the value of a block output and display in the MATLAB Command Window by entering the following commands.\n\nrto = get_param(gcb,'RuntimeObject') rto.OutputPort(1).Data\n\nHowever, the displayed data may not be the true block output if the run-time object is not synchronized with the Simulink execution. Simulink only ensures the run-time object and Simulink execution are synchronized when the run-time object is used either within a Level-2 MATLAB S-function or in an event listener callback. When called from the MATLAB Command Window, the run-time object can return incorrect output data if other blocks in the model are allowed to share memory.\n\nTo ensure the Data field contains the correct block output, open the Configuration Parameters dialog box, and then clear the Signal storage reuse check box (see Signal storage reuse (Simulink Coder))."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/accessing-block-data-during-simulation.html",
        "images": []
    },
    {
        "title": "Monitor CPU Overload Rate - MATLAB &amp; Simulink\n",
        "introduction": "SLRT Overload Options",
        "chunks": [
            {
                "heading": "Create Target Object and Connect",
                "content": "Create a Target object for the default target computer and connect to the target computer. In the Command Window, type:\n\ntg = slrealtime; connect(tg);"
            },
            {
                "heading": "Open, Build, and Run the Model",
                "content": "In the MATLAB Command Window, type:\n\nmodel = 'slrt_ex_overload'; open_system(model); modelSTF = getSTFName(tg); set_param(model,\"SystemTargetFile\",modelSTF); set_param(model, 'RTWVerbose', 'off');\n\nName the signal coming out from the outport of rate limiter block as Rate Limiter and log it in the Simulation Data Inspector.\n\np = get_param('slrt_ex_overload/Rate Limiter','PortHandles'); l = get_param(p.Outport,'Line'); set_param(l,'Name','Rate Limiter'); Simulink.sdi.markSignalForStreaming('slrt_ex_overload/Rate Limiter',1,'on');\n\nBuild the model.\n\nevalc('slbuild(model)');\n\nDownload the application and run it on the target computer.\n\nload(tg,model); start(tg); pause(20); stop(tg);"
            },
            {
                "heading": "Open Simulation Data Inspector",
                "content": "To view the rate at which CPU overloads occur, open the Simulation Data Inspector.\n\nIn the MATLAB Command Window, type:\n\nSimulink.sdi.view;"
            },
            {
                "heading": "Examine CPU Overload Rate Data",
                "content": "In the Simulation Data Inspector, the graph shows:\n\nBottom rising stair step signal -- This signal indicates the number of CPU overloads that occurred.Top rising stair step signal -- This signal indicates the number of CPU overloads that are allowed, which is (occurred + 2).Rising slew rate -- This signal indicates the rate at which CPU overloads occur. When the rising slew rate becomes greater than the top rising stair step signal, the rate of CPU overloads is greater than are allowed."
            },
            {
                "heading": "Modify Rate of CPU Overloads",
                "content": "To modify the rate at which CPU overloads occur in the model, modify the Constant2 parameter value."
            },
            {
                "heading": "Modify Allowed Rate of CPU Overloads",
                "content": "To modify the rate of CPU overloads that are acceptable in the model, modify the RisingSlewLimit parameter value."
            },
            {
                "heading": "Build and Run Model with Changed Overload Rates",
                "content": "In the MATLAB Command Window, type:\n\nload(tg,model);\n\nTo modify the rate of CPU overloads that are acceptable in the model.\n\ntg.setparam('slrt_ex_overload/Rate Limiter','RisingSlewLimit',4);\n\nTo modify the rate at which CPU overloads occur in the model.\n\ntg.setparam('slrt_ex_overload/Constant2','Value',4);\n\nRun the modified application on the target computer.\n\nstart(tg); pause(20); stop(tg);\n\nIn the Simulation Data Inspector, compare the signal data from the simulation runs and observe the change to the CPU overload rate.\n\nbdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/monitor-cpu-overload-rate.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtMonitorCPUOverloadRateExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxrate1.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxrate2.png"
        ]
    },
    {
        "title": "Specify Signal Ranges",
        "introduction": "Simulink\u00c2\u00ae blocks allow you to specify a range of valid values for their output signals. Specifying signal ranges help you to optimize data types and improve generated code. If you have Embedded Coder\u00c2\u00ae, Simulink Coder\u00e2\u0084\u00a2 can optimize the code that you generate from the model by taking into account the minimum and maximum values that you specify for signals and parameters. This optimization can remove algorithmic code and affect the results of some simulation modes such as SIL or external mode. For more information, see Optimize using the specified minimum and maximum values (Embedded Coder).",
        "chunks": [
            {
                "heading": "Blocks That Allow Signal Range Specification",
                "content": "The following blocks allow you to specify ranges for their output signals:\n\nAbsConstantData Store MemoryData Type ConversionDifferenceDiscrete DerivativeDiscrete-Time IntegratorGainIn Bus ElementInportInterpolation Using Prelookup1-D Lookup Table2-D Lookup Tablen-D Lookup TableMath FunctionMinMaxMultiport SwitchOut Bus ElementOutportProduct, Divide, Product of ElementsRelayRepeating Sequence InterpolatedRepeating Sequence StairSaturationSaturation DynamicSignal SpecificationSum, Add, Subtract, Sum of ElementsSwitch"
            },
            {
                "heading": "Work with Signal Ranges in Blocks",
                "content": "To specify signal ranges for most blocks, use the Output minimum and Output maximum parameters of a block to specify a range of valid values for the block output signal. Exceptions include the Data Store Memory, Inport, In Bus Element, Outport, Out Bus Element, and Signal Specification blocks, for which you use their Minimum and Maximum parameters to specify a signal range. See Blocks That Allow Signal Range Specification for a list of applicable blocks.\n\nTo access these parameters, use the Property Inspector (on the Modeling tab, under Design, click Property Inspector), the Model Data Editor (on the Modeling tab, click Model Data Editor), or the block dialog box.\n\nSpecify a minimum or maximum as an expression that evaluates to a scalar, real number with double data type. For example, you can use:\n\nA literal number such as 98.884. Implicitly, the data type is double.A numeric workspace variable (see Share and Reuse Block Parameter Values by Creating Variables) whose data type is double. Use this technique to share a minimum or maximum value between multiple data items.When you use a variable to set the Min or Max property of a Simulink.ValueType, Simulink.Signal, or Simulink.BusElement object, the current value of the variable is assigned to the object. The Min and Max properties of the object are not affected by future changes to the variable.\n\nThe scalar value that you specify applies to each element of a composite signal (for example, when the signal is nonscalar or a bus). For information about scalar expansion, see Scalar Expansion of Inputs and Parameters.\n\nTo leave the minimum or maximum of a signal unspecified, use an empty matrix [], which is the default value."
            },
            {
                "heading": "Specify Ranges for Modeling Constructs",
                "content": "If you use modeling constructs such as buses, data stores, and Stateflow\u00c2\u00ae charts, you can use different techniques to specify design range information. Use the information in the table.\n\nDescription of Target SignalTechnique and More InformationNumerically complex signalWhen you specify an Output minimum or Output maximum for a signal that is numerically complex, the specified minimum and maximum values apply separately to the real part and to the imaginary part of the complex number. If the value of either part of the number is less than the minimum, or greater than the maximum, the complex number is outside the specified range. No range checking occurs against any combination of the real and imaginary parts, such as (sqrt(a^2+b^2)).Signal elements in a busIf you assemble the bus by using a Bus Creator block, you can specify range information on the upstream blocks that feed the Bus Creator block.Regardless of the technique you use to assemble the bus, you can create a Simulink.Bus object and use it as the data type of the bus. In this case, consider specifying range information by using the Min and Max properties of the Simulink.BusElement objects that reside in the bus object. For more information, see Specify Bus Properties with Bus Objects.Signal in a MATLAB Function blockUse the Symbols pane and Property Inspector to specify the Minimum and Maximum properties of the variables. See Set General Variable Properties.Signal in a Stateflow chartSet the Minimum and Maximum properties of the corresponding Stateflow data. See Limit range (Stateflow).Signal that you associate with an object (such as a Simulink.Signal or Simulink.ValueType object)Set the Min and Max properties of the Simulink.Signal or Simulink.ValueType object.Data store (Data Store Memory block or Simulink.Signal object)For a Data Store Memory block, set the Minimum and Maximum block parameters. For a signal object, set the Min and Max properties."
            },
            {
                "heading": "Troubleshoot Signal Range Errors",
                "content": "Simulink provides a diagnostic named Simulation range checking, which you can enable to detect when signals exceed their specified ranges during simulation. When enabled, Simulink compares the signal values that a block outputs with both the specified range (see Work with Signal Ranges in Blocks) and the block data type. That is, Simulink performs the following check:\n\nDataTypeMin \u00e2\u0089\u00a4 MinValue \u00e2\u0089\u00a4 VALUE \u00e2\u0089\u00a4 MaxValue \u00e2\u0089\u00a4 DataTypeMax\n\nwhere\n\nDataTypeMin is the minimum value representable by the block data type.MinValue is the minimum value the block should output, specified by, e.g., Output minimum.VALUE is the signal value that the block outputs.MaxValue is the maximum value the block should output, specified by, e.g., Output maximum.DataTypeMax is the maximum value representable by the block data type.\n\nNoteIt is possible to overspecify how a block handles signals that exceed particular ranges. For example, you can specify values (other than the default values) for both signal range parameters and enable the Saturate on integer overflow parameter. In this case, Simulink displays a warning message that advises you to disable the Saturate on integer overflow parameter."
            },
            {
                "heading": "Enable Simulation Range Checking",
                "content": "To enable the Simulation range checking diagnostic:\n\nIn your model window, on the Modeling tab, click Model Settings.Simulink displays the Configuration Parameters dialog box.In the Select tree on the left side of the Configuration Parameters dialog box, click the Diagnostics > Data Validity category. On the right side under Signals, set the Simulation range checking diagnostic to error or warning.Click OK to apply your changes and close the Configuration Parameters dialog box.\n\nSee Simulation range checking for more information."
            },
            {
                "heading": "Simulate Models with Simulation Range Checking",
                "content": "To check for signal range errors or warnings:\n\nEnable the Simulation range checking diagnostic for your model (see Enable Simulation Range Checking).In your model window, click Run to simulate the model.Simulink simulates your model and performs signal range checking. If a signal exceeds its specified range when the Simulation range checking diagnostic specifies error, Simulink stops the simulation and generates an error (for example, in the Diagnostic Viewer).Otherwise, if a signal exceeds its specified range when the Simulation range checking diagnostic specifies warning, Simulink generates a warning message in the MATLAB\u00c2\u00ae Command Window. Each message identifies the block whose output signal exceeds its specified range, and the time step at which this violation occurs."
            },
            {
                "heading": "Signal Range Propagation for Virtual Blocks",
                "content": "Some virtual blocks (see Nonvirtual and Virtual Blocks) allow you to specify ranges for their output signals, for example, the Inport and Outport blocks. When the Simulation range checking diagnostic is enabled for a model that contains such blocks, the signal range of the virtual block propagates backward to the first instance of a nonvirtual block whose output signal it receives. If the nonvirtual block specifies different values for its own range, Simulink performs signal range checking with the tightest range possible. That is, Simulink checks the signal using the larger minimum value and the smaller maximum value.\n\nFor example, consider the following model:\n\nIn this model, the Constant block specifies its Output maximum parameter as 300, and that of the Inport block is set to 100. Suppose you enable the Simulation range checking diagnostic and simulate the model. The Inport block back propagates its maximum value to the nonvirtual block that precedes it, i.e., the Constant block. Simulink then uses the smaller of the two maximum values to check the signal that the Constant block outputs. Because the Constant block outputs a signal whose value (200) exceeds the tightest range, Simulink generates an error."
            },
            {
                "heading": "Unexpected Errors or Warnings for Data with Greater Precision or Range than double",
                "content": "When a data item (signal or parameter) uses a data type other than double, before comparison, Simulink casts the data item and each design limit (minimum or maximum value that you specify) to the nondouble data type. This technique helps prevent the generation of unnecessary, misleading errors and warnings.\n\nHowever, Simulink stores design limits as double before comparison. If the data type of the data item has higher precision than double (for example, a fixed-point data type with a 128-bit word length and a 126-bit fraction length) or greater range than double, and double cannot exactly represent the value of a design limit, Simulink can generate unexpected warnings and errors.\n\nIf the nondouble type has higher precision, consider rounding the design limit to the next number furthest from zero that double can represent. For example, suppose that a signal generates an error after you set the maximum value to 98.8847692348509014. At the command prompt, calculate the next number furthest from zero that double can represent.\n\nformat long 98.8847692348509014 + eps(98.8847692348509014)\n\nans = 98.884769234850921\n\nUse the resulting number, 98.884769234850921, to replace the maximum value."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/signal-ranges.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/sim_range_checking_diagnostic.png",
            "https://in.mathworks.com/help/simulink/ug/signal_range_prop_ex.png"
        ]
    },
    {
        "title": "Build and Download Real-Time Application by Using Run on Target",
        "introduction": "The example model is a real-time model of a damped oscillator, slrt_ex_osc_rt. To open the model, in the MATLAB\u00c2\u00ae Command Window, type: To generate C code, compile, link, and download the real-time application to the target computer, use the Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 build process available from the Simulink Editor Real-Time tab. After you enter changes in the Configuration Parameters dialog box, you can build the real-time application. For information about real-time application options, see Simulink Real-Time Options Pane. Target | Mux | load",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/build-and-download-with-run-on-target.html",
        "images": []
    },
    {
        "title": "Execution Modes for Real-Time Applications",
        "introduction": "The Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 RTOS has two mutually exclusive execution modes. For more information, see Force polling mode and Application. Thread Trigger | TLC Command-Line Options",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ug/execution-modes-for-real-time-applications.html",
        "images": []
    },
    {
        "title": "TLC Command-Line Options",
        "introduction": "TLC command-line options are model options set before code generation to configure the real-time application and the real-time RTOS. To set these options from the Code Generation pane in the Configuration Parameters dialog box, select Advanced Parameters. Type the option in the TLC command line options text box in this form: Prefix each option name with -a. Do not leave spaces around the equal sign. Do not place a comma between consecutive value assignments. To set these options from the Command Window, use the syntax: To read these options from the Command Window, use the syntax: To remove these options, use the syntax:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/ref/tlc-command-line-options.html",
        "images": []
    },
    {
        "title": "View Simulation Data in Simulation Data Inspector",
        "introduction": "You can use the Simulation Data Inspector to visualize data you generate throughout the design process, including data that you log during a simulation. You can also import test data and other recorded data into the Simulation Data Inspector to inspect and analyze it alongside the logged simulation data. For more information about importing data to the Simulation Data Inspector, see Import Data from Workspace or File into Simulation Data Inspector. Simulation data that you log in a Simulink\u00c2\u00ae model logs to the Simulation Data Inspector. The Simulation Data Inspector offers several types of plots, which allow you to easily create complex visualizations of your data. For more information, see Create Plots Using the Simulation Data Inspector.",
        "chunks": [
            {
                "heading": "View Logged Data",
                "content": "Many types of logged data automatically stream to the Simulation Data Inspector when you simulate a model. Data that streams to the Simulation Data Inspector is also available after simulation. Other types of logged simulation data only appear in the Simulation Data Inspector when the simulation is paused, stopped, or complete. To view these types of logged data, open the Configuration Parameters dialog box and, in the Data Import/Export pane, select Record logged workspace data in Simulation Data Inspector. For more information about logging simulation data, see Save Simulation Data.\n\nType of Simulation DataData That Can Be Viewed During and After SimulationData That Can Be Viewed Only After Simulation is Paused, Stopped, or CompleteOutputOutput data logged using Dataset formatOutput data logged in a format other than Dataset when the Record logged workspace data in Simulation Data Inspector parameter is selectedSignal dataSignal data logged using one of these techniques: Signal loggingA Record blockA To Workspace block When the Record logged workspace data in Simulation Data Inspector parameter is selected, signal data logged using: A To File blockA Scope block configured to log data to the workspace StateState data logged using Dataset formatState data logged in a format other than Dataset when the Record logged workspace data in Simulation Data Inspector parameter is selectedData storeAll data store dataNot applicable\n\nNoteWhen you log states and outputs using the Structure or Array format, you must also log time for the data to record to the Simulation Data Inspector.\n\nThe Simulation Data Inspector displays available data in a table in the Inspect pane. To plot a signal, select the check box next to the signal. You can modify the layout and add different visualizations to analyze the simulation data.\n\nThe Simulation Data Inspector manages incoming simulation data using the archive. By default, the previous run moves to the archive when you start a new simulation. You can plot signals from the archive, or you can drag runs of interest back into the work area."
            },
            {
                "heading": "View Complex Data",
                "content": "Open Live Script\n\nThe complexSignal model logs two complex signals. The Complex Square Wave signal is logged using an Outport block. The Complex Sine Wave signal is logged using signal logging. Open the model.\n\nmdl = \"complexSignal\"; open_system(mdl)\n\nSimulate the model. Then, plot the simulation data in the Simulation Data Inspector.\n\nout = sim(mdl); Simulink.sdi.plot(out);\n\nYou can control how to visualize a complex signal using the Properties pane in the Simulation Data Inspector. You can choose from these complex format options:\n\nMagnitudeMagnitude-PhasePhaseReal-Imaginary\n\nSelect the Complex Square Wave signal from the signal table. Then, in the Complex Format drop-down menu, select Real-Imaginary. If you select Magnitude-Phase or Real-Imaginary for the Complex Format, the Simulation Data Inspector plots both components of the signal. For signals in Real-Imaginary format, the Line Color specifies the color of the real component of the signal, and the imaginary component is a different shade of the Line Color.\n\nWhen you use signal logging to log data, you can also change the default complex format for the signal using the Instrumentation Properties for the signal in the model. To access the Instrumentation Properties for the Complex Sine Wave signal, right-click the logging badge for the signal and select Properties. From the Complex Format drop-down menu, select Magnitude-Phase.\n\nSimulate the model again to visualize the Complex Sine Wave signal in the Simulation Data Inspector using the Magnitude-Phase format.\n\nout = sim(mdl);"
            },
            {
                "heading": "View String Data",
                "content": "Open Live Script\n\nYou can log and view string data with your signal data in the Simulation Data Inspector. In the model stringData, the value of the sine wave block controls whether the switch sends a string reading Positive or Negative to the output. Open the model.\n\nmdl = \"stringData\"; open_system(mdl)\n\nSimulate the model.\n\nout = sim(mdl);\n\nOpen the Simulation Data Inspector.\n\nSimulink.sdi.view\n\nSelect the Sine Wave and Switch signals from the signal table to plot the results. The string signal is shown at the bottom of the graphical viewing area.\n\nSelect Show/hide data cursors to inspect how the string signal values correspond with the sine signal's values.\n\nWhen you plot multiple string signals on a plot, the signals stack in the order they were simulated or imported, with the most recent signal positioned at the top. For example, change the phase of the sine wave controlling the switch. Then, simulate the model again. In the Simulation Data Inspector, select all of the signals from both runs to visualize both simulation results on one plot. You can change the line color to better distinguish between the two runs. The string data from the second run is stacked on top of the string data from the first run."
            },
            {
                "heading": "View Multidimensional Data",
                "content": "Open Live Script\n\nYou can view and analyze multidimensional signal data in the Simulation Data Inspector. To view a signal with multidimensional signal values, use the array plot. The model MultiDim contains six Sine Wave blocks, each vertically displaced from the previous sine wave by one, connected to a Mux block. Output from the Mux block is logged to the Simulation Data Inspector using an Outport block.\n\nSimulate the model. Then, open the Simulation Data Inspector.\n\nmdl = \"MultiDim\"; sim(mdl); Simulink.sdi.view\n\nTo plot data on an array plot, click Visualizations and layouts . Then, select Array. When you plot a signal with multidimensional sample values on an array plot, a stem plot displays the value of each sample at a given time. The time is shown in the upper right corner of the plot. The dimensions of the signal are displayed in parentheses next to the signal name. For example, because the multidimensional signal MultiDimSig contains six channels, the array plot of the data has six markers.\n\nYou can also convert the representation of a multidimensional signal from a single signal with multidimensional sample values to a set of signals with scalar sample values called channels. Once converted to channels, you can plot the data using time plots, XY plots, maps, or sparklines. To see the difference between plotting the multidimensional signal on an array plot, and plotting the individual channels in a time plot, run the simulation again.\n\nsim(mdl);\n\nTo convert the multidimensional signal in the second run to channels, click the dimensions of the signal, shown in parenthesis, next to the signal name in the Simulation Data Inspector. Then, select Convert to channels.\n\nIn the Visualizations and layouts menu, select a 2x1 layout. In the lower subplot, plot the signal with multidimensional sample values from the first run in an array plot. In the upper subplot, plot the channels from the second run in a time plot. To view the values of each channel at a particular time, add a cursor to the time plot. To add one cursor to the subplot, click the arrow next to Show/hide data cursors . Then, choose One cursor.\n\nNotice that the sample values in the array plot change as you drag the cursor. As you move the cursor through time, the display of each sample value in the array plot changes to show the value of that element at that particular time. In this case, because both runs contain the same data, the values in the array plot match the values displayed by the cursor for each corresponding channel in the time plot. For example, when the cursor is positioned at 3.6 seconds, the time displayed in the upper-right corner of the array plot is also 3.6 and the value of the first sample in the array plot is equal to the value displayed by the cursor for the MultiDimSig(1) signal in the time plot.\n\nYou can also see the values in the array plot change over time by replaying the data. Click Show/hide replay controls . Then, click Replay .\n\nFor more information about inspecting and analyzing multidimensional signal data, including frame-based data, see Analyze Multidimensional Signal Data."
            },
            {
                "heading": "View Frame-Based Data",
                "content": "Some applications buffer several samples of a signal into a frame to process with a single computation instead of processing each sample in the frame separately. When you work with frame-based signals, you can analyze the data frame by frame, or you can remove the buffering and analyze the signal without the frames.\n\nProcessing data in frames rather than point by point provides a performance boost needed in some applications. When you log frame-based signals as sample-based, you can convert the frames in the Simulation Data Inspector after simulation. For more information about viewing frame-based data in the Simulation Data Inspector, see View Multidimensional Signals Using the Array Plot."
            },
            {
                "heading": "View Event-Based Data",
                "content": "Open Live Script\n\nYou can log or import event data to the Simulation Data Inspector. In this example, the model SimpleMessagesModel logs signal data and message data using signal logging. For more information about the model, see Animate and Understand Sending and Receiving Messages.\n\nmdl = \"SimpleMessagesModel\"; open_system(mdl)\n\nSimulate the model. During simulation:\n\nThe Sine Wave block generates the sine wave signal.Every 0.1 seconds, the Send block converts the value of the sine wave signal to a message and sends it to the Queue block. The Queue block sends messages to the Receive block.The Receive block generates the reconstructed sine wave signal.\n\nout = sim(mdl);\n\nPlot the data in the Simulation Data Inspector. The Simulation Data Inspector displays message data as a stem plot, where the value for the stem is the sample of the sine wave that was taken as the message payload for the given simulation time.\n\nSimulink.sdi.plot(out);"
            },
            {
                "heading": "Functions",
                "content": "\u2022 Simulink.sdi.createRun | Simulink.sdi.addToRun | Simulink.sdi.view | Simulink.sdi.plot\n\n\u2022 Inspect Simulation Data\n\u2022 Compare Simulation Data\n\u2022 Share Simulation Data Inspector Data and Views\n\u2022 Decide How to Visualize Data\n\u2022 Import Data from Workspace or File into Simulation Data Inspector"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/populate-sdi-with-your-data.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/sdi_view_logged.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewComplexDataExample_01.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewComplexDataExample_02.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewComplexDataExample_03.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewStringDataExample_01.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewStringDataExample_02.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewStringDataExample_03.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewStringDataExample_04.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewStringDataExample_05.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_01.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_02.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_03.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_04.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_05.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_06.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_07.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewMultidimensionalDataExample_08.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewEventBasedDataExample_01.png",
            "https://in.mathworks.com/help/examples/shared_sdi/win64/ViewEventBasedDataExample_02.png"
        ]
    },
    {
        "title": "External Code Integration of Libraries and C/C++ Code with Simulink Real-Time Models",
        "introduction": "",
        "chunks": [
            {
                "heading": "Considerations for Integrating Third-Party Libraries and External Code into Simulink Real-Time",
                "content": "When integrating code into Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2 applications, start by following the guidance in Build Integrated Code Within the Simulink Environment. Developers who integrate C/C++ code with Simulink Real-Time applications notice some differences when they migrate the code that they integrated with Simulink Real-Time applications from previous releases to R2020b and later releases. These differences include:\n\nIn release R2020a and previous releases, the On-Time RTOS on the Speedgoat\u00c2\u00ae target computer shared some libraries and system calls with Windows\u00c2\u00ae. In release R2020b and later releases, the QNX\u00c2\u00ae Neutrino\u00c2\u00ae RTOS on the target computer does not share libraries or system calls specific to Windows.In release R2020a and previous releases, developers could use Microsoft\u00c2\u00ae Visual Studio\u00c2\u00ae to compile libraries to integrate with Simulink Real-Time applications. In release R2020b and later releases, you cannot use the Microsoft Visual Studio compiler for this purpose. You can configure Microsoft Visual Studio to use the QNX Neutrino compiler from the Simulink Real-Time target support package.In R2020b and later releases, developers use cross-compiling to produce libraries on their development computer for deployment to their target computer."
            },
            {
                "heading": "Value of Upgrading Your C/C++ Code for Integration into Simulink Real-Time",
                "content": "By updating your C/C++ code for integration into your Simulink Real-Time application, you gain these benefits:\n\nLeverage the QNX Neutrino 64-bit and POSIX\u00c2\u00ae compatible RTOS.Code directly in C++ or wrap your legacy C code.Use the code editor of your choice.For instance, customizing Visual Studio Code with the source files and shipped QCC compiler from the Simulink Real-Time Target Support Package provides a similar experience to a full IDE.Leverage the precompiled QNX Neutrino libraries and headers that are included in Simulink Real-Time to extend the functionality of your real-time application.Integrate any C/C++ application based on modern build and package software such as CMake."
            },
            {
                "heading": "Approaches for C/C++ Code Integration into Simulink Real-Time",
                "content": "There are advantages and disadvantages to each of these external code integration approaches.\n\nApproach 1: Directly Call C/C++ Code. In this approach, you \u00e2\u0080\u008buse C Caller or C Function blocks in the model. For more information, see Integrate C/C++ Code Using C Function Blocks.\u00e2\u0080\u008b\n\nAdvantages\u00e2\u0080\u008b: There is no need to compile source code before building the model.\u00e2\u0080\u008bDisadvantages: This approach is \u00e2\u0080\u008bhard to use for complex projects that have many files and dependencies\u00e2\u0080\u008b.\n\nApproach 2: Build, link, and use static libraries (.a files)\u00e2\u0080\u008b\n\nAdvantages\u00e2\u0080\u008b: All required files are packed in the real-time application MLDATX file. In this approach, \u00e2\u0080\u008bthere is no need to install libraries on the target. And, this approach lets you \u00e2\u0080\u008bprotect your intellectual property.\u00e2\u0080\u008bDisadvantages\u00e2\u0080\u008b: This approach is non-modular. A change in the library requires rebuilding the whole real-time application\u00e2\u0080\u008b. Also, this approach tends to produce larger real-time application MLDATX files.\u00e2\u0080\u008b\n\nApproach 3: Build, deploy and use shared objects (.so files)\u00e2\u0080\u008b\n\nAdvantages\u00e2\u0080\u008b: This approach is modular. You can build the real-time application and shared object independently\u00e2\u0080\u008b. Also, this approach tends to produce smaller real-time application MLDATX files. And this approach lets you protect your intellectual property.\u00e2\u0080\u008bDisadvantages: \u00e2\u0080\u008bIn this approach, you need to access the target computer file system before running the real-time application and install (copy) the shared objects\u00e2\u0080\u008b to any of the common lib paths on the target computers."
            },
            {
                "heading": "Build Libraries from Source Code for Simulink Real-Time",
                "content": "To integrate external code in a real-time application, the most flexible approaches are to build static libraries or shared objects from source code.\n\nThe library build workflow is similar to the workflow used by most developers for release R2020a and previous releases. In those releases, the library build workflow for the target computer On-Time RTOS produced static libraries built with Microsoft Visual Studio and produced .lib files.You achieve better usability when working with complex C++ projects that have many dependencies and source code files.S-functions offer better granularity when handling third-party libraries in Simulink. S-functions enable the flexibility to use the same S-function source code with different platforms, including simulation on the desktop in different operating systems. The S-functions are deployed and function in real-time on a target computer.\n\nCross-compiling is compiling a library for a target operating system (for example, QNX Neutrino RTOS) on a development operating system (for example, Windows). Some cross-compiling considerations for Simulink Real-Time are:\n\nChoice of development environment. Many modern C++ projects use the CMake build environment. For more information, see the CMake website.Extensibility of development environment. For example, it is a common practice to extend most common CMake support for the QNX Neutrino RTOS by leveraging similarities with the UNIX\u00c2\u00ae OS and its POSIX compatibility.In your libraries, save cross-compiling libraries, including dependencies that might be already included in the Simulink Real-Time Target Support Package. These libraries can be linked to other C++ projects.\n\nThe suggested workflow for integration of complex C++ applications into Simulink Real-Time is:\n\nStart from a C++ project with CMake as the build environment.\u00e2\u0080\u008bSet the dependencies, such as headers and libraries, in your Simulink model.\u00e2\u0080\u008bOn the development computer, cross-compile libraries for the QNX Neutrino RTOS on the target computer.\u00e2\u0080\u008bCreate an S-function, for instance using the S-function Builder block or a handwritten C-MEX S-function, as the main function that calls the C++ functions defined in the header files and implemented in the compiled libraries for the QNX Neutrino RTOS\u00e2\u0080\u008b.Build the real-time application. \u00e2\u0080\u008bBy using SSH or FTP, copy your cross-compiled libraries to a location on the target computer where they can be found and loaded at run time. The recommended locations are /lib, /usr/lib, or /usr/local/lib.Load and run the real-time application."
            },
            {
                "heading": "External Code Integration for S-Functions and Simulink Real-Time",
                "content": "When you include static libraries or shared objects in S-functions for external code integration with a real-time application, there are some tips for your development.\n\nWhen building from Simulink:\n\nUse rtwmakecfg.m and makeInfo object to map libraries and header files. For more information, see Use makecfg to Customize Generated Makefiles for S-Functions.function makeInfo = rtwmakecfg\u00e2\u0080\u008b proj = currentProject;\u00e2\u0080\u008b rootPath = proj.RootFolder;\u00e2\u0080\u008b makeInfo.linkLibsObjs = {};\u00e2\u0080\u008b sysTarget = get_param(bdroot, 'RTWSystemTargetFile');\u00e2\u0080\u008b switch sysTarget\u00e2\u0080\u008b case 'speedgoat.tlc'\u00e2\u0080\u008b makeInfo.includePath = '<includePath>';\u00e2\u0080\u008b makeInfo.linkLibsObjs{end+1} = '<libraryPath>';\u00e2\u0080\u008b otherwise\u00e2\u0080\u008b error('No rtwmakecfg found for %s target file', sysTarget);\u00e2\u0080\u008b end\u00e2\u0080\u008b end\u00e2\u0080\u008bEnable linking for different target files.Use macros, such as SIMULINK_REAL_TIME, in your source code to add lines at compile time for real-time simulation. SIMULINK_REAL_TIME is useful to wrap the LOG function calls.\n\nWhen cross-compiling, use macros such as __unix__ and __QNXNTO__ in your source code to add lines at compile time."
            },
            {
                "heading": "Additional C/C++ Project for Simulink Real-Time",
                "content": "The eCAL Toolbox for Simulink project on github.com/mathworks/ecal-toolbox shows complete external code integration with Simulink Real-Time, including S-function wrappers, rtwmakecfg customization, and shared object compilation. You also can simulate this example on your development computer."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/external-code-integration-of-libraries-and-cc-code-with-simulink-real-time-models.html",
        "images": []
    },
    {
        "title": "Time-Based Scheduling and Code Generation",
        "introduction": "",
        "chunks": [
            {
                "heading": "Sample Time and Blocks that Compute State",
                "content": "The sample time of a block in a Simulink\u00c2\u00ae model specifies when the block produces output, and if appropriate, updates its internal state during simulation or generated code execution. The internal state of a block includes but is not limited to continuous and discrete states that Simulink computes and logs. For blocks that define discrete states Simulink computes the values of the states at each time step. Blocks that define continuous states rely on numerical integration for the computation of internal state values. A model can include continuous blocks, discrete blocks, or continuous and discrete blocks. Models that include both types of blocks are hybrid systems.\n\nTypically, you use continuous blocks to model equations in integral form in variable steps so that you can control the accuracy of simulations. MathWorks\u00c2\u00ae does not recommend using continuous blocks in models from which you intend to generate production code, especially for safety-critical applications. Continuous blocks rely on numerical integration to compute continuous state, which can impact determinism of software execution and numerical accuracy for the execution rate of the generated code. After achieving required results, you can convert continuous blocks to discrete blocks (see Discretization), which have a predictable number of steps because you know the fixed step size.\n\nEmbedded Coder\u00c2\u00ae does not support the use of continuous blocks by default, or for models configured to use a service code interface.\n\nIf you are using Embedded Coder (for example, if System target file is set to ert.tlc) to generate code from a model that includes continuous blocks, select the model configuration parameter Support: continuous time.\n\nFor more information about using Continuous and Discrete blocks in models from which you intend to generate code, see these pages:\n\nFor lists of blocks in the Continuous and Discrete block libraries, see Continuous and Discrete.Blocks Supported for Code Generation describes how to get information about Simulink built-in blocks and product-specific blockset blocks that you can use in models intended for code generation. If you are generating row-major code from a model, see Unsupported Blocks for Row-Major Code Generation.If you are generating code for variant choices of startup variant blocks that include continuous blocks, see Run Executables for Variant Blocks Without Recompiling Code for Changing Active Choices Using Startup Activation Time.For a custom system target file to support continuous time, you must modify the system target files as described in Customize System Target Files."
            },
            {
                "heading": "Multirate Systems and Rate Transitions",
                "content": "You can model single-rate and multirate discrete systems and hybrid continuous-discrete systems by setting block sample times that control the rate of block calculations and execution. Simulink provides considerable flexibility for designing multirate systems. For a multirate model to operate as expected in real time, the model must handle rate transitions between blocks configured to use different sample times.\n\nBy default, the Simulink engine returns errors during simulation if a model contains unprotected rate transitions. Use the diagnostic model configuration parameter Multitask data transfer to specify whether the Simulink engine displays a warning and returns an error after detecting an invalid transition.\n\nTo avoid rate transition errors, insert Rate Transition blocks between blocks configured to use different sample times. You can insert the Rate Transition blocks explicitly or you can configure a model so that the Simulink engine detects mismatched rate transitions during a diagram update and inserts hidden Rate Transition blocks for you. To instruct the Simulink engine to insert the blocks, select the model configuration parameter Automatically handle rate transition for data transfer.\n\nTo understand the importance of detecting and handling rate transitions, consider how Simulink simulations differ from real-time program execution."
            },
            {
                "heading": "Rate Transitions During Model Simulation",
                "content": "Before simulating a model, the Simulink engine orders the blocks in the model based upon their topological dependencies. This includes expanding virtual subsystems into the individual blocks they contain and flattening the model into a single list. Once this step is complete, each block executes in order.\n\nThe key to this process is the ordering of blocks. A block that produces output that is directly dependent on the block input (that is, a block with direct feedthrough) cannot execute until the block driving the input executes."
            },
            {
                "heading": "Rate Transitions During Real-Time Program Execution",
                "content": "A real-time program differs from a Simulink simulation in that the program must execute the model code synchronously with real time. Every calculation results in some computational delay. This means the sample intervals cannot be shortened or lengthened (as they can be in a Simulink simulation), which leads to less efficient execution. Rate transitions are relevant when multiple tasks might access the same data simultaneously.\n\nConsider this timing diagram.\n\nIn the diagram, the vertical lines that are labeled t0, t1, and t2 indicate sample time hits. The blue areas represent execution by the Simulink engine. The blank spaces show time during which the processor is idle.\n\nA processing inefficiency occurs in the sample interval from times t1 to t2. That interval cannot be compressed to increase execution speed because, by definition, sample times are clocked in real time.\n\nYou can circumvent the inefficiency by configuring code generation for a model in multitasking mode. Multitasking mode defines tasks with different priorities to execute parts of the model code that have different sample rates. See Tasking Modes."
            },
            {
                "heading": "Discretization",
                "content": "Discretization is the process of replacing continuous blocks with discrete equivalents. If a model includes continuous blocks and you are ready to generate production code or perform hardware-in-the-loop (HIL) simulations, consider these options for discretizing the model.\n\nIf you have a Control System Toolbox\u00e2\u0084\u00a2 license, Version 5.2 or higher, use the Simulink Model Discretizer app to:Identify continuous blocks in a model.Change block parameters from continuous to discrete.Apply discretization settings to continuous blocks.Create variant subsystems that contain multiple discretization candidates and original continuous blocks.Switch between discretization candidates and evaluate model simulation results.For an example, see Discretize a Model with the Model Discretizer.If you have a Control System Toolbox or System Identification Toolbox\u00e2\u0084\u00a2 license, use the c2d function to discretize a state and then place the discrete state in a model."
            },
            {
                "heading": "Tasking Modes",
                "content": "For models configured to use a fixed-step solver, the code generator supports two tasking modes (modes of execution) for periodic sample times: single-tasking and multitasking. See Configure Tasking Mode for information on how to switch between the two modes."
            },
            {
                "heading": "Single-Tasking Mode",
                "content": "Setting up a model in single-tasking mode can:\n\nSimplify the model.Negatively impact execution speed.\n\nIn single-tasking mode, the base sample rate for a model must define a time interval that is long enough to execute one step of the model (that is, all blocks in the model) within that interval.\n\nThis timing diagram shows the inefficiency inherent when using single-tasking mode.\n\nIn the diagram, the vertical lines that are labeled t0 to t4 indicate sample time hits. The blue areas represent execution by the Simulink engine. The blank spaces show time during which the processor is idle.\n\nFor more information about single-tasking execution and examples, see Tasking Modes and Execution Order."
            },
            {
                "heading": "Multitasking and Pseudomultitasking Modes",
                "content": "When periodic tasks execute in multitasking mode, by default the blocks with the fastest sample rates execute as the task with the highest priority, the next fastest blocks execute as the task with the next higher priority, and so on. Time available between the processing of high-priority tasks is used for processing lower priority tasks. This results in more efficient program execution.\n\nWhen tasks are asynchronous rather than periodic, there might not be a relationship between sample rates and task priorities; the task with the highest priority need not have the fastest sample rate. You specify asynchronous task priority numbers by using Async Interrupt and Task Sync blocks. You can switch the sense of what priority numbers mean (that is, whether higher or lower priority number correspond to higher priority tasks) by selecting or clearing the model configuration parameter Higher priority value indicates higher task priority.\n\nIn multitasking environments that include a real-time operating system, you can define separate tasks and assign them priorities. For bare-metal target hardware where a real-time operating system is not present, you cannot create separate tasks. However, generated application modules implement what is effectively a multitasking execution scheme by using overlapping interrupts and programmatic context switching.\n\nThis means that an interrupt can occur while another interrupt is currently in progress. When this happens, the current interrupt is preempted, the floating-point unit (FPU) context is saved, and the higher priority interrupt executes its higher priority (that is, faster sample rate) code. Once complete, control returns to the preempted interrupt service routine (ISR).\n\nIn the next two timing diagrams:\n\nVertical solid lines that are labeled t0 to t4 indicate sample time hits. Blue areas represent execution by the Simulink engine. Blank spaces show time during which the processor is idle.Hashed areas indicate task preemption by a higher priority task.Vertical dotted lines with downward pointing arrows indicate the release of control of the CPU to a lower priority task.Vertical dotted lines with upward pointing arrows indicate preemption by a higher priority task.\n\nThis diagram shows how timing of tasks in multirate systems are handled in a multitasking environment.\n\nThe next diagram shows how overlapped interrupts are used to implement pseudomultitasking. In this case, Interrupt 0 does not return until after Interrupts 1, 2, and 3 finish executing. The dark lines the execution paths of the interrupts\n\nNoteA model that is multirate and uses multitasking cannot reference a multirate model that uses single-tasking.\n\nFor information about multitasking execution and examples, see Tasking Modes and Execution Order."
            },
            {
                "heading": "Tasking Considerations",
                "content": "Single-tasking programs require longer sample intervals because all computations must execute within each clock period. This can result in inefficient use of available CPU time.If a model is large and has many blocks executing at different rates, multitasking mode can improve the efficiency of your program. If a model is dominated by a single rate and only a few blocks execute at a slower rate, multitasking can degrade performance. The overhead incurred from task switching can be greater than the time required to execute the slower blocks. In this case, it is more efficient to execute all blocks at the dominant rate.If a model can benefit from multitasking execution, add Rate Transition blocks (or instruct the Simulink engine to do so) to generate expected results."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/time-based-scheduling-and-code-generation.html",
        "images": []
    },
    {
        "title": "Inspect Variable-Size Signals on Simulink Models",
        "introduction": "",
        "chunks": [
            {
                "heading": "Variable-Size Signal Generation and Operations",
                "content": "This example model shows how to create a variable-size signal from multiple fixed-size signals and from a single data signal. It also shows some of the operations you can apply to variable-size signals.\n\nFor a complete list of blocks that support variable-size signals, see Simulink Block Support for Variable-Size Signals.\n\nIn the MATLAB\u00c2\u00ae Command Window, typeopenExample('sldemo_varsize_basic') varSize = get_param(outPortHandle,'CompiledPortDimensionsMode')In the Simulink\u00c2\u00ae Editor, on the Debug tab, select Information Overlays > Signal Dimensions. Run a simulation or press Ctrl-D.The Simulink Editor displays the signal dimensions and line styles. See Signal Basics for an interpretation of signal line styles.So that you can see the names of the blocks in the model, on the Format tab, clear Auto > Hide Automatic Block Names."
            },
            {
                "heading": "Create a Variable-Size Signal from Fixed-Size Signals",
                "content": "One way to create a variable-size signal is to use the Switch block. The input signals to the Switch block can differ in their number of dimensions and in their size.\n\nOutput from the Switch block is a 2-D variable-size signal with a maximum size of 3x2. When you select the Allow different data input sizes parameter on the Switch block, Simulink does not expand the scalar value from the Constant block named Constant1."
            },
            {
                "heading": "Save Variable-Size Signal Data",
                "content": "You could add a To Workspace block to the output from the Switch block. Since the model already has a To Workspace block, the second To Workspace block would save data to a signal array named simout2 The values field logs the actual signal values. If logged signal data is smaller than the maximum size, values are padded with NaNs or appropriate values. To obtain these signal values, type:\n\nsimout2.signals.values ans(:,:,1) = 1 -1 -2 2 -3 3 ans(:,:,2) = 1 -1 -2 2 -3 3 ans(:,:,3) = 0 NaN NaN NaN NaN NaN\n\nThe valueDimensions field logs the dimensions of a variable-size signal. To obtain the dimensions, type:\n\nsimout2.signals.valueDimensions\n\nThe signal dimensions for the first three time steps are shown.\n\nans = 3 2 3 2 1 1"
            },
            {
                "heading": "Create a Variable-Size Signal from a Single Data Signal",
                "content": "The data signal (Constant5) is a 3x4 matrix. The Pulse Generator block represents a control signal that selects a starting and ending index value ( [1 2] or [1 3]). The Selector block then uses the index values to select different parts of the data signal at each time step and output a variable-size signal."
            },
            {
                "heading": "View Changes in Signal Size",
                "content": "The output from the Selector block is either a 2x2 or 3x3 matrix. Because the maximum dimension for a variable-size signal is the 3x4 matrix from the data signal, the logged output signals are padded with NaNs.\n\nUse the Probe or Width blocks to inspect the current dimensions and width of a variable-size signal. In addition, you can display variable-size signals on Scope blocks and save variable-size signals to the workspace using the To Workspace block."
            },
            {
                "heading": "Process Variable-Size Signals",
                "content": "The remainder of the model shows various operations that are possible with variable-size signals. Operations include using the Gain, Sum, Math Function, and Matrix Concatenate blocks. You can connect variable-size signals with the From, Goto, Bus Assignment, Bus Creator, and Bus Selector blocks."
            },
            {
                "heading": "Variable-Size Signal Length Adaptation",
                "content": "This example model corresponds to a hypothetical system where the model adapts the length of a signal over time. Length adaptation is based on the value of a control signal. When the control signal falls within one of three predefined ranges, the fixed-size raw data signal changes to a variable-size data signal.\n\nThe variable-size signal connects to a processing block, where blocks that support variable-size signals operate on it. A MATLAB Function block with both input and output signals of variable size allow more flexibility than other blocks supporting variable-size signals. See Simulink Block Support for Variable-Size Signals.\n\nTo open the example model, in the MATLAB Command Window, type:\n\nopenExample('sldemo_varsize_dataLengthAdapt')\n\nSo that you can see the names of the blocks, in the model, on the Format tab, clear Auto > Hide Automatic Block Names."
            },
            {
                "heading": "Creating a Variable-Size Signal by Adapting the Length of a Data Signal",
                "content": "This model generates a data signal and converts the signal to a variable-size signal. The size of the signal depends on the value of a control signal. The raw data signal is a column vector with values from 1 to 9.\n\n[1:9].' ans = 1 2 3 4 5 6 7 8 9\n\nIn the Length Adaptation subsystem, the Signal Size subsystem generates an index based on the quality value from the Size Selection subsystem (In2). The Data Selector block uses the starting and ending indices to adapt the length of the data signal (In1) and output a variable-size signal."
            },
            {
                "heading": "Processing a Variable-Size Signal",
                "content": "The center section of the model processes the variable-size signal. The MATLAB Function block adds zeros between the data values in a way that is similar to upsampling a signal. The dimension of the signal changes from 9 to 18. The Math Function blocks show various manipulations you can do with variable-size signals."
            },
            {
                "heading": "Visualizing a Variable-Size Signal",
                "content": "The right section of the model determines the signal width (size) and uses a scope to visualize the width and the processed data signal."
            },
            {
                "heading": "Mode-Dependent Variable-Size Signals",
                "content": "This example model represents a system that has three operation modes. For each mode, the data signal to process has a different size.\n\nThe Process subsystem in this model receives a variable-size signal where the size of the signal depends on the operation mode of the system. For each mode change, the Stateflow\u00c2\u00ae chart, Mode Control Logic, detects when the data signal size changes. It then generates a function call to reset the blocks in the Process subsystem.\n\nTo open the model, In the MATLAB Command Window, type:\n\nopenExample('sldemo_varsize_multimode')\n\nSo that you can see the names of the blocks, in the model, on the Format tab, clear Auto > Hide Automatic Block Names."
            },
            {
                "heading": "Creating a Variable-Size Signal Based on Mode",
                "content": "The Mode Selection subsystem determines the mode for processing a data signal and outputs a mode value (1, 2, or 3). This value helps to select the length of the data signal using the Size Selection and Data subsystems.\n\nThe Size Selection subsystem creates an index value from the mode value. In this example, the index values are [1 3], [1 2], and [1 1].\n\nThe Data subsystem takes a data signal (Constant block) and selects part of the data signal dependent on the mode. The output is a variable-size signal with a matrix size of 3x3, 2x2, and 1x1.\n\nThe dimensions of the raw data signal (Constant block) is a 3x3. After connecting a To Workspace block to a signal line, you can view the signal in the MATLAB Command Window by typing:\n\nsimout.signals.values ans(:,:,1) = 1 4 7 2 5 8 3 6 9\n\nThe variable-size signal generated from the Data subsystem is also a 3x3 matrix. For shorter signals, the matrix is padded with NaNs.\n\nsimout.signals.values ans(:,:,1) = 1 NaN NaN NaN NaN NaN NaN NaN NaN ans(:,:,2) = 1 4 NaN 2 5 NaN NaN NaN NaN ans(:,:,3) = 1 4 7 2 5 8 3 6 9"
            },
            {
                "heading": "Processing a Variable-Size Signal with a Conditionally Executed Subsystem",
                "content": "Because the Process subsystem contains a Delay block, the subsystem resets and repropagates the signal at each time step. This model uses a Stateflow chart to detect a signal size change and reset the Process subsystem.\n\nIn the function block dialog, and from the Propagate sizes of variable-size signals list, choose Only when enabling. When the model enables this subsystem, selecting this option directs the Simulink software to propagate sizes for variable-size signals inside the conditionally executed subsystem. Signal sizes can change only when they transition from disabled to enabled. For an explanation of handling signal-size changes with blocks containing states, see How Variable-Size Signals Propagate.\n\nThe Stateflow chart determines if there is a change in the size of the signal. The function size_detect calculates the width of the variable-size signal at each time step, and compares the current width to the previous width. If there is a change in signal size, the chart outputs a function-call output event that resets and repropagates the signal sizes within the Process subsystem."
            },
            {
                "heading": "Visualizing Data",
                "content": "Use the Probe block to visualize signal size and signal dimension.\n\nSince the signals are n x n matrices, the signal dimension lines overlap in the Scope display.\n\nYou can use a Display block and the Simulink Debugger to visualize signal values at each time step."
            },
            {
                "heading": "S-Functions Using Variable-Size Signals",
                "content": ""
            },
            {
                "heading": "Level-2 MATLAB S-Function with Variable-Size Signals",
                "content": "Both level-2 MATLAB S-functions and C S-functions support variable-size signals when you set the DimensionMode for the output port to Variable. You also need to consider the current dimension of the input and output signals in the input and output update methods.\n\nTo open this example model, in the MATLAB Command Window, type:\n\nmsfcndemo_varsize\n\nThe enabled subsystem includes a level-2 MATLAB S-function which shows how to implement a block that holds its states until reset. Because this block contains states and delays the input signal, the input size can change only when a reset occurs.\n\nThe Expand block is a level-2 MATLAB S-function that takes a scalar input and outputs a vector of length indicated by its input value. The output is by 1:n where n is the input value."
            },
            {
                "heading": "C S-Function with Variable-Size Signals",
                "content": "To open this example model, in the MATLAB Command Window, type:\n\nsfcndemo_varsize\n\nThe enabled subsystems have two S-functions:\n\nsfun_varsize_holdStatesUntilReset is a C S-function that has states and requires its DWorks vector to reset whenever the sizes of the input signal changes.sfun_varsize_concat1D is a C S-function that implements the concatenation of two unoriented vectors. You can use this function within an enabled subsystem by itself."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/simulink-models-using-variable-size-signals-demos-modeling-features-variable-size-signals-or-type-varsizedemos.html#br9ecac-1",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_basic.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_basic_create_signal.gif",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_basic_part_data.gif",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_datalengthadapt01.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_datalengthadapt_sizeselection.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_datalengthadapt_lengthadaptation.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_datalengthadapt_process.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_datalengthadapt_scope.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_mode01.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_sizeselection.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_datasubsystem.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_process.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_chart.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_probescope.gif",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_scope.png",
            "https://in.mathworks.com/help/simulink/ug/sldemo_varsize_multimode_display.gif",
            "https://in.mathworks.com/help/simulink/ug/msfcndemo_varsize.png",
            "https://in.mathworks.com/help/simulink/ug/sfcndemo_varsize.png"
        ]
    },
    {
        "title": "Specify Block Properties",
        "introduction": "For each block in a model, you can set general block properties, such as: To set block properties, use the Property Inspector. You can set properties in the Properties and Info tabs of the Property Inspector when the block is selected. Alternatively, you can use the Block Properties dialog box.",
        "chunks": [
            {
                "heading": "Set Block Annotation Properties",
                "content": "In the Property Inspector, use the Block Annotation section to display the values of selected block parameters in an annotation. The annotation appears below the block icon.\n\nEnter the text of the annotation in the text box. You can use a block property token in the annotation. The value for the property replaces the token in the annotation in the model. To display a list of tokens that you can use in an annotation, type % in the text box. The parameters that are valid for the selected block appear. See Common Block Properties and Programmatically Specify Block Parameters and Properties.\n\nSuppose that you specify the following annotation text and tokens for a Product block:\n\nMultiplication = %<Multiplication> Sample time = %<SampleTime>\n\nIn the Simulink\u00c2\u00ae Editor, the block displays this annotation:\n\nYou can also create block annotations programmatically. See Create Block Annotations Programmatically."
            },
            {
                "heading": "Specify Block Callbacks",
                "content": "Use the Callbacks section to specify block callbacks. Callbacks are MATLAB\u00c2\u00ae commands that execute when a specific model action occurs, such as when you select or delete a block. For more information on callbacks, see Customize Model Behavior with Callbacks.\n\nSelect the block whose callback you want to set.In Properties tab of the Property Inspector, in the Callbacks section, select the function that you want to assign the callback to. For example, select OpenFcn to specify a behavior for double-clicking a block.In the text box, enter the command that you want to execute when that block function occurs.After you assign a callback to a function, the function displays an asterisk next to it in the list. The asterisks helps you to see the functions that have callbacks assigned to them.NoteAfter you add an OpenFcn callback to a block, double-clicking the block does not open the block dialog box. Also, the block parameters do not appear in the Property Inspector when the block is selected. To set the block parameters, select Block Parameters from the block context menu."
            },
            {
                "heading": "Set a Block Callback Programmatically",
                "content": "This example shows how to use the OpenFcn callback to execute MATLAB scripts when you double-click a block. For example, in a MATLAB script you can define variables or open a plot of simulated data.\n\nTo create a callback programmatically, select the block to which you want to add this property. Then, at the MATLAB command prompt, enter a command in this form:\n\nset_param(gcb,'OpenFcn','myfunction')"
            },
            {
                "heading": "Specify Block Execution Order, Execution Priority and Tag",
                "content": "In the block properties, you can specify the block execution order, execution priority and identify the block by assigning a value to the Tag property.\n\nExecution Order\u00e2\u0080\u0094 Specify execution order of blocks relative to other blocks. By default, blocks execute based on priority. You can use this property to designate blocks at the root level of a model or inside a nonvirtual subsystem to execute first or last relative to other blocks. You can set the block execution order through Block Properties dialog. In the Block Properties dialog, from the Execution Order list, select Based on Priority, First or Last per your modeling requirements. For more information, see Specify Blocks to Execute First or Last.Priority \u00e2\u0080\u0094 Specify the execution priority of the block relative to other blocks. Specify a numerical value. A smaller number indicates a higher priority. This option is available only when the Execution Order is set to Based on priority. For more information, see Set Priority in Execution Order of Blocks.Tag \u00e2\u0080\u0094 Specify an identifier for the block. Specify text to assign to the block Tag property. Setting this property is useful for finding the block in the model by searching or programmatically using find_system. See Explore Model Hierarchy.\n\nNoteIn determining execution priority, Simulink compares the Priority of blocks only to that of other blocks in the same block diagram, even if the block diagram is a virtual subsystem, and only to other blocks that have their Priority explicitly set."
            },
            {
                "heading": "Use Block Description to Identify a Block",
                "content": "The Info tab displays information about the block type. The block author provides this description.\n\nYou can also enter a description in the Description box to provide information about the block instance.\n\nIf you add a description, you can set up your model display so that the description appears in a tooltip when you hover over the block. To enable this tooltip, on the Debug tab, select Information Overlays > Description in Tooltip .The Description property can help you to find a block by searching. See Simulink Editor."
            },
            {
                "heading": "Create Block Annotations Programmatically",
                "content": "You can use a block AttributesFormatString parameter to display specified block parameter values below the block. Common Block Properties and Programmatically Specify Block Parameters and Properties describe the parameters that a block can have. Use the Simulink set_param function to set this parameter to the attributes format that you want.\n\nThe attributes format can be any text that has embedded parameter names. An embedded parameter name is a parameter name preceded by %< and followed by >, for example, %<priority>. Simulink displays the attributes format text below the block icon, replacing each parameter name with the corresponding value. You can use line-feed characters (\\n) to display each parameter on a separate line. For example, select a Gain block and enter this command at the MATLAB command prompt:\n\nset_param(gcb,'AttributesFormatString','pri=%<priority>\\ngain=%<Gain>')\n\nThe Gain block displays this block annotation:\n\nIf a parameter value is not text or an integer, N/S (for not supported) appears in place of the value. If the parameter name is not valid, Simulink displays ??? in place of the value."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/block-properties-dialog-box.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/block_annot.png",
            "https://in.mathworks.com/help/simulink/ug/block_annotation_programmatic.png"
        ]
    },
    {
        "title": "Generate Code from a Partitioned Model",
        "introduction": "Partitioning and scheduling a model has an impact on the order of the function calls in the generated code. Using the Schedule Editor to edit the schedule of a rate-based model or a referenced export-function model, the order of the functions in the generated code depends on the specified schedule in the Schedule Editor. The resulting code shows every partition as an entry point. The generated code does not include the scheduler and it must be provided by the user. To see the impact of the Schedule Editor on the generated code, use the model that is created in Create Rate-Based Model. In the generated code, the order of the functions depends on the schedule specified in the Schedule Editor. Schedule Editor",
        "chunks": [],
        "link": "https://in.mathworks.com/help/simulink/ug/generate-code-from-a-partitioned-model.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/se_codegen_dd.png",
            "https://in.mathworks.com/help/simulink/ug/rate_based_codegen.png"
        ]
    },
    {
        "title": "Troubleshoot Signal Data Logging from Send and Receive Blocks",
        "introduction": "A model uses Send and Receive blocks. It would be helpful to view signal data from the message line (output of send or input of receive) in the Simulation Data Inspector. Unexpected data appears when a message line in Simulink Real-Time Explorer is selected for streaming to the Simulation Data Inspector. File Log",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "There are some guidelines to data logging message line signals:\n\nMessage line signals that are marked for logging with the Simulation Data Inspector display the data accurately in the Simulation Data Inspector.Message line signals that are connected to File Log blocks display the data accurately in the Simulation Data Inspector.Message line signals that are selected for dynamic streaming with an instrument object\u00e2\u0080\u0094either by selecting the signals in Simulink Real-Time Explorer or adding the signals by using the Application object API\u00e2\u0080\u0094do not display the data accurately in the Simulation Data Inspector or in App Designer instrument panel applications.\n\nFor more information about message lines, see Animate and Understand Sending and Receiving Messages."
            },
            {
                "heading": "Try This Workaround",
                "content": "To get accurate display of message line signals in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-send-and-receive-blocks.html",
        "images": []
    },
    {
        "title": "Implement Pipelining in Simulink - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Configure Model for Concurrent Execution",
                "content": "Open the ex_task_parallelism_initial model.Convert areas in this model to referenced models. Use the same referenced model to replace each of the functional components that process the input."
            },
            {
                "heading": "Set Model Configuration Parameters",
                "content": "Click Configure Tasks. In the Concurrent Execution dialog box, in the right pane, select the Enable explicit model partitioning for concurrent behavior check box. With explicit partitioning, you can partition your model manually.On the Modeling tab, click Model Settings.Select Code Generation > Interface > Advanced parameters. Clear the MAT-file logging check box.Select Solver, set Type to Fixed-step, and click Apply.On the Solver pane, expand Solver details. Check that Periodic sample time constraint is set to Unconstrained. Under Tasking and sample time options, select Allow tasks to execute concurrently on target."
            },
            {
                "heading": "Partition Model Using Explicit Partitioning",
                "content": "Partition the top model.\n\nIn the Concurrent Execution tree, under Tasks and Mapping, select CPU. Click Add task three times to add three new tasks."
            },
            {
                "heading": "Map Blocks to Tasks",
                "content": "In the Concurrent Execution tree, select Tasks and Mapping. On the Map block to tasks pane:\n\nUnder Block: Input, click select task and select Periodic: Task. Under Block: Function 1, select Periodic: Task1. Under Block: Function 2, select Periodic: Task2. Under Block: Output, select Periodic: Task.\n\nThis action maps your partitions to the tasks you created. The Input and Output model blocks are on one task. Each functional component is assigned a separate task."
            },
            {
                "heading": "Finalize Model",
                "content": "Close the Concurrent Execution dialog box."
            },
            {
                "heading": "Share Configuration with Referenced Models",
                "content": "Apply configuration parameters to all referenced models."
            },
            {
                "heading": "Initialize Data Dictionary to Store Configuration Set",
                "content": "Create a Simulink.data.dictionary.Entry object that represents the configuration set, which is an entry in the dictionary. For this example, suppose the name of the dictionary is myData.sldd and the name of the Simulink.ConfigSet object is myConfigs.Store a copy of the target Simulink.ConfigSet object in a temporary variable.Save changes made to the dictionary."
            },
            {
                "heading": "Set Up Configuration Reference",
                "content": "Create a freestanding configuration set in the base workspace by copying the active configuration set of the model.Create a separate configuration reference for the top model and each reference model. To point the reference to your freestanding configuration, set the SourceName property to freeConfigSet, the variable that represents your configuration.Attach the configuration reference to each model by using the ConfigSetRef object. To use the configuration reference in the model, activate it for each model.\n\nFor more information, see Share a Configuration with Multiple Models, Automate Model Configuration by Using a Script, and Make Changes to Configuration Set Stored in Dictionary.\n\nUpdate your model to see the tasks mapped to individual model blocks.\n\nNotice that delays are introduced between different tasks, indicated by the z-1 badge. Introducing these delays may cause different model outputs in Simulink. Ensure that your model has an expected output on simulating the parallelized model."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/implement-pipelining-in-simulink.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementPipeliningInSimulinkExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementPipeliningInSimulinkExample_02.png"
        ]
    },
    {
        "title": "Troubleshoot Gaps in Streamed Data",
        "introduction": "A real-time application is producing a live streaming overload while attempting to stream signal data at a high rate.",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "Live streaming from a real-time application does not guarantee all the data appears in the Simulation Data Inspector. Live stream instrumentation runs at a lower priority than the real-time application. So, data sent by live streaming could be dropped if the development computer to Speedgoat\u00c2\u00ae target computer connection cannot keep up.\n\nIf a live stream overload occurs, you could see noticeable gaps in the data in the Simulation Data Inspector or see that some time steps are lost when you export data from the Simulation Data Inspector."
            },
            {
                "heading": "Try This Workaround",
                "content": "The issue is caused by high data rates and live streaming of data.\n\nTo workaround the issue:\n\nModify the real-time application to decrease the data rate for live streaming data. To do this, you could increase the sample rate, instrument fewer signals, or increase the decimation of instrumented signals. Change the real-time application to use file logging instead of live streaming. File logging is capable of logging higher data rates without dropping data."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-gaps-in-streamed-data.html",
        "images": []
    },
    {
        "title": "Control and Display Execution Order",
        "introduction": "The execution order for a model is the order in which the software invokes the block output methods during simulation. The software determines this order during a model update, which you can initiate by clicking Update Model on the Modeling tab. The software also updates the model during simulation. You cannot set the execution order, but you can assign priorities to nonvirtual blocks to indicate their execution order relative to other blocks in the corresponding block diagram. Some nonvirtual blocks do not support block priorities. For example, the software ignores priorities set on these blocks: If a priority is set on these blocks, the Block priority violation configuration parameter setting determines whether you receive a warning or error. The software tries to honor block priority settings unless there is a conflict with data dependencies. To confirm the results of the priorities you have set or to debug your model, display and review the execution order of your nonvirtual blocks and subsystems. For more information about block methods and execution, see:",
        "chunks": [
            {
                "heading": "Execution Order viewer",
                "content": "On the Debug tab, select Information Overlays > Execution Order. The Execution Order viewer opens in a pane on the right side of the Simulink\u00c2\u00ae Editor.\n\nThe Execution Order viewer displays information based on the latest compiled execution order.\n\nSystem Index \u00e2\u0080\u0094 Unique value within a model that represents the current system or nonvirtual subsystem. For the top-level model, the system index is 0. For each nonvirtual subsystem, the system index is a positive integer.Blocks that are directly inside the nonvirtual subsystem have the same system index as the subsystem. To determine whether subsystems are part of the same system within a model, compare their system indexes.In model reference hierarchies, the same system index may be used multiple times. It remains unique only within each model of the hierarchy.Execution Order Block List \u00e2\u0080\u0094 List of blocks in order of their task-based execution order. The block list provides complete execution order information for the selected task, providing more information than the block diagram displays. For example, the list includes hidden blocks and blocks in subsystem block diagrams.Task ID \u00e2\u0080\u0094 Unique identifier for each task in the current system. Each task corresponds to a group of blocks that execute in a set order relative to each other based on their derived sample time information. A single Task ID can contain blocks with multiple different types of sample times. Execution order displays blocks with different types of constant sample times in separate tasks. For example, Simulink blocks with constant sample times of [Inf 0] and [Inf Inf] are displayed in Task 1 and Task 2, respectively. For more information about sample times, see Constant Sample Time. To obtain the sample time information programmatically, use get_param function.get_param('model_name/block_name','CompiledSampleTime') For more information, see Block Compiled Sample Time.For fixed-step sizes, the Treat each discrete rate as a separate task configuration parameter determines whether blocks with discrete rates execute in one or multiple tasks.\n\nTo update execution order information for a model that has changed since its last compile, recompile the model. In the Execution Order viewer, click the Recompile model to update execution order information button .\n\nTo highlight the blocks that belong to a task and display their execution order, select the task in the Execution Order viewer. By default, the software selects the first task that corresponds to the active block diagram.\n\nNoteStarting in R2023b, the execution order display no longer highlights signal lines and virtual blocks for a selected task. For more information about virtual blocks see, Nonvirtual and Virtual Blocks.\n\nWhen the active block diagram does not contain any blocks that execute as part of a given task, you cannot select the task in the Execution Order viewer. The active block diagram may contain virtual blocks, such as Inport blocks, that are part of this task.\n\nTo hide the highlighting and execution order, click the Clear Highlighting button ."
            },
            {
                "heading": "Navigation from Blocks to Tasks",
                "content": "To display the tasks in which a block executes, click on a block.\n\nThe task numbers in the label are links that you can click to select the corresponding task in the Execution Order viewer. When a model has many tasks, these links provide an alternative to scrolling through the list of tasks in the Execution Order viewer.\n\nTo compare tasks among blocks, select multiple blocks."
            },
            {
                "heading": "Execution Order Notation",
                "content": "The block diagram displays a number at the top-right corner of each nonvirtual block. These numbers indicate the order in which the blocks execute. The first block to execute has the lowest execution order, which is usually 1. The displayed execution order may skip numbers, but the blocks always execute in order of the visible numbers. Suppose a task displays execution orders 1, 2, and 4. The block labeled 1 executes before the block labeled 2, which executes before the block labeled 4.\n\nFor example, in this model, the block execution order ranges from 1 to 12, with each nonvirtual block receiving an execution order."
            },
            {
                "heading": "Virtual and Nonvirtual Subsystems",
                "content": "Virtual Subsystem blocks exist only graphically and do not execute. Consequently, they are not part of the execution order. Creating virtual subsystems can affect the execution order of blocks when the blocks are sorted by block path. Each block within a virtual subsystem executes as an atomic unit and has an execution order in the context of the root-level model or, if the virtual subsystem is inside a nonvirtual subsystem, in the context of the parent nonvirtual subsystem. For virtual subsystems, block execution order within the subsystem is listed in curly brackets {}.\n\nNonvirtual Subsystem blocks exist functionally and execute as a unit. They have a single execution order and a different system index than the root-level model or any parent nonvirtual subsystem. The blocks inside a nonvirtual subsystem have their own execution orders, which are independent of the root-level model or any parent nonvirtual subsystem.\n\nFor example, this model contains a virtual subsystem named car dynamics and an atomic, nonvirtual subsystem named discrete cruise controller.\n\nThe virtual car dynamics subsystem shows a list of execution orders within curly brackets for the blocks it contains. The blocks it contains execute at the same level as the Step, Sum, and Scope blocks and the discrete cruise controller nonvirtual subsystem. The Integrator block executes first and sends its output to the Scope block, which executes second.\n\nThe nonvirtual discrete cruise controller subsystem has a single execution order (4), which indicates that the subsystem and the blocks within it are the fourth to execute relative to the blocks at the same level.\n\nNoteDepending on your model configuration, the software can insert hidden, nonvirtual subsystems in your model. As a result, the visible blocks inside the hidden Subsystem block can have a system index that is different from the current system index. For example, if you select the Conditional input branch execution configuration parameter, the software may create hidden, nonvirtual subsystems for optimization, which can affect the sorted execution order."
            },
            {
                "heading": "Algebraic Loops",
                "content": "Blocks within an algebraic loop are moved into a hidden nonvirtual subsystem. The software first determines the execution order of the hidden subsystem within the context of the other blocks, then determines the execution order of the blocks within the hidden subsystem. See Algebraic Loop Concepts."
            },
            {
                "heading": "Function-Call and Action Subsystems",
                "content": "For function-call and action subsystems, the execution of the subsystem is controlled by the execution of its initiator. The subsystem and its initiator therefore share an execution order.\n\nThe software ignores any block priority set on Function-Call Subsystem, If Action Subsystem, or Switch Case Action Subsystem blocks, but you can set the block priority on the blocks that initiate these subsystems.\n\nAt the root-level of export-function models, function-call execution orders have an F prefix.\n\nFor more information, see Export-Function Models Overview."
            },
            {
                "heading": "Buses and Multiple Initiators",
                "content": "A block has multiple execution orders when the block executes multiple times based on different execution paths to that block. For example:\n\nA block connected to a bus has an execution order corresponding to each signal that the bus contains.A function-call or action subsystem with multiple initiators has an execution order corresponding to each initiator."
            },
            {
                "heading": "Determining Execution Order",
                "content": "Task-based sorting sets the execution order of blocks and ports based on their derived sample time information. Task-based sorting provides an efficient and simpler process for determining the execution order of blocks.\n\nWith task-based sorting:\n\nTasks are sorted individually based on sample time.Multiple sorted lists are generated instead of one flattened, sorted list of blocks across all tasks.Rate transition handling is simplified.False data dependency violations involving blocks in different tasks are avoided.Code generation results are in efficient rate groupings.One subsystem can belong to different sorted lists in multiple tasks."
            },
            {
                "heading": "Direct-Feedthrough Input Impact on Execution Order",
                "content": "To ensure that the execution order reflects data dependencies among blocks, the software categorizes block input ports according to the dependency of the block outputs on the block input ports. An input port whose current value determines the current value of one of the block outputs is a direct-feedthrough input. See Algebraic Loop Concepts.\n\nExamples of blocks that have direct-feedthrough inputs include:\n\nGainProductSum\n\nExamples of blocks without direct-feedthrough inputs include:\n\nIntegratorUnit DelayConstant"
            },
            {
                "heading": "Rules for Determining Block Execution Order",
                "content": "To sort blocks, the software uses these rules:\n\nIf a block drives the direct-feedthrough input of another block, the driving block must appear in the execution order ahead of the block that it drives. This rule ensures that the direct-feedthrough inputs to blocks are valid when the software invokes block output methods that require current inputs.If a block drives the input of another block that is not a direct-feedthrough input, there is no data dependency between the two blocks, so their relative execution order does not matter.\n\nThis model illustrates this result.\n\nThe Integrator block 1/s in the Car Dynamics virtual subsystem has no direct-feedthrough input. Therefore, even though its input is connected to the Gain block 1/m, the Integrator block is sorted before the Gain block 1/m. The output of the Integrator block drives the input of the Gain block b, so the Integrator block is sorted before that Gain block.In the root-level model, the Step block step response drives a Sum block, so the Step block is sorted before the Sum block. The Sum block drives the direct-feedthrough input of the discrete cruise controller nonvirtual subsystem, so the subsystem is sorted after the Sum block.\n\nThe discrete cruise controller nonvirtual subsystem is treated as a block with a direct-feedthrough input because its output depends on the current value of the input via the branch with the Gain block named Kp. Inside the subsystem, all the Gain blocks, which have direct-feedthrough inputs, run before the Sum block that they drive."
            },
            {
                "heading": "Rules for Determining Block Execution Order in Models Containing Asynchronous Tasks",
                "content": "In simulation, asynchronous function-call initiators have the highest priority when determining block sorting order within a task. For more information, see Asynchronous Sample Time and Rate Transitions and Asynchronous Blocks (Simulink Coder).\n\nTo determine the block execution order in models containing asynchronous sample times, the software uses these rules:\n\nIf an asynchronous function-call initiator is triggered by a discrete rate shared by the corresponding rate transition block, then in the task of the common discrete rate, the asynchronous function-call initiator will be sorted first.For example, in the below model, there is one asynchronous function-call initiator (an Async Interrupt (Simulink Coder) block) that is triggered by the discrete rate D1. Within the discrete task, the asynchronous function-call initiator is sorted first. The Rate Transition blocks convert between the asynchronous rate, A1, and the discrete rate, D1.If a Rate Transition block is reduced to NoOp, the Rate Transition block does not execute, and its position in the sorted order within the discrete task is transferred to the upstream or downstream discrete block to which it is connected.For example, in the above model, RTB2 is reduced to NoOp, so its position in the sorted order is transferred to the downstream Gain block.If two asynchronous function-call initiators share a common discrete rate task, then asynchronous function-call initiator with higher priority executes first within the discrete rate task.For example, in the below model, two asynchronous function-call initiators (two Async Interrupt (Simulink Coder) blocks) are triggered by the same discrete rate, D1. The one with higher task priority is sorted first.The union of asynchronous sample times is not supported by task-based sorting. All blocks associated with the union of multiple asynchronous sample times are sorted within a single task.For example, in the below model, two asynchronous function-call initiators (two Async Interrupt (Simulink Coder) blocks) with same Simulink task priority are triggered by the same discrete rate, D1. In this model, a Rate Transition block RTB1_Union computes U1 = union(A4 , A5). The blocks associated with the union is grouped in Task 0. For more information about union sample time, see Union Rate and asynchronous sample time, see Asynchronous Sample Time."
            },
            {
                "heading": "Check for Execution Order Changes Involving Data Store Memory Blocks",
                "content": ""
            },
            {
                "heading": "Model Upgrades",
                "content": "Using task-based sorting instead of legacy (block) sorting can change the relative execution order involving Data Store Memory blocks. An Upgrade Advisor check detects the changes and provides an option to keep the original execution order when upgrading your model from earlier Simulink versions.\n\nOpen the Upgrade Advisor. On the Modeling tab, select Model Advisor > Upgrade Advisor.Select the check box for Check relative execution orders for Data Store Read and Data Store Write blocks.Click Run This Check.Review any changes in the Result table. If you want to keep the original execution order, click Modify."
            },
            {
                "heading": "Code Generation",
                "content": "When a model is compiled for code generation, the relative execution order of Data Store Read and Data Store Write blocks can differ in the generated code from the order in normal simulation mode. A Model Advisor check detects these differences and provides an option to change the execution order in normal simulation mode to match the order in the generated code.\n\nOpen the Model Advisor. On the Modeling tab, select Model Advisor > By Product > Simulink Coder.Select the check box for Check for relative execution order change for Data Store Read and Data Store Write blocks.Click Run This Check.Review any changes in the Result table. If there are discrepancies listed and you want to change the execution order in normal simulation to conform with the execution order in generated code, click Modify block priorities."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/controlling-and-displaying-the-sorted-order.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/tbs_execution_order_viewer.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_separate_tasks_constant_sample_times.png",
            "https://in.mathworks.com/help/simulink/ug/execution-order-recompile-button.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_clear_highlighting_icon.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_execution_order_task_links.png",
            "https://in.mathworks.com/help/simulink/ug/vdp_sorted_order.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_root_level_model.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_car_dynamics.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_discrete_cruise_controller.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_block_to_task_based03.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_function_call_subsystem.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_export_function_model.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_block_to_task_based02.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_block_to_task_based06.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_car_dynamics.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_root_level_model.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_example_discrete_cruise_controller.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_moneasync_rtbnoop.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_mtwoasyncs.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_munionrate_model.png",
            "https://in.mathworks.com/help/simulink/ug/sorted_order_munionrate.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_model_advisor_check.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_model_adviser_check1.png",
            "https://in.mathworks.com/help/simulink/ug/tbs_model_adviser_check2.png"
        ]
    },
    {
        "title": "Compare Capabilities of Composite Interfaces",
        "introduction": "Before you implement a piece of your system using a specific type of composite interface, consider whether the type satisfies your requirements for composite interface elements, modeling, and code generation. To identify which composite interfaces to consider based on high-level guidelines and ideal use cases, see Explore Composite Interfaces.",
        "chunks": [
            {
                "heading": "Composite Interface Elements",
                "content": "RequirementVirtual BusesNonvirtual BusesArrays of BusesArraysHierarchical elementsSupportedElements of virtual buses can have hierarchy.SupportedElements of nonvirtual buses can have hierarchy.SupportedWhile an array of buses is flat, the nested buses can have hierarchy.Not supportedWhile you can concatenate signals in stages to create an array, the result is flat, as if you used a single block to concatenate the signals.Elements with different sample timesSupportedElements of virtual buses can have different sample times.For faster model compilation, use the same sample time for each element of a virtual bus. To change the sample time of an input element, use a Rate Transition block.Not supportedAll elements of a nonvirtual bus must use the same sample time.Use a Rate Transition block to change the sample time of signals in a bus. For more information, see Modify Sample Times for Nonvirtual Buses.Not supportedAll elements of an array of buses must use the same sample time.Not supportedAll elements of an array must use the same sample time.Elements with different data typesSupportedElements of virtual buses can have different data types.SupportedElements of nonvirtual buses can have different data types.SupportedTop-level elements of arrays of buses must specify the same Simulink.Bus object data type. Elements of the nested buses can have different data types.Not supportedAll elements of an array must have the same data type.Variable-size signalsSupportedVirtual buses can contain variable-size signals as long as they are not used as inputs to or outputs from a referenced model.Supported Nonvirtual buses can contain variable-size signals.Signal logging is supported for nonvirtual buses with variable-size signals when running a simulation in normal or accelerator mode. (since R2023a)SupportedArrays of buses can contain variable-size signals only for simulations in normal mode.Signal logging is supported for arrays of buses with variable-size signals only when running a simulation in normal mode. (since R2023a)SupportedArrays can contain variable-size signals.Function-call signalsSupportedA virtual bus can contain function-call signals as long as the bus is not defined by a Simulink.Bus object.Not supportedNonvirtual buses do not support function-call signals.Not supportedArrays of buses do not support function-call signals.Not supportedArrays do not support function-call signals.To group function-call signals in a virtual vector, see Mux.MessagesSupportedVirtual buses can have message elements as long as they do not also have signal elements.Not supportedNonvirtual buses cannot contain message elements.Not supportedArrays of buses cannot contain message elements.Not supportedArrays cannot contain message elements.Physical conserving connectionsNot supportedSimulink\u00c2\u00ae buses do not support physical conserving connections.To group physical conserving connections, use a Simscape Bus (Simscape) block.Not supportedSimulink buses do not support physical conserving connections.Not supportedArrays of buses do not support physical conserving connections.SupportedArrays support physical conserving connections. For more information, see Nonscalar Physical Signal Connections (Simscape)."
            },
            {
                "heading": "Composite Interface Modeling",
                "content": "RequirementVirtual BusesNonvirtual BusesArrays of BusesArraysName-based element accessSupportedYou can access the elements of virtual buses by name.SupportedYou can access the elements of nonvirtual buses by name.Not supportedYou can access the top-level elements of arrays of buses only by index.Not supportedYou can access the elements of an array only by index.Element access at component input portsSupportedTo select elements of a virtual bus at an input port, use In Bus Element blocks.SupportedTo select elements of a nonvirtual bus at an input port, use In Bus Element blocks.Not supportedIn Bus Element blocks can pass an array of buses through the interface, but they cannot select the index-based elements of arrays of buses.Not supportedIn Bus Element blocks can pass an array through the interface, but they cannot select the index-based elements of the array.Composite interface definition at component input portsSupportedTo define an input virtual bus for a model component, specify the virtual bus and its elements with one or more In Bus Element blocks.SupportedTo define an input nonvirtual bus for a model component, specify the nonvirtual bus with one or more In Bus Element blocks.For the element that you want to be a nonvirtual bus: Set Data type to a Simulink.Bus object.Set Bus virtuality to nonvirtual. SupportedTo define an input array of buses for a model component, specify the array of buses with an In Bus Element block.For the element that you want to be an array of buses: Set Data type to a Simulink.Bus object.Set Bus virtuality to nonvirtual.Set Dimensions to an integer greater than 1. SupportedTo define an input array for a model component, specify the array with a Simulink.ValueType object as the data type of the input.Composite interface creation at component output portsSupportedTo create a virtual bus at an output port, connect the desired elements of the virtual bus to Out Bus Element blocks that correspond to the same output port.SupportedTo create a nonvirtual bus at an output port, connect the desired elements of the nonvirtual bus to Out Bus Element blocks that correspond to the same output port. Then, edit the signal attributes of the bus. Set Data type to a Simulink.Bus object.Set Bus virtuality to nonvirtual. Not supportedOut Bus Element blocks can pass an array of buses through the interface, but they cannot create an array of buses.Not supportedOut Bus Element blocks can pass an array through the interface, but they cannot create an array.Incremental interface changes using port blocksSupportedYou can add, remove, and modify elements of a virtual bus at an interface with or without changing the block diagram by using In Bus Element and Out Bus Element blocks.Not supportedYou cannot make incremental interface changes to nonvirtual buses using port blocks.To modify a nonvirtual bus, modify the corresponding Simulink.Bus object.Not supportedWhile you can change the dimensions of an array of buses at an interface by using port blocks, you cannot change the elements at the interface.To modify the elements of an array of buses, modify the corresponding Simulink.Bus object or use Selector and Vector Concatenate blocks.Not supportedYou cannot make incremental interface changes to arrays using port blocks.To modify an array, use Selector and Vector Concatenate blocks.Defined interfaces in simulationSupportedTo define the properties of a virtual bus, you can use a Simulink.Bus object or specify element attributes with In Bus Element and Out Bus Element blocks.SupportedNonvirtual buses require Simulink.Bus objects, which define bus properties.SupportedTo define the properties of an array of buses, use a Simulink.ValueType object.SupportedTo define the properties of an array, use a Simulink.Signal or Simulink.ValueType object.Iterative processing of subsystemsNot supportedVirtual buses do not support iterative processing of subsystems.Not supportedNonvirtual buses do not support iterative processing of subsystems.Group nonvirtual buses in arrays of buses to iteratively process them in a subsystem such as a for-each, while-iterator, or for-iterator subsystem.SupportedArrays of buses let you iterate over a group of nonvirtual buses. Connect the array of buses to a subsystem such as a for-each, while-iterator, or for-iterator subsystem.SupportedArrays let you iterate over a group of signals. Connect the array to a subsystem such as a for-each, while-iterator, or for-iterator subsystem."
            },
            {
                "heading": "Composite Interface Code Generation",
                "content": "RequirementVirtual BusesNonvirtual BusesArrays of BusesArraysStructures in generated codeNot supportedVirtual buses do not appear as structures in the generated code. While you can specify a Simulink.Bus object data type for a virtual bus, the generated code does not apply the type.SupportedNonvirtual buses appear as structures in the generated code. The corresponding Simulink.Bus objects represent the structure types.For more information, see Organize Data into Structures in Generated Code (Simulink Coder).SupportedArrays of buses appear as arrays of structures in the generated code. The corresponding Simulink.Bus objects represent the structure types.Not supportedArrays appear as vectors in the generated code.For more information, see Code Generation of Matrices and Arrays (Simulink Coder).Individual data elements at interfaceSupportedFor a virtual bus, the generated code appears as if the bus did not exist. The code generator is able to fully optimize the signals in a virtual bus. For more information, see Generate Efficient Code for Buses (Simulink Coder).Not supportedA nonvirtual bus is represented as a whole in the generated code. A nonvirtual bus can require data copies.Not supportedAn array of buses is represented as a whole in the generated code. An array of buses can require data copies.Not supportedAn array is represented as a whole in the generated code. An array can require data copies."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/compare-capabilities-of-composite-interfaces.html",
        "images": []
    },
    {
        "title": "Create App Designer Instrument Panels by Using Simulink Real-Time Components - MATLAB &amp; Simulink\n",
        "introduction": "Simulink Real-Time Explorer | Instrument | ConnectButton | InstrumentManager | LoadButton | Menu | ParameterTable | ParameterTuner | SignalTable | SimulationTimeEditField | StartStopButton | StatusBar | StopTimeEditField | SystemLog | TETMonitor | TargetSelector | UpdateButton | slrealtime.ui Properties",
        "chunks": [
            {
                "heading": "Create Blank App",
                "content": "To create an App Designer instrument panel by using Simulink Real-Time components:\n\nOpen the App Designer. In MATLAB\u00c2\u00ae, select Home > New > App.\n\nOr, in the MATLAB Command Window, type appdesigner. Then, select New > Blank App"
            },
            {
                "heading": "Add Components to App",
                "content": "From the Simulink Real-Time group in the Component Library, add real-time application components to the instrument panel. For this instrument panel, add:\n\nTarget SelectorConnectLoadStart/StopStop TimeParameter TableSignal Table\n\nFrom the Instrumentation group in the Component Library, add Instrumentation components to the instrument panel. For this instrument panel, add Knob and Gauge.\n\nFrom the Common group in the Component Library, add common components to the instrument panel. For this instrument panel, add Axes."
            },
            {
                "heading": "Arrange Components in App",
                "content": "Arrange the instrument panel to appear as shown in this instrument panel."
            },
            {
                "heading": "Configure Options for Components",
                "content": "Select the Knob instrument and change the Limits to 0,20 in the Inspector tab of the Component Browser.\n\nSelect the Gauge instrument and change the Limits to -1.5,1.5 in the Inspector tab of the Component Browser.\n\nSave the instrument panel as myInstPanel_slrt_ex_osc.mlapp."
            },
            {
                "heading": "Add Callback Code",
                "content": "To add callback code to your App Designer instrument panel and test the instrument panel as a UI to a real-time application:\n\nChange to the Code View tab.\n\nIn the Component Browser, select node myInstPanel_slrt_ex_osc. Select Callbacks. From the StartupFcn drop-down list, select <add StartupFcn callback>.\n\nAdd callback code to connect the instruments to the real-time application. Paste this callback code into the startup function callback of the instrument panel application. This code connects the instruments to the real-time application slrt_ex_osc.\n\n% Define the real-time application file to load. app.LoadButton.Application = 'slrt_ex_osc'; % Define parameters parameters to display in the % Parameter Table component. The parameters are % defined in a structure. The block path is the % first element the parameter name. app.ParameterTable.Parameters = struct( ... 'BlockPath', {'slrt_ex_osc/Signal Generator', ... 'slrt_ex_osc/Signal Generator'}, ... 'ParameterName', {'Amplitude', ... 'Frequency'}); % Create a ParameterTuner object and bind % to the knob component. myParamFreq = slrealtime.ui.tool.ParameterTuner(app.UIFigure); myParamFreq.Component = app.Knob; myParamFreq.BlockPath = 'slrt_ex_osc/Signal Generator'; myParamFreq.ParameterName = 'Frequency'; % Define the signals to display in the Signal Table. % The structure requires the block path of all parameters, % and the port index of the port connected to the signal. app.SignalTable.Signals = struct( ... 'BlockPath', {'slrt_ex_osc/Signal Generator', ... 'slrt_ex_osc/Transfer Fcn'}, ... 'PortIndex', {1,1}); % Create an Instrument object and connect the gauge % component. instMyGauge = slrealtime.Instrument(); instMyGauge.connectScalar(app.Gauge, 'slrt_ex_osc/Transfer Fcn', 1); % Create another Instrument object and connect to the % axes component. % % An Instrument object is needed for each component, but % you can add more signals to the same axes by using connectLine. instMyAxes = slrealtime.Instrument(); instMyAxes.connectLine(app.UIAxes, 'XfrFnc'); instMyAxes.AxesTimeSpan = 10; instMyAxes.AxesTimeSpanOverrun = 'scroll'; % Create an InstrumentManager and connect the previously created % Instrument object. instMgr = slrealtime.ui.tool.InstrumentManager(app.UIFigure); instMgr.Instruments = [instMyGauge, instMyAxes];\n\nSave the instrument panel."
            },
            {
                "heading": "Tuning a Workspace Variable",
                "content": "The code shows how to connect the ParameterTuner component to a value on a block. Instead, you can use slightly different code to connect the ParameterTuner component to a variable or parameter in the workspace. In the code for the component, the BlockPath is empty, and the ParameterName is the parameter name instead of the property of the block to tune. The syntax for the callback could be:\n\n% Create Parameter Tuning object hParamTuner = slrealtime.ui.tool.ParameterTuner(app.UIFigure); hParamTuner.Component = app.Knob; hParamTuner.BlockPath = ''; hParamTuner.ParameterName = 'myParameter';"
            },
            {
                "heading": "Recommendations for Callback Code",
                "content": "It is recommended that you make the bindings between instrument panel controls and their related signals or parameters robust. Robust bindings do not break due to minor changes in a model and are more easily re-used with a new model.\n\nFor signals, a technique that helps produce robust bindings is to specify signals by using signal names instead of by using a full block path and port index. This technique applies to the SignalTable component and functions such as connectLine or connectScalar.\n\nFor parameters, a technique that helps produce robust bindings is to use workspace variables instead of block parameters. This technique applies to the ParameterTable component.\n\nFor more information, see the examples for SignalTable, ParameterTable, connectLine, and connectScalar."
            },
            {
                "heading": "Open Model, Configure for Simulink Real-Time",
                "content": "In MATLAB, open the slrt_ex_osc model. In the Command Window, type:\n\nopen_system('slrt_ex_osc');\n\nFrom the Apps tab in the Simulink\u00c2\u00ae editor, select Simulink Real-Time. This app configures the model for Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2."
            },
            {
                "heading": "Connect Target Computer, Build Real-Time Application, Run Instrument Panel",
                "content": "Connect the target computer. In the Simulink editor, select the computer from the Connect to Target Computer section.\n\nBuild the real-time application. In the Simulink editor, select Real-Time > Run on Target.\n\nAfter the model builds and the real-time application runs, in the App Designer, run the instrument panel application.\n\nFrom the instrument panel application, connect to the target computer, load the real-time application slrt_ex_osc, set the stop time at 10 seconds, and start the real-time application.\n\nThe instrument panel controls indicate signal and parameter values for the real-time application. Start the real-time application, use the knob to change the parameter value, and see the affect on the output.\n\nWhen done observing the operation of the instrument panel, close the app and close the App Designer."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/create-app-designer-instrument-panels-by-using-simulink-real-time-components.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/CreateAppDesignerInstPanelWithSlrtComponentsExample_01.png"
        ]
    },
    {
        "title": "Troubleshoot Signal Data Logging from Nonvirtual Bus, Fixed-Point, and Multidimensional Signals",
        "introduction": "Some models use signals in nonvirtual buses, signals with fixed-point data types, and multidimensional signals that have a number of dimensions greater than two. It would be helpful to view signal data from these signals in the Simulation Data Inspector. The data for these signals is not visible when they are selected in Simulink Real-Time Explorer for streaming to the Simulation Data Inspector. Bus Creator | fixdt | addSignal | connectLine | connectScalar",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "There are some guidelines to data logging signals in nonvirtual buses, signals with fixed-point data types, and multidimensional signals that have a number of dimensions greater than two:\n\nWhen these signals are marked for logging with the Simulation Data Inspector, the signal data displays in the Simulation Data Inspector.When these signals are connected to File Log blocks, the signal data displays in the Simulation Data Inspector.When these signals are selected for dynamic streaming with an instrument object\u00e2\u0080\u0094either by selecting the signals in Simulink Real-Time Explorer or adding the signals by using the Application object API, the signal data does not display in the Simulation Data Inspector or in App Designer instrument panel applications."
            },
            {
                "heading": "Try This Workaround",
                "content": "There are workarounds to get signals in nonvirtual buses, signals with fixed-point data types, and mutidimensional signals (that have a number of dimensions greater than two) to display in the Simulation Data Inspector."
            },
            {
                "heading": "Signals in Nonvirtual Buses",
                "content": "To get signals in nonvirtual buses to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks.\n\nTo instrument signals in nonvirtual buses to stream to an Instrument object, use the BusElement argument in the addSignal, connectLine, or connectScalar methods."
            },
            {
                "heading": "Signals with Fixed-Point Data Types",
                "content": "To get signals with fixed-point data types to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks."
            },
            {
                "heading": "Multidimensional Signal",
                "content": "To get signals in multidimensional signals (that have a number of dimensions greater than two) to display in the Simulation Data Inspector, mark the signals for data logging in the model or connect the signals to File Log blocks."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-signal-data-logging-from-nonvirtual-bus-fixed-point-and-multidimensional-signals.html",
        "images": []
    },
    {
        "title": "Stream Real-Time Signals by Using Simulink External Mode",
        "introduction": "You can use Simulink\u00c2\u00ae external mode to establish a communication channel between your Simulink block diagram and your real-time application. The block diagram becomes a user interface to your real-time application. Simulink scopes can display signal data from the real-time application, including from models referenced inside a top model. You can control which signals to upload through the External Signal & Triggering dialog box. See Select Signals to Upload and TCP/IP or Serial External Mode Control Panel. If using external mode simulation with the model serving as the interface to the real-time application and the model contains referenced models, use the Simulation Data Inspector to log signal data. Do not use Floating Scope or Scope Viewer blocks to display signals in the referenced models for external mode simulation.",
        "chunks": [
            {
                "heading": "Set Up for External Mode Simulation",
                "content": "This procedure uses model slrt_ex_osc. This model contains a Simulink Scope block. To set up triggering for the external mode simulation:\n\nOpen model slrt_ex_osc.Open the external mode control panel. In the Simulink Editor, on the Real-Time tab, click Prepare > Control Panel.In the external mode control panel, click Signal & Triggering.In the External Signal & Triggering dialog box, set the Source parameter to manual.Set the Mode parameter to normal. In this mode, the scope acquires data continuously.Select the Arm when connecting to target check box.In the Delay box, enter 0.In the Duration box, enter the number of samples for which external mode is to log data, for example, 1000. The External Signal & Triggering dialog box looks like this figure. Click Apply, and then Close. In the External Mode Control Panel dialog box, click OK."
            },
            {
                "heading": "Set Stop Time and Simulate",
                "content": "To set the stop time and run the simulation:\n\nIn the Simulink toolbar, increase the simulation stop time to, for example, 50.Save the model as ex_slrt_ext_osc. On the Simulation tab, from Save, click Save As.If a scope window is not displayed for the Scope block, double-click the Scope block.Connect to the target computer. On the Real-Time tab, toggle the Disconnected indicator to Connected.Build and download the real-time application to the target computer. Click Run on Target.The real-time application begins running on the target computer. The Scope window displays plotted data.To stop the simulation, on the Real-Time tab click Stop."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/strean-real-time-signals-by-using-simulink-external-mode.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ug/window-external-mode-signal.png",
            "https://in.mathworks.com/help/slrealtime/ug/window-external-mode-scope.png"
        ]
    },
    {
        "title": "Test Models in Real Time",
        "introduction": "You can test your system in environments, such as Simulink\u00c2\u00ae Real-Time\u00e2\u0084\u00a2, that resemble your application. You begin with model simulation on a development computer, then use software-in-the-loop (SIL) and processor-in-the-loop (PIL) simulations. Real-time testing executes an application on a standalone target computer that can connect to a physical system. Real-time testing can include effects of timing, signal interfaces, system response, and production hardware. Real-time testing includes: setVariable",
        "chunks": [
            {
                "heading": "Overall Workflow",
                "content": "This example workflow describes the major steps of creating and executing a real-time test:\n\nCreate test cases that verify the model against requirements. Run the model simulation tests and save the baseline data.Set up the real-time target computer.Create test harnesses for real-time testing, or reuse model simulation test harnesses. In Test Sequence or Test Assessment blocks, verify statements assess the real-time execution.In the Test Manager, create real-time test cases.For the real-time test cases, configure target settings, inputs, callbacks, and iterations. Add baseline or equivalence criteria.Execute the real-time tests.Analyze the results in the Test Manager. Report the results."
            },
            {
                "heading": "Real-Time Testing Considerations",
                "content": "assert statements in a Test Sequence block or Stateflow\u00c2\u00ae chart are not supported for code generation and are ignored, so no error occurs if the assert condition fails during a Simulink Real-Time simulation. However, verify statements are supported for Simulink Real-Time code generation and automatically log results for a test case in the Test Manager. The same logging behavior is available when using a Simulink Assert block.Baseline or equivalence comparisons can fail because of missing data or time-shifted data from the real-time target computer. When investigating real-time test failures, look for time shifts or missing data points.You cannot override the real-time execution sample time for applications built from models containing a Test Sequence block. The code generated for the Test Sequence block contains a hard-coded sample time. Overriding the target computer sample time can produce unexpected results.You cannot log states or, on some platforms, output ports.Your target computer must have a file system to use verify statements and test case logging. Your target computer must be running Simulink Real-Time.You cannot use variant configurations."
            },
            {
                "heading": "Complete Basic Model Testing",
                "content": "Real-time testing often takes longer than comparative model testing, especially if you execute a suite of real-time tests that cover several scenarios. Before executing real-time tests, complete requirements-based testing using desktop simulation. Using the desktop simulation results:\n\nDebug your model or make design changes that meet requirements.Debug your test sequence. Use the debugging features in the Test Sequence Editor. See Debug a Test Sequence.Update your requirements and add corresponding test cases."
            },
            {
                "heading": "Set up the Target Computer",
                "content": "Real-time testing requires a target computer or external hardware test bench. Simulink Test supports target computers running Simulink Real-Time. For more information, see:\n\nTarget Computer Settings (Simulink Real-Time) Troubleshooting in Simulink Real-Time (Simulink Real-Time)"
            },
            {
                "heading": "Configure the Model or Test Harness",
                "content": "Real-time applications require specific configuration parameters and signal properties."
            },
            {
                "heading": "Code Generation",
                "content": "A real-time test case requires a real-time system target file. In the model or harness configuration parameters, on the Apps tab, under Code Generation, click Simulink Coder. In the C Code tab, verify that the system target file (STF) is for a Simulink Real-Time model.\n\nIf the button in the Output section is Custom Target, click that button and verify that the Custom target is an STF for a Simulink Real-Time model. If it isn't, select Select system target file and select the STF to generate system target code.\n\nIf your model requires a different STF, you can set the parameter using a test case or test suite callback. After the real-time test executes, set the parameter to its original setting with a cleanup callback. For example, this callback opens the sltestProjectorController model and sets the STF parameter to speedgoat.tlc.\n\nopenExample('sltestProjectorController'); set_param('sltestProjectorController',... 'SystemTargetFile','speedgoat.tlc');"
            },
            {
                "heading": "Data Import/Export Format",
                "content": "Models must use a data format other than dataset. To set the data format:\n\nOpen the configuration parameters.Select the Data Import/Export pane.Select the Format."
            },
            {
                "heading": "Log Signals from Real-Time Execution",
                "content": "To configure your signals of interest for real-time testing:\n\nEnable signal logging in the Configuration Parameters, in the Data Import/Export pane.Name each signal of interest using the signal properties. Unnamed signals can be assigned a default name which does not match the name of the baseline or equivalence signal. In this example test harness, the logged signals have explicit names."
            },
            {
                "heading": "Add Test Cases for Real-Time Testing",
                "content": "Use the Test Manager to create real-time test cases.\n\nIn the Simulink toolstrip, on the Apps tab under Model Verification, Validation, and Test, select Simulink Test.Click Simulink Test Manager.In the Test Manager, select New > Test Case > Real-Time Test."
            },
            {
                "heading": "Test Type",
                "content": "You can select a baseline, equivalence, or simulation real-time test. For simulation test types, verify statements serve as pass/fail criteria in the test results. For equivalence and baseline test types, the equivalence or baseline criteria also serve as pass/fail criteria.\n\nBaseline \u00e2\u0080\u0094 Compares the signal data returned from the target computer to the baseline in the test case. To compare a real-time execution result to a model simulation result, add the model baseline result to the real-time test case and apply optional tolerances to the signals.Equivalence \u00e2\u0080\u0094 Compares signal data from a simulation and a real-time test, or two real-time tests. To run a real-time test on the target computer, then compare results to a model simulation:Select Simulation 1 on target.Clear Simulation 2 on target.The test case displays two simulation sections, Simulation 1 and Simulation 2.Comparing two real-time tests is similar, except that you select both simulations on target. In the Equivalence Criteria section, you can capture logged signals from the simulation and apply tolerances for pass/fail analysis.Simulation: Assesses the test result using only verify statements and real-time execution. If no verify statements fail, and the real-time test executes, the test case passes."
            },
            {
                "heading": "Load Application From",
                "content": "Using this option, specify how you want to load the real-time application. The real-time application is built from your model or test harness. You can load the application from:\n\nModel \u00e2\u0080\u0094 Choose Model if you are running the real-time test for the first time, or your model changed since the last real-time execution. Model typically takes the longest because it includes model build and download. Model loads the application from the model, builds the real-time application, downloads it to the target computer, and executes it on the target computer.Target Application \u00e2\u0080\u0094 Choose Target Application to send the target application from the host to a target computer, and execute the application. Target Application can be useful if you want to load an already-built application on multiple targets.Target Computer \u00e2\u0080\u0094 This option executes an application that is already loaded on the real-time target computer. You can update the parameters in the test case and execute using Target Computer.\n\nThis table summarizes which steps and callbacks execute for each option.\n\nTest Case Execution Step (first to last)Load Application FromModelTarget ApplicationTarget ComputerExecutes pre-load callbackYesYesYesLoads Simulink modelYesNoNoExecutes post-load callbackYesNoNoSets Signal Editor scenarioYesNoNoBuilds real-time application from modelYesNoNoDownloads real-time application to target computerYesYesNoSets runtime parametersYesYesYesRuns Test Sequence scenariosYesNoNoExecutes pre-start real-time callbackYesYesYesExecutes real-time application YesYesYesExecutes cleanup callbackYesYesYes"
            },
            {
                "heading": "Model",
                "content": "Select the model from which to generate the real-time application."
            },
            {
                "heading": "Test Harness",
                "content": "If you use a test harness to generate the real-time application, select the test harness."
            },
            {
                "heading": "Simulation Settings Overrides",
                "content": "For real-time tests, you can override the simulation stop time, which can be useful in debugging a real-time test failure. Consider a 60-second test that returns a verify statement failure at 15 seconds due to a bug in the model. After debugging your model, you execute the real-time test to verify the fix. You can override the stop time to terminate the execution at 20 seconds, which reduces the time it takes to verify the fix."
            },
            {
                "heading": "Callbacks",
                "content": "Real-time tests offer a Pre-start real-time application callback which executes commands just before the application executes on the target computer. Real-time test callbacks execute in a sequence along with the model load, build, download, and execute steps. Callbacks and step execution depends on how the test case loads the application.\n\nSequenceLoad application from:ModelLoad application from:Target applicationLoad application from:Target computerExecutes firstPreload callbackPreload callbackPreload callback\u00c2 Post-load callback\u00e2\u0080\u0094\u00e2\u0080\u0094\u00c2 Pre-start real-time callbackPre-start real-time callbackPre-start real-time callbackExecutes lastCleanup callbackCleanup callbackCleanup callback"
            },
            {
                "heading": "Iterations",
                "content": "You can execute iterations in real-time tests. Iterations are convenient for executing real-time tests that sweep through parameter values or Signal Editor scenarios. Results appear grouped by iteration. For more information on setting up iterations, see Test Iterations. You can create:\n\nTabled iterations from a parameter set \u00e2\u0080\u0094 Define several parameter sets in the Parameter Overrides section of the test case. Under Iterations > Table Iterations, click Auto Generate and select Parameter Set.Tabled iterations from Signal Editor scenarios \u00e2\u0080\u0094 If your model or test harness uses a Signal Editor input, below the IterationsTable Iterations table, click Auto Generate and select Signal Editor Scenario. If you use a Signal Editor scenario, load the application from the model.Tabled iterations from Test Sequence scenarios \u00e2\u0080\u0094 If your test harness uses Test Sequence block scenarios, you can create an iteration for each scenario in the Test Manager. Below the Iterations table, click Auto Generate and select Test Sequence Scenario. If you use Test Sequence scenarios, load the application from the model.Scripted iterations \u00e2\u0080\u0094 Use scripts to iterate using model variables or parameters. For example, assume you are testing an oscillator system and use a Test Sequence block to create a square wave test signal using the parameter frequency.In the test file, you can use real-time test scripted iterations to cover a frequency sweep from 5 Hz to 35 Hz. The script iterates the value of frequency in the Test Sequence block.%% Iterate over frequencies to determine best oscillator settings % Create parameter sets freq = 5.0:1.0:35.0; for i_iter = 1:length(freq) % Create iteration object testItr = sltestiteration(); % Set parameters setVariable(testItr,'Name','frequency','Source',... 'Test Sequence','Value',freq(i_iter)); % Register iteration addIteration(sltest_testCase, testItr); end"
            },
            {
                "heading": "Assess Real-Time Execution Using verify Statements",
                "content": "In addition to baseline and equivalence signal comparisons, you can assess real-time test execution using verify statements. A verify statement assesses a logical expression and returns results to the Test Manager. Use verify inside a Test Sequence or Test Assessment block or, if you have a Stateflow license, in a Stateflow chart. See Verify Model Simulation by Using When Decomposition."
            }
        ],
        "link": "https://in.mathworks.com/help/sltest/ug/test-models-in-real-time-and-assess-results.html",
        "images": [
            "https://in.mathworks.com/help/sltest/ug/sltest_projector_ctrl_realtime_harness.png",
            "https://in.mathworks.com/help/sltest/ug/rtt_oscillator_test_function.png",
            "https://in.mathworks.com/help/sltest/ug/sltestprojectorcontrollerrealtimeverifyresults.png"
        ]
    },
    {
        "title": "Animate and Understand Sending and Receiving Messages - MATLAB &amp; Simulink\n",
        "introduction": "Sine Wave | Send | Receive | Queue | Hit Crossing Probe | Sequence Viewer",
        "chunks": [
            {
                "heading": "Model Description",
                "content": "The SimpleMessagesModel contains these blocks:\n\nSine Wave \u00e2\u0080\u0094 The signal source. The Sample time parameter of the block is set to 0.1.\n\nSend \u00e2\u0080\u0094 Converts data signals and send messages. The specified value for the Sample time parameter of the Sine Wave block determines the rate at which the Send block sends messages. Therefore, the Send block sends one message every 0.1 simulation time.\n\nQueue \u00e2\u0080\u0094 Stores messages. Observe the message line between the Send block and the Queue block. The default capacity of the queue is 16, which means the Queue block can store at most 16 messages. The default message sorting behavior is LIFO, which means incoming messages are sorted based on last-in-first-out policy. By default, the Overwrite the oldest element if queue is full check box is selected. When the queue is full, an incoming message overwrites the oldest message in the queue. For more information about using the Queue block, see Use a Queue Block to Manage Messages.\n\nReceive \u00e2\u0080\u0094 Receives messages and converts them to signal data. In the block, Sample time parameter is set to 0.1. The Receive block receives a message every 0.1 simulation time.\n\nScope \u00e2\u0080\u0094 Visualizes messages received by the Receive block."
            },
            {
                "heading": "Simulate the Model and Review Results",
                "content": "In the model, data logging is enabled for the signal and message lines among Sine Wave, Send, Queue, Receive, and Scope blocks.\n\nSimulate the SimpleMessagesModel and observe from the Simulation Data Inspector that:\n\nThe Sine Wave block generates the sine wave signal (green).\n\nEvery 0.1 simulation time, Send block converts the value of the signal to a message and sends it to the Queue block. Simulation Data inspector displays messages as stem plots. Observe the Simulation Data Inspector displaying sent messages (purple).\n\nThe Queue block sends messages to the Receive block (blue).\n\nReceive block output is the reconstructed sine wave signal (orange)."
            },
            {
                "heading": "Use Sequence Viewer to Visualize Messages",
                "content": "You can use the Sequence Viewer tool or the Sequence Viewer block to visualize messages, events, and Simulink\u00c2\u00ae function calls. The Sequence Viewer displays message transition events and the data that the messages carry. In the Sequence Viewer window, you can view event data related to Stateflow\u00c2\u00ae chart execution and the exchange of messages between Stateflow charts.\n\nTo use the Sequence Viewer tool:\n\nTo activate logging events, in the Simulink Toolstrip, on the Simulation tab, in the Prepare section, click Log Events.\n\nSimulate your model. To open the Sequence Viewer tool, on the Simulation tab, in the Review Results section, click Sequence Viewer.\n\nThe Log events and Sequence Viewer buttons are visible when your model has blocks from the Simulink Messages & Events library, a Stateflow chart, Function-Call Subsystem, Simulink Function, or SimEvents\u00c2\u00ae blocks.\n\nThe Sequence Viewer window shows messages as they are created, sent, forwarded, received, and destroyed at different times during model execution. The Sequence Viewer window also displays state activity, transitions, and function calls to Stateflow graphical functions, Simulink functions, and MATLAB\u00c2\u00ae functions.\n\nYou can also add the Sequence Viewer block to your model for visualizing message transitions. For more information, see Use a Queue Block to Manage Messages."
            },
            {
                "heading": "Use Animation and Storage Inspector",
                "content": "You can use Animation to animate the model and observe the message flow between model components. You can specify the speed of the animation as Slow, Medium, or Fast. The option None disables the model animation.\n\nIn the toolstrip, on the Debug tab, locate the Event Animation section.\n\nFrom the Event Animation section, set the animation speed to Slow.\n\nSimulate the model again. Observe the highlighted message lines representing message flow between the blocks.\n\nAnimation highlights message lines and Simulink function calls based on events rather than time passed. Within one simulation time, more than one message flow or Simulink function call event can be highlighted.\n\nPause the animation. In the Simulink Toolstrip, on the Debug tab, click Pause. Observe that the last highlighted message line is highlighted in violet.\n\nThe Storage Inspector allows you to visualize the details of the stored messages in Queue block. When you pause the simulation, the Storage Inspector magnifying glass icon appears on the Queue block. To open the Storage Inspector, click the magnifying glass.\n\nThe Storage Inspector does not show any stored messages because messages arriving at the Queue block are simultaneously received by the Receive block at the same simulation time.\n\nTo create a scenario with stored messages, stop the simulation and change the Sample time parameter of the Receive block to 0.5. Now the Send block sends one message every 0.1 simulation time, but the Receive block receives messages every 0.5 simulation time. This causes a backlog of messages that are stored in the Queue block.\n\nSimulate the model again with animation speed set to Slow, and pause the simulation to check the status in the Storage Inspector. An entity in the Storage Inspector represents stored elements in the Queue block, in this case, messages. Storage Inspector lists the messages stored in the Queue block with their ID and data value carried by each message."
            },
            {
                "heading": "Display Message Payload Using Port Value Labels",
                "content": "To display message data using port value labels, right-click the message line emerging from a block and select Show Port Value Label On Selected Signal.\n\nIn the example below, the port value label displayed on the message line that connects the Send block to the Queue block.\n\nIf a message carries data as a bus, you can also select the bus elements to display in the port value label.\n\nThe SimpleMessagesPortValueModel is a variation of the SimpleMessagesModel where the input to the Send block comes from a Bus Creator block. In this example, a bus object Data_message is created with two elements, sinewave and constant.\n\nTo open this model, enter:\n\nopen_system('SimpleMessagesPortValueModel');\n\nRight-click the message line emerging from the Send block, click Show Port Value Label On Selected Signal, and select constant.\n\nOnly the values of the constant signal are displayed in the port value label.\n\nIf the message transmission stops on a message line, the port value label keeps displaying the last message payload value."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/visualize-animate-and-inspect-messages.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ModelMessageBasedCommunicationFrameworkExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_simple_model_fourplots.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessage_simulink_logevents.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessage_simulink_toolstrip_sequenceviewer.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessage_sequence_viewer_tool_window.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxanimation_toolstrip_event_animation.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxanimation_toolstrip_slow.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_simple_model_flow.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_simple_model_latestline.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_simple_model_queueinspector.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_simple_model_queueinspector2.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessage_port_value_display.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_choose_port_value.png",
            "https://in.mathworks.com/help/examples/simulink/win64/xxmessages_ex_port_value_display.png"
        ]
    },
    {
        "title": "Generate Inlined Subsystem Code",
        "introduction": "To inline subsystem code with your model code, configure a nonvirtual subsystem. In the Subsystem Block Parameters dialog box, the Function packaging parameter specifies the format of the subsystem generated code. This parameter has these settings: The code generator can generate inlined code for the Auto and Inline settings. The inline setting directs the code generator to inline the subsystem code unconditionally. The default Auto setting directs the code generator to generate the most efficient code for the subsystem based on the type and number of instances of the subsystem that exist in the model. When there is only one instance of a subsystem, the Auto setting inlines the subsystem code. In Embedded Coder\u00c2\u00ae, when there are multiple instances of a subsystem that are not too complex, the Auto setting inlines the code for each subsystem. Otherwise, the Auto setting generates a single copy of the function (as a reusable function). For a function-call subsystem that has multiple callers, the Auto setting generates subsystem code that is consistent with the Nonreusable function setting.",
        "chunks": [
            {
                "heading": "Configure Subsystem to Inline Code",
                "content": "Open a model with a subsystem, such as SubsystemAtomic.openExample('SubsystemAtomic')Open Simulink\u00c2\u00ae Coder\u00e2\u0084\u00a2 or Embedded Coder. If you are using Embedded Coder, from the C Code tab, click View Code to open the Code View editor.Right-click the Subsystem block. From the context menu, select Block Parameters (Subsystem).In the Subsystem Parameters dialog box, verify that Treat as atomic unit is selected. This option makes the subsystem nonvirtual. When the subsystem is nonvirtual, the Function packaging option is available on the Code Generation tab.Click the Code Generation tab and select Auto or Inline from the Function packaging parameter.Click Apply and close the dialog box.The border of the subsystem thickens, indicating that it is nonvirtual.Generate code from the model. The code generator inlines subsystem code within SubsystemAtomic.c. You can identify this code by system and block identification tags, such as:/* Atomic SubSystem Block: <Root>/AtomicSubsys1 */"
            },
            {
                "heading": "Exceptions to Inlining",
                "content": "There are certain cases in which the code generator does not inline a nonvirtual subsystem, even though you select the Inline setting.\n\nIf a noninlined S-function calls a function-call subsystem, the code generator ignores the Inline setting. Because noninlined S-functions use function pointers to make function calls, the code generator must generate a function with all arguments present.In a feedback loop involving function-call subsystems, the code generator generates a function instead of inlined code for one of the subsystems. Based on the internal, sorted order of the subsystems, the code generator selects which subsystem to generate a function.If an S-function, an Async Interrupt, or a Task Sync block that has the option SS_OPTION_FORCE_NONINLINED_FCNCALL set to TRUE calls a subsystem, the code generator generates a function instead of inlined code for the subsystem. The VxWorks\u00c2\u00ae block library (vxlib1) contains the user-defined Async Interrupt and Task Sync blocks.1\n\nThe Function packaging parameter is disabled in Simulink Function blocks."
            },
            {
                "heading": "See Also",
                "content": "Generate Subsystem Code as Separate Function and FilesGenerate Reentrant Code from SubsystemsRemove Algebraic Loops"
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/inline-subsystem-code-ecoder.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/rtwdemo_atomic.png"
        ]
    },
    {
        "title": "Call Reusable Hardware-Independent External Code for Simulation and Code Generation",
        "introduction": "Code reuse offers business and technological advantages. From a business perspective, code reuse saves time and resources. From a technological perspective, code reuse promotes consistency and reduces memory requirements. Other considerations include: Examples of reusable hardware-independent algorithmic code to consider importing into the Simulink\u00c2\u00ae environment for simulation and code generation include:",
        "chunks": [
            {
                "heading": "Workflow",
                "content": "To call reusable external algorithm code for simulation and code generation, iterate through the tasks listed in this table.\n\nTaskActionMore Information1Review your assessment of external code characteristics and integration requirements.Choose an External Code Integration Workflow2Choose an integration technique to add the external code to a Simulink model.Choose an Integration Technique3Verify algorithm behavior and performance by simulating the model.Simulation4Define the representation of model data for code generation.Code Interface Configuration and Exchange Data Between External C/C++ Code and Simulink Model or Generated Code5Configure the model for code generation.Model Configuration Set Customization 6Generate code and a code generation report.Code Generation7Review the generated code interface and static code metrics.Analyze Generated Data Code Interface Report, Analyze Generated Service Code Interface Report, and Static Code Metrics8Build an executable program from the model.Build Integrated Code Within the Simulink Environment9Verify that executable program behaves as expected.Verification and TestingVerification, Testing, and Certification"
            },
            {
                "heading": "Choose an Integration Technique",
                "content": "Several techniques are available for integrating reusable hardware-independent algorithmic code into the Simulink environment. Some techniques integrate external code directly. Other approaches convert the external code to Simulink or Stateflow\u00c2\u00ae modeling elements. The integration technique that you choose depends on:\n\nProgramming language of the external code \u00e2\u0080\u0094 MATLAB\u00c2\u00ae, C, C++, or FortranYour programming language experience and preferencePerformance requirementsWhether the algorithm models continuous time dynamics or you are integrating the algorithm into an application that uses discrete and continuous timeWhether you want to take advantage of Model-Based DesignLevel of control required over the code that the code generator produces\n\nTo choose an integration technique for a reusable algorithm, see the subsection that matches the programming language of your external code.\n\nIntegration Techniques for External MATLAB CodeIntegration Techniques for External C or C++ CodeIntegration Approaches for External Fortran Code"
            },
            {
                "heading": "Integration Techniques for External MATLAB Code",
                "content": "Multiple techniques are available for integrating external MATLAB code into the Simulink environment. Use this table to choose the best integration technique for your application.\n\nCondition or RequirementActionMore Information External code complies with the MATLAB code generation subsetYou want to call MATLAB code from a Simulink model Add a MATLAB Function block to the model. Embed the MATLAB code in the block. Integrate C Code by Using the MATLAB Function BlockMATLAB Function External code complies with the MATLAB code generation subsetYou want to call MATLAB code from a Simulink modelYour external code includes iterative computations that process large streams of data Add a MATLAB System block to the model. Embed the MATLAB code in the block as a System object\u00e2\u0084\u00a2. Integrate C Code by Using the MATLAB Function BlockMATLAB System External code complies with the MATLAB code generation subsetYou want to call MATLAB code from a Simulink modelYour external code includes design logic that is based on state machines and flow charts Add a Stateflow chart to the model. Call the external code from the chart, using MATLAB as the action language. Chart Programming Basics (Stateflow)Integrate External Code with Stateflow Charts You want to use the parfor function for parallel computing.Add a MATLAB Function block to the model. Embed the MATLAB code in the block. Integrate C Code by Using the MATLAB Function BlockMATLAB Function You have C or C++ programming experience and the external MATLAB code is compact and primarily uses C or C++ constructs.Manually convert the MATLAB code to C or C++ code. Choose an integration approach for C or C++ code.Integration Techniques for External C or C++ CodeSections of the external MATLAB code map to built-in blocks.Develop the algorithm in the context of a model, using the applicable built-in blocks. Interactive Model Editing and Project ManagementUse Products and Blocks Supported for Code Generation The external algorithm models continuous state dynamics.Write a MATLAB S-function and TLC file for the algorithm. Add the S-function to your model. Author Blocks Using MATLAB S-Functions Target Language Compiler\n\nTo embed external MATLAB code in a MATLAB Function or MATLAB System block or generate C or C++ code from MATLAB code with the MATLAB Coder\u00e2\u0084\u00a2, the MATLAB code must use functions and classes supported for C/C++ code generation. For more information, see Functions and Objects Supported for C/C++ Code Generation."
            },
            {
                "heading": "Integration Techniques for External C or C++ Code",
                "content": "Multiple techniques are available for integrating external C or C++ code into the Simulink environment. The following table helps you choose the best integration technique for your application.\n\nCondition or RequirementActionMore InformationYou want to integrate external C code with generated C++ code or converselyMatch the language choice for the generated code by modifying the language of the external code.Modify Programming Language of External Code to Match Generated Code You want to call a simple external C function from your model.Your function code does not require states.You do not want to customize the integration of the code.You want to easily integrate with Simulink Coverage\u00e2\u0084\u00a2, Simulink Test\u00e2\u0084\u00a2, and Simulink Design Verifier\u00e2\u0084\u00a2. Use the Simulink C Caller block.Integrate C Code Using C Caller Blocks You want to call multiple external C or C++ functions from a Simulink block or call functions conditionally. You want to include code to preprocess and postprocess data before and after calling external functions.You want to specify different code for simulation and code generation. Use the C Function blockIntegrate External C/C++ Code into Simulink Using C Function Blocks Your external C/C++ algorithm models simple dynamic systems with discrete states. You want to call external code for output, start, initialize conditions, and terminate code.Programming experience is limited. You want ease of use with basic flexibility for controlling what code the code generator produces for rapid prototyping. Use the C Function block. Integrate External C/C++ Code into Simulink Using C Function BlocksStart and Terminate Actions Within a C Function Block Your external C/C++ algorithm models simple dynamic systems with discrete states. You want to call external code for enabling, disabling and updating state code. Programming experience is limited. You want ease of use with basic flexibility for controlling what code the code generator produces for rapid prototyping. Generate S-function and TLC files by using the S-Function Builder. If necessary, refine the generated code manually to meet application requirements. (If you change the generated code, you lose the changes if you regenerate the S-function and TLC files.)Build S-Functions Automatically Using S-Function Builder Your external C/C++ algorithm models simple dynamic systems that have continuous states.You do not want to manually write a TLC file.Programming experience is limited. You want ease of use with basic flexibility for controlling what code the code generator produces for rapid prototyping. Generate S-function and TLC files by using the S-Function Builder. If necessary, refine the generated code manually to meet application requirements. (If you change the generated code, you lose the changes if you regenerate the S-function and TLC files.)Build S-Functions Automatically Using S-Function Builder Your external C/C++ algorithm models dynamic systems that have continuous states.You have C/C++ programming experience. You want to control what code the code generator produces for rapid prototyping. Manually write an S-function and TLC file. C/C++ S-Function Basics S-Functions and Code GenerationC S-Function Examples and C++ S-Function Examples The application requires more entry-point functions than the code generator typically produces\u00e2\u0080\u0094for example, more than model_step, model_initialize, and model_terminate. You want maximum flexibility for controlling what code the code generator produces. Manually write an S-function and TLC file. C/C++ S-Function Basics S-Functions and Code GenerationC S-Function Examples and C++ S-Function Examples Your C/C++ algorithm includes design logic that is based on state machines and flow charts. Or, a function that you want to integrate must exchange data with a model by using global variables. The function defines the global variables and uses them to write output rather than returning a value or writing output to an argument.Add a Stateflow chart to the model. Call the external code from the chart, using C as the action language. In the chart, write code that calls the external function and reads from and writes to the global variables. To perform calculations with output of the external code, the model must read from the global variable during execution.Integrate External Code with Stateflow ChartsYou want to include external C/C++ code in a Stateflow chart for simulation and code generation.Configure the model that contains the chart to apply the external C or C++ code. Custom Code (Stateflow)Call C Library Functions in C Charts (Stateflow)Integrate External Code with Stateflow Charts You want to embed a call to external C/ C++ code from a model quickly. Performance is not an issue.Call the C/C++ code with the coder.ceval function from within a MATLAB Function block. coder.ceval functionIntegrate C Code by Using the MATLAB Function BlockMATLAB Function block"
            },
            {
                "heading": "Modify Programming Language of External Code to Match Generated Code",
                "content": "To integrate external C code with generated C++ code or conversely, modify the language of the external code to match the programming language of the generated code. To match the programing language of the external code with the generated code, use the appropriate approach explained below:\n\nRewrite the external code to match the programming language of the generated code.If you are generating C++ code and the external code is C code, for each C function, create a header file that prototypes the function. Use this format: #ifdef __cplusplus extern \"C\" { #endif int my_c_function_wrapper(); #ifdef __cplusplus } #endifThe prototype serves as a function wrapper. If your compiler supports C++ code, the value __cplusplus is defined. The linkage specification extern \"C\" specifies C linkage without name mangling.If you are generating C code and the external code is C++ code, include an extern \"C\" linkage specification in each .cpp file. For example, the following example shows C++ code in the file my_func.cpp:extern \"C\" { int my_cpp_function() { ... } }"
            },
            {
                "heading": "Integration Approaches for External Fortran Code",
                "content": "To integrate external Fortran code:\n\nWrite an S-function and corresponding TLC file.Add the S-function to your model.If necessary, add support files and control model code generation and builds within the Simulink environment.\n\nFor more information, see Integrate Fortran Code into Simulink."
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/import-calls-to-external-reusable-algorithmic-code-into-models-for-code-generation.html",
        "images": []
    },
    {
        "title": "Signal Basics",
        "introduction": "A signal is a time-varying quantity that has values at all points in time. You can specify a wide range of signal attributes, including: In Simulink\u00c2\u00ae, signals are the outputs of dynamic systems represented by blocks in a Simulink diagram and by the diagram itself. The lines in a block diagram represent mathematical relationships among the signals defined by the block diagram. For example, a line connecting the output of block A to the input of block B indicates that the signal output of B depends on the signal output of A. Simulink block diagrams represent signals with lines that have an arrowhead. The source of the signal corresponds to the block that writes to the signal during evaluation of its block methods (equations). The destinations of the signal are blocks that read the signal during the evaluation of the block methods (equations). The destination of signals in a model do not necessarily represent the order of simulation of blocks in a model. The simulation order is determined by Simulink automatically. You can create a signal by adding a source block to your model. For example, you can create a signal that varies sinusoidally with time by adding an instance of the Sine, Cosine block from the Simulink Sources library into your model. To see a list of the blocks that create signals in a model, see Sources. Alternatively, you can use the Viewers and Generators Manager to create signals in your model without using blocks.",
        "chunks": [
            {
                "heading": "Signal Line Styles",
                "content": "A Simulink model can include many different types of signals. As you construct a block diagram, all signal types appear as a thin, solid line. After you update the diagram or start simulation, the signals appear with the specified line styles. These signal types enable you to differentiate between different signal types. From all signal types, you can only customize the nonscalar signal type. To learn more, see Signal Types.\n\nSignal TypeLine StyleScalar and nonscalarNonscalar (with the Wide nonscalar lines option enabled\u00e2\u0080\u0094see Wide Nonscalar Lines)Control signalVirtual busNonvirtual busArray of busesVariable-size"
            },
            {
                "heading": "Signal Properties",
                "content": "You may want to specify signal properties in your model to give a name or a label to your signals, prepare data for logging, or to customize your signals in a model. Use the Property Inspector, the Model Data Editor, or the Signal Properties dialog box to specify properties for:\n\nSignal names and labelsSignal loggingSimulink Coder\u00e2\u0084\u00a2 to use to generate codeDocumentation of the signal\n\nTo access the signal properties in the Property Inspector, first display the Property Inspector. On the Modeling tab, under Design, click Property Inspector. When you select a signal, the properties appear in the Property Inspector.\n\nTo open the Model Data Editor, on the Modeling tab, click Model Data Editor. Then, inspect the Signals tab and select a signal.\n\nTo use the Signal Properties dialog box, right-click a signal and select Properties.\n\nTo specify signal properties programmatically, use a function such as get_param to create a variable that holds the handle to the block output port that creates the signal line. Then, use set_param to set the programmatic parameters of the port. For example:\n\np = get_param(gcb,'PortHandles') l = get_param(p.Outport,'Line') set_param(l,'Name','s9')"
            },
            {
                "heading": "Signal Names and Labels",
                "content": "You can name a signal interactively or programmatically in a model. The syntactic requirements for a signal name depend on how you use the name. The most common cases are:\n\nDo not use a less than character (<) to start a signal name.The signal name can resolve to a Simulink.Signal object. (See Simulink.Signal.) The signal name must then be a legal MATLAB\u00c2\u00ae identifier. This identifier starts with an alphabetic character, followed by alphanumeric or underscore characters up to the length given by the function namelengthmax.The signal has a name so the signal can be identified and referenced by name in a data log. (See Save Signal Data Using Signal Logging.) Such a signal name can contain space and newline characters. These characters can improve readability but sometimes require special handling techniques, as described in Access Logged Signals with Spaces and Newlines in Logged NamesThe signal name exists only to clarify the diagram and has no computational significance. Such a signal name can contain anything and does not need special handling.The signal is an element of a bus object. Use a valid C language identifier for the signal name.Inputs to a Bus Creator block must have unique names. If there are duplicate names, the Bus Creator block appends (signal#) to all input signal names, where # is the input port index.\n\nMaking every signal name a legal MATLAB identifier handles a wide range of model configurations. Unexpected requirements can require changing signal names to follow a more restrictive syntax. You can use the function isvarname to determine whether a signal name is a legal MATLAB identifier.\n\nName a signal interactively by using one of these options:\n\nThe Property Inspector toolThe Model Data Editor toolThe Signal Properties dialog box\n\nThe signal name appears below a signal, displayed as a signal label.\n\nTo name a signal programmatically, use the get_param and set_param functions on the signal. The table below summarizes how to work with signal names and labels in the Simulink Editor.\n\nTaskActionName a signal lineDouble-click the signal and type its name.Name a branch of a named signal lineDouble-click the branch.Name every branch of a signal Right-click the signal, select Properties, and use the dialog box.Delete signal label and nameDelete characters in the label or delete the name in Signal Properties dialog box.Delete signal label only Right-click the label and select Delete Label.Open signal label text box for editingDouble-click the signal line.Click the label.Select the signal line (not the label) and use F2.On a Mac, select the signal line (not the label) and use control+return.Move signal label Drag the label to a new location on the same signal line.Copy signal labelCtrl+drag the signal label.Change the label fontSelect the signal line (not the label), and then on the Format tab, click the Font Properties button arrow, then click Fonts for Model."
            },
            {
                "heading": "Signal Display Options",
                "content": "Displaying signal attributes in the model diagram can make the model easier to read. For example, in the Simulink Editor, on the Debug tab, use the Information Overlays menu to include in the model layout information about signal attributes, such as:\n\nPort data typesDesign rangesSignal dimensionsSignal resolution\n\nFor details, see Display Signal Attributes.\n\nYou can also highlight a signal and its source or destination blocks. For details, see Highlight Signal Sources and Destinations."
            },
            {
                "heading": "Store Design Attributes of Signals and States",
                "content": "You can use block parameters and signal properties to specify signal design attributes such as data type, minimum and maximum values, physical unit, and numeric complexity. To configure states, you can use block parameters. When you use these block parameters and signal properties, you store the specifications in the model file.\n\nAlternatively, you can specify these attributes by using the properties of a Simulink.Signal or Simulink.ValueType object that you store in a workspace or data dictionary.\n\nChoose which strategy to use based on your modeling goals.\n\nModeling GoalStrategyImprove model portability, readability, and ease of maintenanceStore signal attribute specifications in the model file. You do not need to save and manage external objects. Consider setting the model configuration parameter Signal resolution to None, which disables the use of Simulink.Signal objects by the model.Separate signal attribute specifications from the model so that you can manage each signal independentlyUse Simulink.Signal objects.Separate signal attribute specifications from the model so that you can reuse an application-specific set of attributesUse Simulink.Valuetype objects.\n\nTo configure design attributes and code generation settings for signals by using a list that you can sort, group, and filter, consider using the Model Data Editor. For objects, you can also use the Model Explorer.\n\nTo determine where to permanently store a Simulink.Signal or Simulink.ValueType object, see Determine Where to Store Variables and Objects for Simulink Models."
            },
            {
                "heading": "Test Signals",
                "content": "You can perform the following kinds of tests on signals:\n\nMinimum and Maximum Values \u00e2\u0080\u0094 For many Simulink blocks, you can specify a range of valid values for the output signals. Simulink provides a diagnostic for detecting when blocks generate signals that exceed their specified ranges during simulation. For details, see Specify Signal Ranges.Connection Validation \u00e2\u0080\u0094 Many Simulink blocks have limitations on the types of signals that they accept. Before simulating a model, Simulink checks all blocks to ensure that the blocks can accommodate the types of signals output by the ports to which the blocks connect and reports errors about incompatibilities. To detect signal compatibility errors before running a simulation, update the diagram.\n\nThe Signal Editor block displays interchangeable groups of scenarios. Use the Signal Editor to display, create, edit, and switch interchangeable scenarios.\n\nScenarios can help with testing a model."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/signal-basics.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/linestyle_scalar_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_widenonscalar_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_control_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_virtualbus_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/linestyle_nonvirtualbus_ex.gif",
            "https://in.mathworks.com/help/simulink/ug/array_of_buses_line_style.png",
            "https://in.mathworks.com/help/simulink/ug/variablesizesignal_line.gif"
        ]
    },
    {
        "title": "Prepare ASAP2 Data Description File - MATLAB &amp; Simulink\n",
        "introduction": "n-D Lookup Table | coder.asap2.export",
        "chunks": [
            {
                "heading": "Open the Model",
                "content": "This example uses model slrt_ex_osc_cal. To open the model, in the MATLAB\u00c2\u00ae Command Window, type:\n\nmodel = 'slrt_ex_osc_cal'; open_system(model);\n\nCalibration of parameters reduces the ringing in signals DampedOsc, L_1D, and L_2D."
            },
            {
                "heading": "Initial Setup",
                "content": "Open the model and check for model data.\n\n1. The Model Workspace variables contain these functions:\n\nKg -- Parameter object for the Gain1 block DampedOsc, SignalGenerator, L_1D, L_2D -- Signal objects for output signals LUT_1D_obj, LUT_2D_obj -- 1-D and 2-D lookup tables data respectively SignalGenerator -- Test input data\n\n2. Set the Default parameter behavior configuration parameter to Tunable.\n\n3. In the Code Mappings Editor \u00e2\u0080\u0093 C in Data Defaults, specify the storage class as PageSwitching for Model parameters under Parameters.\n\nNote: The model default setting for parameters sets the storage class as PageSwitching."
            },
            {
                "heading": "Set Up Parameters",
                "content": "Set up parameter tuning by using Simulink\u00c2\u00ae parameter objects.\n\n1. In slrt_ex_osc_cal, on the Modeling tab, click Design > Model Explorer.\n\n2. Select Model Workspace in the Model Hierarchy pane.\n\n3. Make sure that the Kg parameter object exists and has these properties:\n\nValue -- 400 Data type -- double\n\n4. If the parameter object does not exist, add it. On the toolbar, click the Add Simulink Parameter button.\n\n5. Open slrt_ex_osc_cal/Gain1.\n\n6. Make sure that you have set the Gain value to the parameter object Kg."
            },
            {
                "heading": "Set Up Signals",
                "content": "As a best practice, set up signal viewing by using Simulink signal objects.\n\n1. In slrt_ex_osc_cal, on the Modeling tab, click Design > Model Explorer.\n\n2. Select Model Workspace in the Model Hierarchy pane.\n\n3. Make sure that the DampedOsc signal object exists and has these properties:\n\nMinimum -- -10 Maximum -- 10Data type* -- double\n\n4. Make sure that the SignalGenerator signal object exists and has these properties:\n\nMinimum -- -10 Maximum -- 10 Data type -- double\n\n5. Make sure that the L_1D signal object exists and has these properties:\n\nMinimum -- -15 Maximum -- 15 Data type -- double\n\n6. Make sure that the L_2D signal object exists and has these properties:\n\nMinimum -- -15 Maximum -- 15 Data type -- double\n\n7. If a signal does not exist, add it. On the toolbar, click the Add Simulink Signal button.\n\n8. For each signal, open its Properties dialog box.\n\n9. Make sure that you selected the Signal name must resolve to Simulink signal object and the Test point check boxes."
            },
            {
                "heading": "Set Up Lookup Tables",
                "content": "The example model contains 1-D and 2-D lookup tables.\n\n1. Open the block parameters for the 1-D Lookup Table block.\n\n2. In the Table and Breakpoints pane, verify these settings:\n\nNumber of table dimensions -- 1 Data specification -- Lookup table object Name -- LUT_1D_obj\n\n3. Open the block parameters for the 2-D Lookup Table block.\n\n4. In the Table and Breakpoints pane, check these settings:\n\nNumber of table dimensions -- 2 Data specification -- Lookup table object Name -- LUT_2D_obj\n\nTo view the contents of the lookup tables, click Edit table and breakpoints, and then click Plot > Mesh."
            },
            {
                "heading": "Generate Data Description File",
                "content": "1. On the Real-Time tab, select Run on Target > Build Application.\n\n2. On the C Code tab, select Share > Generate Calibration Files. Use the tool to generate the required version of ASAP2 file. For more information about using the tool, see Generate ASAP2 and CDF Calibration Files. You can perform the same operation by using the coder.asap2.export function.\n\ncoder.asap2.export('slrt_ex_osc_cal', ... 'MapFile','slrt_ex_osc_cal_slrealtime_rtw/slrt_ex_osc_cal', ... 'Comments',false);\n\n3. Connect to the target by using a third-party calibration tool."
            },
            {
                "heading": "Close All Open Files",
                "content": "bdclose(model);"
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/prepare-third-party-calibrator-input-data-file.html",
        "images": [
            "https://in.mathworks.com/help/examples/slrealtime/win64/SlrtPrepareASAP2DataDescriptionFileExample_01.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-slrt_ex_osc_cal-scope.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-slrt_ex_osc_cal-scope1.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-slrt_ex_osc_cal-scope2.png",
            "https://in.mathworks.com/help/examples/slrealtime/win64/xxwindow-slrt-code-mapping-editor.png"
        ]
    },
    {
        "title": "Place External C/C++ Code in Generated Code",
        "introduction": "You can customize code that the code generator produces for a model by placing external code into the specific location of the generated code. For example, you can: The functions that you can augment with external code depends on the functions that the code generator produces for blocks that are in the model. For example, if a model or atomic subsystem includes blocks that have states, you can specify code for a disable function. Likewise, if you need the code for a block to save data, free memory, or reset target hardware, specify code for a terminate function. For more information, see Block Target File Methods.",
        "chunks": [
            {
                "heading": "Choose an Integration Approach",
                "content": "Within the Simulink\u00c2\u00ae modeling environment, two approaches are available for placing external C/C++ code into the generated code:\n\nAdding custom code blocks.Setting configuration parameters on the Code Generation > Custom Code pane.\n\nCustom code blocks provide you more flexibility to control the positioning of the external code into the generated code. For example, you can control whether you want to insert the external code precisely at the bottom or end of the generated code or at the declaration, body, and exit of the generated function code. Precisely controlling the positing of the external code is necessary for:\n\nProfiling of a system functionDisabling and enabling interrupts Tracing comments that are required by build environments to correctly integrate system code.\n\nThe following table compares the two approaches. Choose the approach that aligns best with your integration requirements.\n\nRequirementBlocksModel Configuration ParametersInclude a representation of your external code in the modeling canvas.\u00e2\u009c\u0093\u00c2 Place code in functions generated for root models.\u00e2\u009c\u0093\u00e2\u009c\u0093Place code in functions generated for atomic subsystems.\u00e2\u009c\u0093\u00c2 Save code placement in a model configuration set.\u00c2 \u00e2\u009c\u0093Place code at the top and bottom of the header and source files generated for a model.\u00e2\u009c\u0093\u00c2 Place code near the top of the header and source files generated for a model.\u00c2 \u00e2\u009c\u0093Place code inside of the SystemInitialize and SystemTerminate functions that the code generator creates.\u00c2 \u00e2\u009c\u0093Place code within declaration, execution, and exit sections of the SystemInitialize and SystemTerminate functions that the code generator creates.\u00e2\u009c\u0093\u00c2 Place code within declaration, execution, and exit sections of the SystemStart, SystemEnable, SystemDisable, SystemOutputs, SystemUpdate, or SystemDerivatives functions that the code generator creates.\u00e2\u009c\u0093\u00c2 Add preprocessor macro definitions to generated code.\u00c2 \u00e2\u009c\u0093Use the custom code settings that are specified for the simulation target.\u00c2 \u00e2\u009c\u0093Configure a library model to use custom code settings of the parent model to which the library is linked.\u00c2 \u00e2\u009c\u0093\n\nFor more information about how to apply each approach, see Integrate External Code by Using Custom Code Blocks and Integrate External Code by Using Model Configuration Parameters."
            },
            {
                "heading": "Integrate External Code by Using Custom Code Blocks",
                "content": "\u2022 Custom Code Block Library\n\u2022 Add Custom Code Blocks to the Modeling Canvas\n\u2022 Place External Code in Generated start function"
            },
            {
                "heading": "Custom Code Block Library",
                "content": "The Custom Code block library contains blocks that you can use to place external C or C++ code into specific locations and functions of the generated code. The library consists of 10 blocks that add your code to the model header (model.h) and source (model.c or model.cpp) files that the code generator produces.\n\nThe Model Header and Model Source blocks can add external code at the top and bottom of header and source files that the code generator produces for a root model. These blocks have two text fields into which you can type or paste code. One field specifies code that you want to place at the top of the generated header or source file. The second field specifies code that you want to place at the bottom of the file.\n\nThe remaining blocks add external code to functions that the code generator produces for the root model or atomic subsystem that contains the block. The blocks display text fields into which you can type or paste code that customizes functions that the code generator produces. The text fields correspond to the declaration, execution, and exit sections of code for a given function.\n\nTo Customize Code ThatUse This BlockComputes continuous statesSystem DerivativesDisables state System DisableEnables stateSystem EnableResets stateSystem InitializeProduces outputSystem OutputsExecutes onceSystem StartSaves data, free memory, reset target hardwareSystem TerminateRequires updates at each major time stepSystem Update\n\nThe block and its location within a model determines where the code generator places the external code. For example, if the System Outputs block is at the root model level, the code generator places the code in the model Outputs function. If the block resides in a triggered or enabled subsystem, the code generator places the code in the subsystem Outputs function.\n\nIf the code generator does not need to generate a function that corresponds to a Custom Code block that you include in a model, the code generator does one of the following:\n\nOmits the external code that you specify in the Custom Code block.Returns an error, indicating that the model does not include a relevant block. In this case, remove the Custom Code block from the model.\n\nFor more information, see Block Target File Methods.\n\nNoteTo avoid a potential mismatch between simulation and code generation results, do not use custom code blocks to read from and write to global Simulink data (signals, states, and block parameters). Instead, use the proper modeling pattern (for example, Data Store Read, Data Store Write, State Reader, and State Writer blocks.)"
            },
            {
                "heading": "Add Custom Code Blocks to the Modeling Canvas",
                "content": "To add the Custom Code library blocks to a model:\n\nIn the Simulink Library Browser, expand the Simulink Coder node then select the Custom Code block library.Drag the blocks that you want into your model or subsystem. Drag Model Header and Model Source blocks into root models only. Drag function-based Custom Code blocks into root models or atomic subsystems.\n\nYou can use models that contain Custom Code blocks as referenced models. The code generator ignores the blocks when producing code for a simulation target. When producing code for a code generation target, the code generator includes and compiles the custom code."
            },
            {
                "heading": "Place External Code in Generated start function",
                "content": "This example shows how to use the System Start block to place external C code into the declaration and execution sections of the start function that the code generator produces for a model containing a Discrete filter.\n\nCreate the following model.Configure the model for code generation.Double-click the System Start block.In the block parameters dialog box, in the System Start Function Declaration Code field, enter this code:unsigned int *ptr = 0xFFEE;In the System Start Function Execution Code field, enter this code:/* Initialize hardware */ *ptr = 0;Click OK.Generate code and a code generation report.View the generated model.c file. Search for the string start function. You should find the following code, which includes the external code that you entered in steps 4 and 5 into the right places. { { /* user code (Start function Header) */ /* System '<Root>' */ unsigned int *ptr = 0xFFEE; /* user code (Start function Body) */ /* System '<Root>' */ /* Initialize hardware */ *ptr = 0; } }"
            },
            {
                "heading": "Integrate External Code by Using Model Configuration Parameters",
                "content": "Model configuration parameters provide a way to place external C or C++ code into specific locations and functions within code that the code generator produces.\n\nToSelectInsert external code near the top of the generated model.c or model.cpp fileAdditional code, and enter the external code to insert.If you generate subsystem code into separate files, that code does not have access to external code that you specify with the Additional code parameter. For example, if you specify an include file as a Additional code setting, the code generator inserts the #include near the top of the model.c or model.cpp file. The subsystem code that the code generator places in a separate file does not have access to declarations inside your included file. In this case, consider specifying your external code with the Include headers parameter.Insert external code near the top of the generated model.h fileInclude headers, and enter the external code to insert. Insert external code inside the model initialize function in the model.c or model.cpp fileInitialize code, and enter the external code to insert. Insert external code inside the model terminate function in the model.c or model.cpp fileTerminate code, and enter the external code to insert. Also select the Terminate function required parameter on the Interface pane.Add preprocessor macro definitions Defines, and enter a space-separated list of preprocessor macro definitions to add to the generated code. The list can include simple definitions (for example, -DEF1) and definitions with a value (for example, -DDEF2=1). Definitions can omit the -D (for example, -DFOO=1 and FOO=1 are equivalent). If a definition includes -D, the toolchain can override the flag if the toolchain uses a different flag for defines.Use the same custom code parameter settings as the settings specified for simulation of MATLAB Function blocks, Stateflow\u00c2\u00ae charts, and Truth Table blocksUse the same custom code settings as Simulation TargetThis parameter refers to the Simulation Target pane in the Configuration Parameters dialog box.Enable a library model to use custom code settings unique from the parent model to which the library is linkedUse local custom code settings (do not inherit from main model)This parameter is available only for library models that contain MATLAB Function blocks, Stateflow charts, or Truth Table blocks.\n\nTo include a header file in an external header file, add #ifndef code. Using this code avoids multiple inclusions. For example, in rtwtypes.h, the following #include guards are added:\n\n#ifndef RTW_HEADER_rtwtypes_h_ #define RTW_HEADER_rtwtypes_h_ ... #endif /* RTW_HEADER_rtwtypes_h_ */\n\nFor more information on how to add files names and locations of header, source, and shared library files to the build process, see Build Integrated Code Within the Simulink Environment.\n\nNoteThe code generator includes external code that you include in a configuration set when generating code for software-in-the-loop (SIL) and processor-in-the-loop (PIL) simulations. However, the code generator ignores external code that you include in a configuration set when producing code with the S-function, rapid simulation, or simulation system target file."
            },
            {
                "heading": "Integrate External C Code into Generated Code by Using Model Configuration Parameters",
                "content": "Open Script\n\nThis example shows how to place external code in generated code by using model configuration parameters.\n\n1. Open the model CustomCode.open_system('CustomCode') 2. Open the Simulink Coder or Embedded Coder app.3. Open the Model Configuration Parameters dialog box and navigate to the Custom Code pane.4. On the Additional source code tab, examine the settings for model configuration parameters Additional code and Initialize code. Additional code specifies a comment and sets the variable GLOBAL_INT2 to -1. Initialize code initializes the variable GLOBAL_INT2 to 1.5. Close the dialog box.6. Generate code and a code generation report.7. Examine the code in the generated source file CustomCode.c. At the top of the file, after the #include statements, you find the following declaration code. int_T GLOBAL_INT2 = -1; The following assignment appears in the model initialize entry-point function. The example specifies this assignment with the Initialize code configuration parameter. GLOBAL_INT2 = 1;"
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/place-external-c-cpp-code-in-generated-code.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/ex_custcodestart_model.png",
            "https://in.mathworks.com/help/examples/simulinkcoder/win64/IntegrateExtCodeUsingCustomCodeBlocksAndConfigParamsExample_01.png"
        ]
    },
    {
        "title": "Customize Build Process with sl_customization.m",
        "introduction": "The Simulink\u00c2\u00ae customization file sl_customization.m is a mechanism that allows you to use MATLAB\u00c2\u00ae to customize the build process interface. The Simulink software reads the sl_customization.m file, if present on the MATLAB path, when it starts and the customizations specified in the file are applied to the Simulink session. For more information on the sl_customization.m customization file, see Register Customizations with Simulink. setTargetProvidesMain",
        "chunks": [
            {
                "heading": "The sl_customization.m File",
                "content": "The sl_customization.m file can be used to register installation-specific hook functions to be invoked during the build process. The hook functions that you register through sl_customization.m complement System Target File (STF) hooks (described in Customize Build Process with STF_make_rtw_hook File) and post-code generation commands (described in Customize Post-Code-Generation Build Processing).\n\nThe following figure shows the relationship between installation-level hooks and the other available mechanisms for customizing the build process."
            },
            {
                "heading": "Register Build Process Hook Functions Using sl_customization.m",
                "content": "To register installation-level hook functions that are invoked during the build process, you create a MATLAB function called sl_customization.m and include it on the MATLAB path of the Simulink installation that you want to customize. The sl_customization function accepts one argument: a handle to a customization manager object. For example,\n\nfunction sl_customization(cm)\n\nAs a starting point for your customizations, the sl_customization function must first get the default (factory) customizations, using the following assignment statement:\n\nhObj = cm.RTWBuildCustomizer;\n\nYou then invoke methods to register your customizations. The customization manager object includes the following method for registering build process hook customizations:\n\naddUserHook(hObj, hookType, hook)Registers the MATLAB hook script or function specified by hook for the build process stage represented by hookType. The valid values for hookType are 'entry', 'before_tlc', 'after_tlc', 'before_make', 'after_make', and 'exit'.\n\nUse this method to register installation-specific hook functions in your instance of the sl_customization function.\n\nThe Simulink software reads the sl_customization.m file when it starts. If you subsequently change the file, you must restart the Simulink session or enter the following command in the Command Window to enable the changes:\n\nsl_refresh_customizations\n\nNoteDo not use the addUserHook method to: Change the model configuration. For example, do not use the method to: Switch between model variants.Call the set_param function. Changing the model configuration might produce unexpected code generation results.Run commands that compile the model. Compiling the model might produce unexpected behavior."
            },
            {
                "heading": "Variables Available for sl_customization.m Hook Functions",
                "content": "The following variables are available for sl_customization.m hook functions to use:\n\nmodelName \u00e2\u0080\u0094 The name of the Simulink model (valid for all stages)dependencyObject \u00e2\u0080\u0094 An object containing the dependencies of the generated code (valid only for the 'after_make' stage)\n\nA hook script can directly access the valid variables. A hook function can pass the valid variables as arguments to the function. For example:\n\nhObj.addUserHook('after_make', 'afterMakeFunction(modelName,dependencyObject);');"
            },
            {
                "heading": "Example of Build Process Customization with sl_customization.m",
                "content": "The sl_customization.m file shown in the example, sl_customization.m for Build Process Customizations, uses the addUserHook method to specify installation-specific build process hooks to be invoked at the 'entry' and 'after_tlc' stages of the build process. For the hook function source code, see the CustomRTWEntryHook.m and CustomRTWPostProcessHook.m examples.\n\nExample\u00c2 1.\u00c2 sl_customization.m for Build Process Customizationsfunction sl_customization(cm) % Register user customizations % Get default (factory) customizations hObj = cm.RTWBuildCustomizer; % Register build process hooks hObj.addUserHook('entry', 'CustomRTWEntryHook(modelName);'); hObj.addUserHook('after_tlc', 'CustomRTWPostProcessHook(modelName);'); end\n\nExample\u00c2 2.\u00c2 CustomRTWEntryHook.mfunction [str, status] = CustomRTWEntryHook(modelName) str =sprintf('Custom entry hook for model ''%s.''',modelName); disp(str) status =1;\n\nExample\u00c2 3.\u00c2 CustomRTWPostProcessHook.mfunction [str, status] = CustomRTWPostProcessHook(modelName) str =sprintf('Custom post process hook for model ''%s.''',modelName); disp(str) status =1;\n\nIf you include the above three files on the MATLAB path of the Simulink installation that you want to customize, the coded hook function messages appear in the displayed output for builds. For example, if you open the ERT-based model UserDefinedDataTypes, open the Code Generation pane of the Configuration Parameters dialog box, and press Ctrl+B to initiate a build, the following messages are displayed:\n\n>> UserDefinedDataTypes ### Starting build procedure for model: UserDefinedDataTypes Custom entry hook for model 'UserDefinedDataTypes.' Custom post process hook for model 'UserDefinedDataTypes.' ### Successful completion of build procedure for model: UserDefinedDataTypes >>"
            },
            {
                "heading": "Use addUserHook Method to Customize Build Process",
                "content": "Open Live Script\n\nThis example shows how you can customize the build process by using the addUserHook method to register build hooks. The example model uses a custom hardware board. By running a custom hook method at the 'after_tlc' build stage, the build process links a custom main file.\n\nRegister New Hardware Device Using Target FrameworkIf you already have hardware settings for your model, you can skip this section.Create a target.Board object that provides MATLAB with a description of your hardware device.myProcessor = target.get('Processor', ... 'Intel-x86-64 (Windows64)'); myBoard = target.create('Board', ... 'Name', 'My Board with Custom Main File Linked', ... 'Processors', myProcessor);Add the target object to an internal database.boardObj = target.add(myBoard);\"target.add\" summary: Objects added to internal database for current MATLAB session: target.Board \"My Board with Custom Main File Linked\" Objects not added because they already exist: target.Processor \"Intel-x86-64 (Windows64)\" Specify Hardware Board for Model and Build CodeSpecify the hardware board for your model and disable the GenerateSampleERTMain option.model = 'CustomBuildCounter'; open_system(model); set_param(model, 'HardwareBoard', myBoard.Name); set_param(model, 'IncludeMdlTerminateFcn', 'on'); set_param(model, 'GenerateSampleERTMain', 'off');The software automatically selects relevant configuration parameters for the toolchain and processor associated with the specified hardware board.Without customization, the build process uses the static rt_main.c file from the matlabroot/rtw/c/src/common folder.slbuild(model);### Starting build procedure for: CustomBuildCounter ### Successful completion of build procedure for: CustomBuildCounter Build Summary Top model targets: Model Build Reason Status Build Duration ===================================================================================================================== CustomBuildCounter Information cache folder or artifacts were missing. Code generated and compiled. 0h 0m 15.152s 1 of 1 models built (0 models already up to date) Build duration: 0h 0m 17.133s The RTW.BuildInfo object contains names of source files used by the build process, including rt_main.c.bi = load(fullfile([model '_ert_rtw'], 'buildInfo.mat')); srcfiles = getSourceFiles(bi.buildInfo, true, false)'srcfiles = 2x1 cell {'$(START_DIR)/CustomBuildCounter_ert_rtw/CustomBuildCounter.c'} {'$(MATLAB_ROOT)/rtw/c/src/common/rt_main.c' } Customize Build ProcessUsing a custom hook method, you can register a custom main file instead of using the default rt_main.c.Each custom hook method must check that it is compatible with the model settings. For example, in registerCustomMain.m, the function checks that the hook method applies only for a specific hardware board.edit(fullfile(pwd, 'myHooks', 'registerCustomMain.m'))Register the custom hook method via sl_refresh_customization.addpath('myHooks'); sl_refresh_customizationsBefore generating code, remove the previous code generation folders and model cache.rmdir(fullfile(pwd, [model '_ert_rtw']), 's'); rmdir(fullfile(pwd, 'slprj'), 's'); delete([model '.slxc']);Build the model.slbuild(model);### Starting build procedure for: CustomBuildCounter Custom after_tlc hook to register custom main file for model 'CustomBuildCounter.' ### Successful completion of build procedure for: CustomBuildCounter Build Summary Top model targets: Model Build Reason Status Build Duration ===================================================================================================================== CustomBuildCounter Information cache folder or artifacts were missing. Code generated and compiled. 0h 0m 13.329s 1 of 1 models built (0 models already up to date) Build duration: 0h 0m 15.724s Check that the build process uses myMainFile.c. bi = load(fullfile([model '_ert_rtw'], 'buildInfo.mat')); srcfiles = getSourceFiles(bi.buildInfo, true, false)'srcfiles = 2x1 cell {'$(START_DIR)/CustomBuildCounter_ert_rtw/CustomBuildCounter.c'} {'$(START_DIR)/myMainFile.c' } Clean Up Close the model, remove target objects from the internal database, and deregister custom hook methods.close_system(model, 0); target.remove(boardObj);\"target.remove\" summary: Objects removed from internal database: target.Board \"My Board with Custom Main File Linked\" rmpath('myHooks'); sl_refresh_customizationsClear the variables added to the workspace.clear INC K LIMIT RESET model bi srcfiles myBoard myProcessor boardObj"
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/customizing-the-target-build-process-with-sl-customization-m.html",
        "images": [
            "https://in.mathworks.com/help/ecoder/ug/build_process_installation_flowchart_17b.png"
        ]
    },
    {
        "title": "Troubleshoot Cannot Load Shared Object on Target Computer",
        "introduction": "When loading and running on the target computer a real-time application that depends on a shared object (.so), the real-time application cannot run and load the library. In the system log, A message like this error appears: update | slrealtime.getSupportInfo",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "An error loading a shared object can indicate some issue with missing or corrupt library dependencies on the target computer. The issue could be:\n\nThe download to the Speedgoat\u00c2\u00ae target computer has modified or has removed some required files on the target computer.The download to the target computer put the library in a location that is not accessible when the real-time application runs."
            },
            {
                "heading": "Try This Workaround",
                "content": "These workarounds explore the possible issues."
            },
            {
                "heading": "Check for Issues with Required Files",
                "content": "To check for this issue, connect to the target computer, and then try to build, load, and run example model slrt_ex_osc. If working with the default target computer, in the MATLAB\u00c2\u00ae Command Window, type:\n\ntg = slrealtime; connect(tg); openExample('slrealtime/SlrtAddIOBlocksToSimulinkModelExample'); open_system('slrt_ex_osc'); slbuild('slrt_ex_osc'); load('slrt_ex_osc'); start('slrt_ex_osc');\n\nIf you can successfully connect to the target computer and build, load, and run the real-time application, there is no issue with files from the Simulink Real-Time Target Support Package on the target computer.\n\nIf you cannot complete those operations successfully, update the target computer software by using the force option. If working with the default target computer, in the MATLAB Command Window, type:\n\nupdate(tg,'force',true);\n\nAfter the software update, connect to the target computer and try to build, load, and run the real-time application.."
            },
            {
                "heading": "Check Location of Shared Object on Target Computer",
                "content": "To check for this issue, use SSH or FTP to examine the location of the shared object file on the target computer. For more information, see Execute Target Computer RTOS Commands at Target Computer Command Line.\n\nAfter you build the real-time application that links to a shared object, you must install the real-time application and the shared object on the target computer. Put the shared objects in a location on the target computer where they can be found and loaded at run time. The recommended locations are /lib, /usr/lib, or /usr/local/lib. Root access is required to copy or modify files in these locations."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-cannot-load-shared-object-on-target-computer.html",
        "images": []
    },
    {
        "title": "Reuse Desktop Test Cases for Real-Time Testing",
        "introduction": "",
        "chunks": [
            {
                "heading": "Convert Desktop Test Cases to Real-Time",
                "content": "In the Test Manager, you can reuse test cases for real-time testing by converting desktop test cases to real-time test cases. For convenience, data can be stored externally so that each test case accesses common inputs and baseline data. The overall workflow is as follows:\n\nCreate a baseline, equivalence, or simulation test case with external inputs. For baseline tests, add baseline data from external files.In the Test Manager, select the test case in the Test Browser.Copy the test case. Right-click the test case and select Copy.Paste the new test case into a test suite.Rename the new test case.Right-click the new test case, and select Convert to > Real-Time Test. For equivalence tests, select which simulation (simulation 1 or simulation 2) to run in real time.Select the Target Computer and Load Application From options.Ensure that the model settings are compatible with real-time test execution. For more information, see Development Computer Requirements (Simulink Real-Time)."
            },
            {
                "heading": "Use External Data for Real-Time Tests",
                "content": "You can simplify test input data management by defining the input data in an external MAT or Excel\u00c2\u00ae file. Map the data to root inports in your model or test harness for desktop simulation. When you convert the desktop simulation test case into a real-time test, the test case uses the same inport mapping.\n\nUsing external data depends on how your test case loads the real-time application:"
            },
            {
                "heading": "Load Real-Time Application from Model",
                "content": "If you are using external data for a real-time test, loading the real-time application from the model gives you the option of using an Excel file, MAT file, or CSV file. The external data is built into the application, and you can rerun the application from the target application or target computer.\n\nIn the System Under Test section, set the application to load from Model. In the Inputs section of the test case, click Add, and select an Excel file, MAT file, or CSV file. Map the data to your model inports. For more information on input mapping, see Use External File Data in Test Cases."
            },
            {
                "heading": "Load Real-Time Application from Target Application or Target Computer",
                "content": "After running the test from the model, you can run the test from the target application or target computer without recompiling. The application uses the input mapping from when the test ran from the model.\n\nYou can map external data to a test case loaded from the target application or target computer, without first running from the model. The external data must be in a MAT file, in the same format used if the test is loaded from the model. In the System Under Test section, select to load the application from the Target Application or Target Computer. In the Inputs section, click Add and select a MAT file. The Input string is not editable."
            },
            {
                "heading": "Reuse Desktop Test Case for Real-Time Testing",
                "content": "This example uses:Simulink TestSimulink TestSimulink Real-TimeSimulink Real-TimeSimulink Real-Time Target Support PackageSimulink Real-Time Target Support PackageSimulinkSimulinkOpen Live Script\n\nThis example shows a basic desktop test case reuse workflow using external input data defined in an Excel file. You run the baseline test case on the desktop, update the baseline data, convert a copy of the test case to a real-time test, then run the test case on a target computer. The test file, baseline data, and Excel input data file are provided. This example runs only on Windows systems.\n\nOpen the Test Manager and Test FileThe test file runs a transmission shift controller algorithm through four iterations, each corresponding to a different test scenario: passing, gradual acceleration, hard braking, and coasting. Baseline data associated with each scenario for the signals vehicle speed and output torque. tf = sltest.testmanager.TestFile('sltestTestCaseRealTimeReuseExample.mldatx'); sltest.testmanager.load(tf.Name); sltest.testmanager.view;Run the Baseline Test and View ResultsClick Run in the toolbar.When the test finishes running, select output torque under Baseline Criteria Result to view the comparison. The Passing result fails due to transient signals that fall outside the relative tolerance.Update the BaselineAssume that the transient signals are not significant, and update the baseline data:Click Next Failure. The first failure region is bounded by data cursors.Click Update Baseline > Replace Signal Segment in Baseline File from the toolstrip, and confirm that you want to overwrite the data.Repeat this process for the other two failure regions.Convert Baseline Test to Real-Time TestIn the Test Browser, right-click Baseline Test and select Copy.Paste the new test case under the test suite.Rename the new test case RT Baseline Test.Right-click RT Baseline Test and select Convert to > Real-Time Test.Run the Real-Time Test CaseSet the Target Computer. 2. Set the system under test to load from Model. 3.Run the RT Baseline Test test case.Examine and Resolve Test FailuresIn this example, several of the scenarios fail due to timing impacts on the data output. For example, in the HardBrake iteration, the vehicle speed output falls outside the relative tolerance after the brake is applied. To resolve this failure, you could:Increase the relative tolerance for the real-time test.Create a separate set of baseline data for the real-time test."
            }
        ],
        "link": "https://in.mathworks.com/help/sltest/ug/reuse-desktop-test-cases-for-real-time-testing.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulinktest_slrealtime/win64/ReuseDesktopTestCaseForRTTestingExample_01.png",
            "https://in.mathworks.com/help/examples/simulinktest_slrealtime/win64/ReuseDesktopTestCaseForRTTestingExample_02.png",
            "https://in.mathworks.com/help/examples/simulinktest_slrealtime/win64/ReuseDesktopTestCaseForRTTestingExample_03.png",
            "https://in.mathworks.com/help/examples/simulinktest_slrealtime/win64/ReuseDesktopTestCaseForRTTestingExample_04.png"
        ]
    },
    {
        "title": "Generate Reusable Code from Library Subsystems Shared Across Models",
        "introduction": "",
        "chunks": [
            {
                "heading": "What Is a Reusable Library Subsystem?",
                "content": "A reusable library subsystem is a subsystem included in a library that is configured for reuse. You must define a subsystem in a library and configure it for reuse to reuse the subsystem across models.\n\nTo reuse common functionality, you can include multiple instances of a subsystem:\n\nWithin a single model, which is a top model or part of model reference hierarchyAcross multiple referenced models in a model reference hierarchyAcross multiple top models that contain Model blocksAcross multiple top models that do not include Model blocks\n\nThe code generator uses checksums to determine reusability. There are cases when the code generator cannot reuse subsystem code.\n\nFor incremental code generation, if the reusable library subsystem changes, a rebuild of itself and its parents occurs. During the build, if a matching function is not found, a new instance of the reusable function is generated into the shared utilities folder. If a different matching function is found from previous builds, that function is used, and a new reusable function is not emitted.\n\nFor subsequent builds, unused files are not replaced or deleted from your folder. During development of a model, when many obsolete shared functions exist in the shared utilities folder, you can delete the folder and regenerate the code. If all instances of a reusable library subsystem are removed from a model reference hierarchy and you regenerate the code, the obsolete shared functions remain in the shared utilities folder until you delete them.\n\nIf a model changes such that the change might cause different generated code for the subsystem, a new reusable function is generated. For example, model configuration parameters that modify code comments might cause different generated code for the subsystem even if the reusable library subsystem did not change.\n\nEmbedded Coder\u00c2\u00ae users can generate code from a library that contains subsystems are configured for reuse. For more information, see Library-Based Code Generation for Reusable Library Subsystems (Embedded Coder)."
            },
            {
                "heading": "Reusable Library Subsystem Code Placement and Naming",
                "content": "The generated code of a reusable library subsystem is independent of the generated code of the model. Code for the reusable library subsystem is generated to the shared utility folder, slprj/target/_sharedutils, instead of the model reference hierarchy folders. The generated code for the supporting types, which are generated to the .h file, are also in the shared utilities folder. Code templates applied to the generated code of the model also apply to generated code for the reusable library subsystem.\n\nFor unique naming, reusable function names have a checksum appended to the reusable library subsystem name. For example, the code and files for a subsystem, SS1, which links to a reusable library subsystem, RLS, might be:\n\nFunction name: RLS_mgdjlngdFile name: RLS_mgdjlnd.c and RLS_mgdjlnd.h\n\nTo configure a reusable library subsystem, set the Subsystem parameters as listed here:\n\nSelect Treat as an atomic unit.On the Code Generation tab:Set Function packaging to Reusable function.Set the Function name options and File name options parameters based on this table. This table summarizes how the code generator produces code and highlights the File name options in bold that enable you to generate code from reusable library subsystems. For the purpose of this table, assume that the Subsystem block is named mySubsystem, the File name value for the User specified option is myFunction, and the Subsystem methods (Embedded Coder) naming rule model configuration parameter has the default value $R$N$M$F. Function Name OptionsFile Name OptionsGenerated Folder LocationGenerated Function NameGenerated File NamesAutoAuto/slprj/target/_sharedutilsmySubsystem_checksummySubsystem_checksum.c, mySubsystem_checksum.hUse subsystem name/slprj/target/_sharedutilsmySubsystem_checksummySubsystem_checksum.c, mySubsystem_checksum.hUse function name/slprj/target/_sharedutilsmySubsystem_checksummySubsystem_checksum.c, mySubsystem_checksum.hUser specifiedmodel_target_rtwmodel_SubsystemmyFile.hUse subsystem nameAutomodel_target_rtwmodel_SubsystemGenerated code included in model.hUse subsystem name/slprj/target/_sharedutilsmySubsystem_checksummySubsystem_checksum.c, mySubsystem_checksum.hUse function name/slprj/target/_sharedutilsmySubsystem_checksummySubsystem_checksum.c, mySubsystem_checksum.hUser specifiedmodel_target_rtwmodel_SubsystemmyFile.hUser specifiedAuto (This specification is supported for one unique instance of the subsystem in the model.)/slprj/target/_sharedutilsmyFunctionmyFunction.c, myFunction.hUse subsystem namemodel_target_rtwmyFunctionmySubsystem.c, mySubsystem.hUse function name (This specification is supported for one unique instance of the subsystem in the model.)/slprj/target/_sharedutilsmyFunctionmyFunction.c, myFunction.hUser specified (This specification is supported if the user-specified function name and file name are same and only for one unique instance of the subsystem in the model.)/slprj/target/_sharedutilsmyFunctionmyFunction.c, myFunction.h\n\nFor more information about the Subsystem block parameters, see Subsystem."
            },
            {
                "heading": "Configure Models That Include Reusable Library Subsystems",
                "content": "For a model to use a reusable library subsystem, you must configure the model differently depending on whether the model is a reference model or top model. If the subsystem is in a referenced model hierarchy, set the configuration parameter, Shared code placement to Auto. Otherwise, for each model that uses the subsystem, set the model configuration parameter Shared code placement to Shared location.\n\nIf a reusable library subsystem uses a shared local data store and you configure default mapping for model data elements, leave the default storage class mapping for category Shared local data stores set to Default.\n\nIn a model reference hierarchy, if an instance of the reusable library subsystem is in the top model, then on the Model Referencing pane of the Configuration Parameters dialog box, you must select the Pass fixed-size scalar root input by value for code generation parameter. If you do not select the parameter, a separate shared function is generated for the reusable library subsystem instance in the top model, and a reusable function is generated for instances in the referenced models.\n\nIf a reusable library subsystem is connected to the root Outport, reuse does not happen with identical subsystems that are not connected to the root Outport. However, you can set Pass reusable subsystem outputs as to Individual arguments on the Optimizations pane to make sure that reuse occurs between these subsystems. This parameter requires an Embedded Coder license.\n\nFor more information on creating a library, see Custom Libraries. For an example of creating a reusable library subsystem, see Generate Reusable Code for Subsystems Shared Across Models."
            },
            {
                "heading": "Generate Reusable Code for Subsystems Shared Across Models",
                "content": "This example shows how to configure a reusable library subsystem and generate a reusable function for a subsystem shared across referenced models. The result is reusable code for the subsystem, which is generated to the shared utility folder (slprj/target/_sharedutils).\n\n\u2022 Create a reusable library subsystem.\n\u2022 Create the example model.\n\u2022 Set configuration parameters of the top model.\n\u2022 Create and propagate a configuration reference.\n\u2022 Generate and view the code."
            },
            {
                "heading": "Create a reusable library subsystem.",
                "content": "In the Simulink Editor, on the Simulation tab, select New > Library. Select Blank Library from the Simulink Start Page window. Open GeneratedCodeFunctionReuse.openExample('GeneratedCodeFunctionReuse')Copy and paste subsystem SS1 into the Library Editor. This action loads the variables for SS1 into the base workspace. Rename the subsystem block to RLS. Click the Subsystem block and press Ctrl+U to view the contents of subsystem RLS. To configure the subsystem, in the Library editor, right-click RLS. In the context menu, select Block Parameters (Subsystem). In the Subsystem Parameters dialog box, choose the following options: Select Treat as an atomic unit.On the Code Generation tab:Set Function packaging to Reusable function.Set Function name options to User specified and verify that the Function name is set to myfun. Set File name options to Auto. Click Apply and OK.Save the reusable library as ssreuselib, which creates a file, ssreuselib.slx."
            },
            {
                "heading": "Create the example model.",
                "content": "Create a model which includes one instance of RLS from ssreuselib. Name this subsystem SS1. Add another subsystem and name it SS2. Name the model ex_model1. Create another model which includes one instance of RLS from ssreuselib. Name this subsystem SS1. Add another subsystem and name it SS3. Name the model ex_model2. Create a top model with two model blocks that reference ex_model1 and ex_model2. Save the top model as ex_mdlref_ssreuse."
            },
            {
                "heading": "Set configuration parameters of the top model.",
                "content": "With model ex_mdlref_ssreuse open in the Simulink\u00c2\u00ae Editor, on the C Code tab, click Settings to open the Configuration Parameters dialog box.On the Solver pane, specify the Type as Fixed-step.On the Model Referencing pane, click the ellipsis to view the advanced parameters. Then, select Pass fixed-size scalar root inputs by value for code generation.On the Code Generation > Report pane, select Create code generation report and Open report automatically.On the Code Generation > Interface pane, set the Shared code placement to Shared location.On the Code Generation > Identifiers pane, set the Maximum identifier length to 256. This step is optional.Click Apply and OK."
            },
            {
                "heading": "Create and propagate a configuration reference.",
                "content": "In the Simulink Editor, on the Modeling tab, click Model Explorer to open the Model Explorer. In the left navigation column of the Model Explorer, expand the ex_mdlref_ssreuse node.Select the Configurations node below the ex_mdlref_ssreuse node. In the Contents pane, right-click Configuration and select Convert to Configuration Reference.In the Convert Active Configuration to Reference dialog box, click OK. This action converts the model configuration set to a configuration reference, Simulink.ConfigSetRef, and creates the configuration reference object, configSetObj, in the base workspace.In the left navigation column, right-click Reference (Active) and select Propagate to Referenced Models.In the Configuration Reference Propagation to Referenced Models dialog box, select the referenced models in the list. Click Propagate.\n\nNow, the top model and referenced models use the same configuration reference, Reference (Active), which points to a model configuration reference object, configSetObj, in the base workspace. When you save your model, you also need to export the configSetObj to a MAT-file."
            },
            {
                "heading": "Generate and view the code.",
                "content": "To generate code, in the Simulink Editor, press Ctrl+B. After the code is generated, the code generation report opens.To view the code generation report for a referenced model, in the left navigation pane, in the Referenced Models section, select ex_model1. The code generation report displays the generated files for ex_model1.In the left navigation pane, expand the Shared files. The code generator uses the reusable library subsystem name. The code for subsystem SS1 is in myfun.c and myfun.h. Click Back and navigate to the ex_model2 code generation report. ex_model2 uses the same source code, myfun.c and myfun.h, as the code for ex_model1. Your subsystem function and file names will be different."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/generate-reusable-code-from-library-subsystems-shared-across-models.html",
        "images": [
            "https://in.mathworks.com/help/rtw/ug/ssreuselib.png",
            "https://in.mathworks.com/help/rtw/ug/rls_subsystem.png",
            "https://in.mathworks.com/help/rtw/ug/ex_model1.png",
            "https://in.mathworks.com/help/rtw/ug/ex_model2.png",
            "https://in.mathworks.com/help/rtw/ug/ex_mdlref_ssreuse.png",
            "https://in.mathworks.com/help/rtw/ug/rls_codegenreport.png"
        ]
    },
    {
        "title": "Implement Task Parallelism in Simulink - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Configure Model for Concurrent Execution",
                "content": "Open the ex_task_parallelism_initial model. Convert areas in this model to referenced models. Use the same referenced model to replace each of the functional components that process the input."
            },
            {
                "heading": "Set Model Configuration Parameters",
                "content": "Click Configure Tasks. In the Concurrent Execution dialog box, in the right pane, select the Enable explicit model partitioning for concurrent behavior check box. With explicit partitioning, you can partition your model manually.On the Modeling tab, click Model Settings.Select Code Generation > Interface > Advanced parameters. Clear the MAT-file logging check box.Select Solver, set Type to Fixed-step, and click Apply.On the Solver pane, expand Solver details. Check that Periodic sample time constraint is set to Unconstrained. Under Tasking and sample time options, select Allow tasks to execute concurrently on target.Click Configure Tasks."
            },
            {
                "heading": "Partition Model Using Explicit Partitioning",
                "content": "Partition the top model.\n\nIn the Concurrent Execution tree, under Tasks and Mapping, select CPU. Click Add task three times to add three new tasks."
            },
            {
                "heading": "Map Blocks to Tasks",
                "content": "In the Concurrent Execution tree, select Tasks and Mapping. On the Map block to tasks pane:\n\nUnder Block: Input, click select task and select Periodic: Task. Under Block: Function 1, select Periodic: Task1. Under Block: Function 2, select Periodic: Task2. Under Block: Output, select Periodic: Task.\n\nThe Input and Output model blocks are on one task. Each functional component is assigned a separate task.\n\nIn the Concurrent Execution tree, select Data Transfer. In the Data Transfer Options pane, set the parameter Periodic signals to Ensure deterministic transfer (minimum delay). Click Apply and close the Concurrent Execution dialog box."
            },
            {
                "heading": "Finalize Model",
                "content": ""
            },
            {
                "heading": "Share Configuration Parameters with Referenced Models",
                "content": "Apply configuration parameters to all referenced models."
            },
            {
                "heading": "Initialize Data Dictionary to Store Configuration Set",
                "content": "Create a Simulink.data.dictionary.Entry object that represents the configuration set, which is an entry in the dictionary. For this example, suppose the name of the dictionary is myData.sldd and the name of the Simulink.ConfigSet object is myConfigs.Store a copy of the target Simulink.ConfigSet object in a temporary variable.Save changes made to the dictionary.Create a freestanding configuration set in the base workspace by copying the active configuration set of the model.Create a separate configuration reference for the top model and each reference model. To point the reference to your freestanding configuration, set the SourceName property to freeConfigSet, the variable that represents your configuration.Attach the configuration reference to each model by using the ConfigSetRef object. To use the configuration reference in the model, activate it for each model.\n\nFor more information, see Share a Configuration with Multiple Models, Automate Model Configuration by Using a Script, and Make Changes to Configuration Set Stored in Dictionary.\n\nUpdate your model to see the tasks mapped to individual model blocks."
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/implement-task-parallelism-in-simulink.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementTaskParallelismInSimulinkExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ImplementTaskParallelismInSimulinkExample_02.png"
        ]
    },
    {
        "title": "Deploy Applications to Target Hardware",
        "introduction": "By default, the Embedded Coder\u00c2\u00ae software generates application code that does not require an external real-time executive or operating system. Generated application code requires minimal modification to be adapted to the target hardware. The architecture of the application code supports execution of models with single or multiple sample rates.",
        "chunks": [
            {
                "heading": "Generate Code for an Application",
                "content": "To generate code for an application:\n\nSelect the model configuration parameter Generate an example main program. This enables the Target operating system menu.From the Target operating system menu, select BareBoardExample. Generate code.\n\nDifferent code is generated for multirate models depending on these factors:\n\nWhether the model executes in single-tasking or multitasking mode.Whether or not reusable code is being generated.\n\nThese factors can impact the scheduling algorithms used in generated code, and in some cases impact the API for the model entry-point functions. The following sections discuss these variants."
            },
            {
                "heading": "Generated Application Code",
                "content": "The core of generated application code is the main loop. On each iteration, the main loop executes a background or null task and checks for a termination condition.\n\nThe main loop is periodically interrupted by a timer. The function rt_OneStep is installed as a timer interrupt service routine (ISR) or is called from a timer ISR at each clock step.\n\nThe execution driver, rt_OneStep, sequences calls to model_step functions. The operation of rt_OneStep differs depending on whether the model is single-rate or multirate. For a single-rate model, rt_OneStep simply calls the model_step function. For a multirate model, rt_OneStep prioritizes and schedules execution of blocks according to the rates at which they run."
            },
            {
                "heading": "Main Program",
                "content": "\u2022 Overview of Operation\n\u2022 Guidelines for Modifying Main Program"
            },
            {
                "heading": "Overview of Operation",
                "content": "This pseudocode shows the execution of a generated example main program.\n\nmain() { Initialization (including installation of rt_OneStep as an interrupt service routine for a real-time clock) Initialize and start timer hardware Enable interrupts While(not Error) and (time < final time) Background task EndWhile Disable interrupts (Disable rt_OneStep from executing) Complete any background tasks Shutdown }\n\nThe pseudocode is a design for a harness program to drive code generated for your model. The main program implements this design partially. You must modify it according to target environment software specifications."
            },
            {
                "heading": "Guidelines for Modifying Main Program",
                "content": "Make these changes in the production version of the main program module that implements your harness program:\n\nCall model_initialize.Initialize target-specific data structures and hardware, such as ADCs or DACs.Install rt_OneStep as a timer ISR.Initialize timer hardware.Enable timer interrupts and start the timer.rtModel is not in a valid state until the main program calls model_initialize. The main program should not start servicing timer interrupts until after calling model_initialize.Optionally, insert background task calls in the main loop.On termination of the main loop (if applicable):Disable timer interrupts.Perform target-specific cleanup such as zeroing DACs.Detect and handle errors. Note that even if your program is designed to run indefinitely, you may need to handle severe error conditions, such as timer interrupt overruns.You can use the macros rtmGetErrorStatus and rtmSetErrorStatus to detect and signal errors."
            },
            {
                "heading": "rt_OneStep and Scheduling Considerations",
                "content": "\u2022 Overview of Operation\n\u2022 Single-Rate Single-Tasking Operation\n\u2022 Multirate Multitasking Operation\n\u2022 Multirate Single-Tasking Operation\n\u2022 Guidelines for Modifying rt_OneStep"
            },
            {
                "heading": "Overview of Operation",
                "content": "The operation of rt_OneStep depends upon\n\nWhether the model is single-rate or multirate. In a single-rate model, the sample times of blocks in the model and the model fixed step size are the same. A model for which the sample times and step size do not meet these conditions is a multirate model.The model solver mode (SingleTasking versus MultiTasking)\n\nPermitted Solver Modes for Embedded Real-Time System Target Files summarizes the valid solver modes for single-rate and multirate models. For a single-rate model, only SingleTasking solver mode is allowed.\n\nPermitted Solver Modes for Embedded Real-Time System Target FilesModeSingle-RateMultirateSingleTaskingAllowedAllowedMultiTaskingDisallowedAllowedAutoAllowed(defaults to SingleTasking)Allowed(defaults to MultiTasking)\n\nThe generated code for rt_OneStep (and associated timing data structures and support functions) is tailored to the number of rates in the model and to the solver mode."
            },
            {
                "heading": "Single-Rate Single-Tasking Operation",
                "content": "The only valid solver mode for a single-rate model is SingleTasking. Such models run in \u00e2\u0080\u009csingle-rate\u00e2\u0080\u009d operation.\n\nThis pseudocode shows the design of rt_OneStep in a single-rate program.\n\nrt_OneStep() { Check for interrupt overflow or other error Enable \"rt_OneStep\" (timer) interrupt Model_Step() -- Time step combines output,logging,update }\n\nFor the single-rate case, the generated model_step function is\n\nvoid model_step(void)\n\nSingle-rate rt_OneStep executes model_step within a single clock period. To enforce this timing constraint, rt_OneStep maintains and checks a timer overrun flag. On entry, the main program disables timer interrupts until after checking the overrun flag and for other error conditions. If the overrun flag is clear, rt_OneStep sets the flag, and proceeds with timer interrupts enabled.\n\nThe main program clears the overrun flag if model_step returns without being reinterrupted by the timer. If rt_OneStep is reinterrupted by the timer before completing model_step, the main program detects the reinterruption through the overrun flag and an error condition results. If the main program detects this condition, rt_OneStep signals an error and returns immediately. You can change this behavior if you want to handle the condition differently.\n\nThe design of rt_OneStep assumes that the main program disables interrupts before calling rt_OneStep. The main program should not interrupt rt_OneStep until after checking the setting of the interrupt overflow flag."
            },
            {
                "heading": "Multirate Multitasking Operation",
                "content": "In a multirate multitasking system, the generated example main program uses a prioritized, preemptive multitasking scheme to execute the different sample rates in a model.\n\nThis pseudocode shows the design of rt_OneStep in a multirate multitasking program.\n\nrt_OneStep() { Check for base-rate interrupt overrun Enable \"rt_OneStep\" interrupt Determine which rates need to run this time step Model_Step0() -- run base-rate time step code For N=1:NumTasks-1 -- iterate over sub-rate tasks If (sub-rate task N is scheduled) Check for sub-rate interrupt overrun Model_StepN() -- run sub-rate time step code EndIf EndFor }\n\nTask Identifiers.\u00c2 \u00c2 The generated main program groups the execution of blocks that use different sample rates into different tasks. The code generator assigns each block that executes at a given sample rate a task identifier (tid), which associates the code for that block with a task that executes at that rate. Where there are NumTasks tasks in the system, the range of task identifiers is 0..NumTasks-1.\n\nPrioritization of Base-Rate and Subrate Tasks.\u00c2 \u00c2 The scheduler prioritizes tasks in descending order by rate. The base-rate task runs at the fastest rate in the system (the hardware clock rate). The base-rate task has highest priority (tid 0). The next fastest task (tid 1) has the next highest priority, and so on down to the slowest, lowest priority task (tid NumTasks-1).\n\nThe slower tasks, running at multiples of the base rate, are subrate tasks.\n\nRate Grouping and Rate-Specific model_step Functions.\u00c2 \u00c2 For a single-rate model, the main program performs block output computations by calling a single entry-point function, model_step. For multirate, multitasking models, the main program applies rate grouping. The generated code includes a separate model_step entry-point function for the base rate task and each subrate task in the model. The function naming convention for these functions is as follows, where N is a task identifier:\n\nmodel_stepN\n\nFor example, for a model named my_model that has three rates, the code generator produces these entry-point functions:\n\nvoid my_model_step0 (void); void my_model_step1 (void); void my_model_step2 (void);\n\nEach model_stepN function executes the code generated for blocks that share tid N. The code generator groups block code that executes within task N into the associated model_stepN function.\n\nScheduling model_stepN Execution.\u00c2 \u00c2 On each clock tick, rt_OneStep maintains scheduling counters and event flags for each subrate task. The code generator implements:\n\nCounters as taskCounter arrays indexed on tidEvent flags as arrays indexed on tid.\n\nThe scheduler uses rt_OneStep to maintain scheduling counters and task flags for subrates. The scheduling counters are clock rate dividers that count up the sample period associated with each subrate task. A pair of tasks that exchanges data maintains an interaction flag at the faster rate. Task interaction flags indicate that fast and slow tasks are scheduled to run.\n\nThe event flags indicate whether a given task is scheduled for execution. rt_OneStep maintains the event flags based on a task counter that is maintained by code in the main program for the model. When a counter indicates that the sample period for a task has elapsed, the main code sets the event flag for that task.\n\nOn each invocation, rt_OneStep updates its scheduling data structures and steps the base-rate task (rt_OneStep calls model_step0 because the base-rate task must execute on every clock step). Then, rt_OneStep iterates over the scheduling flags in tid order, unconditionally calling model_stepN for each task for which the flag is set. The scheduler executes the tasks in priority order.\n\nPreemption.\u00c2 \u00c2 The design of rt_OneStep assumes that the main program disables interrupts before calling rt_OneStep. The main program should not interrupt rt_OneStep until after checking the base-rate interrupt overflow flag (see pseudocode above).\n\nThe event flag array and loop variables that rt_OneStep uses are stored as local stack variables, making rt_OneStep reentrant. If rt_OneStep is reinterrupted, higher priority tasks preempt lower priority tasks. Upon return from interrupt, lower priority tasks resume in the previously scheduled order.\n\nOverrun Detection.\u00c2 \u00c2 Multirate rt_OneStepmaintains an array of timer overrun flags. rt_OneStep detects timer overrun, per task, by the same logic as single-rate rt_OneStep.\n\nIf have developed multirate S-functions, or if you use a customized static main function module, see Rate Grouping Compliance and Compatibility Issues for information about how to adapt your code for rate grouping compatibility. This adaptation produces more efficient code for multirate, multitasking models."
            },
            {
                "heading": "Multirate Single-Tasking Operation",
                "content": "In a multirate single-tasking program, sample times in the model must be an integer multiple of the fixed-step size configured for the model.\n\nIn a multirate single-tasking program, blocks execute at different rates, but under the same task identifier. The operation of rt_OneStep, is a simplified version of multirate multitasking operation. Rate grouping is not used. The only task is the base-rate task. The code generator produces one model_step entry-point function:\n\nvoid model_step(void)\n\nOn each clock tick, rt_OneStep checks the overrun flag and calls model_step. The scheduling function for a multirate single-tasking program is rate_scheduler (rather than rate_monotonic_scheduler). The scheduler maintains scheduling counters on each clock tick. There is one counter for each sample rate in the model. The counters are implemented in an array (indexed on tid) within the Timing structure of rtModel.\n\nThe counters are clock rate dividers that count the sample period associated with each subrate task. When a counter indicates that a sample period for a given rate has elapsed, rate_scheduler clears the counter. This condition indicates that blocks running at that rate should execute on the next call to model_step, which is responsible for checking the counters."
            },
            {
                "heading": "Guidelines for Modifying rt_OneStep",
                "content": "rt_OneStep does not require extensive modification. The only required change is to reenable interrupts after the overrun flags and error conditions are checked. If applicable:\n\nSave and restore your FPU context on entry and exit to rt_OneStep.Set model inputs associated with the base rate before calling model_step0.Get model outputs associated with the base rate after calling model_step0. If you modify rt_OneStep to read a value from a continuous output port after each base-rate model step, see the relevant cautionary guideline below.In a multirate, multitasking model, set model inputs associated with subrates before calling model_stepN in the subrate loop.In a multirate, multitasking model, get model outputs associated with subrates after calling model_stepN in the subrate loop.\n\nComments in rt_OneStep indicate the place to add your code.\n\nIn multirate rt_OneStep, you can optimize the generated code by unrolling for and while loops.\n\nIn addition, you can modify the overrun behavior to continue execution after error recovery is complete.\n\nObserve these guidelines:\n\nYou should not modify the way in which the counters, event flags, or other timing data structures are set in rt_OneStep, or in functions called from rt_OneStep. The rt_OneStep timing data structures (including rtModel) and logic are critical to the operation of the generated program.If you customize the main program module to read model outputs after each base-rate model step and select model configuration parameters Support: continuous time and Single output/update function can cause output values read from main for a continuous output port to differ from the corresponding output values in data logged for the model. While logged data is a snapshot of output at major time steps, output read from main after the base-rate model step function executes reflects intervening minor time steps. To eliminate the discrepancy, separate the generated output and update functions (clear model configuration parameter Single output/update function) or place a Zero-Order Hold block before the continuous output port.You might observe a mismatch between results from simulation and logged MAT file results from generated code if you do not set model inputs before each time you call the model step function. In the generated example main program, the following comments show the locations for setting the inputs and stepping the model with your code: /* Set model inputs here */ /* Step the model */If your model applies signal reuse and you are using MatFileLogging for comparing results from simulation against generated code, modify rt_OneStep to write model inputs in every time step as directed by these comments. Alternatively, you use a SIL or PIL approach for verification (see Choose a SIL or PIL Approach)."
            },
            {
                "heading": "Static Main Function Module",
                "content": "\u2022 Overview\n\u2022 Rate Grouping and Static Main Function\n\u2022 Modify the Static Main Function\n\u2022 Modify Static Main to Allocate and Access Model Instance Data"
            },
            {
                "heading": "Overview",
                "content": "A strategy for deploying generated application code is to use model configuration parameter Generate an example main program option to generate an example main program module (ert_main.c or .cpp). For more information, see Generate Code for an Application.\n\nAlternatively, you can clear the Generate an example main program parameter and use a generated static main function module as an example or template for developing your embedded application. Static main function modules provided by MathWorks\u00c2\u00ae include:\n\nmatlabroot/rtw/c/src/common/rt_main.c \u00e2\u0080\u0094 Supports the Nonreusable function setting for model configuration parameter Code interface packaging.matlabroot/rtw/c/src/common/rt_malloc_main.c \u00e2\u0080\u0094 Supports the Reusable function setting for parameter Code interface packaging. Select model configuration parameter Use dynamic memory allocation for model initialization and set parameter Pass root-level I/O as to Part of model data structure.matlabroot/rtw/c/src/common/rt_cppclass_main.cpp \u00e2\u0080\u0094 Supports the C++ class setting for parameter Code interface packaging.\n\nStatic main functions are not part of the generated code. The programs are provided as a basis for developing custom modifications and for use in simulation.\n\nA static main function contains:\n\nrt_OneStep\u00e2\u0080\u0094A timer interrupt service routine (ISR) that calls the entry-point function model_step to execute processing for one clock period of the model.Skeletal main function\u00e2\u0080\u0094As provided, main is useful for simulation only. You must modify main for real-time interrupt-driven execution.\n\nFor single-rate models, operation of rt_OneStep and the main function in the static main function are the same as they are in the automatically generated version described in Deploy Applications to Target Hardware. For multirate, multitasking models, the static main function and generated code differ as described in the next section.\n\nTo develop an application by using a static main function:\n\nCopy the program module to your working folder.Rename the file. For example, rename rt_main.c to model_rt_main.c. Customize the program module content.If you are using a template makefile build approach, modify the template makefile settings such that the build process creates a corresponding object file in the build folder. For example, depending on the target platform, model_rt_main.obj or model_rt_main.o.If you are using a makefile-based toolchain approach: Use the setTargetProvidesMain function to disable the inclusion of the shipped static main function in the build process.Use the addSourceFiles function to add the source file for your main program.\n\nIf your existing application depends upon a static ert_main.c developed in releases before R2012b, rt_main.c, rt_malloc_main.c, or rt_cppclass_main.cpp, you might need to continue using that static main function."
            },
            {
                "heading": "Rate Grouping and Static Main Function",
                "content": "ERT-based system target files can use a static main function module and disallow use of the model configuration parameter Generate an example main program. A custom system target file does not disallow use of that model configuration parameter when target-specific changes have been made to the static main function and those modifications must be preserved. A generated example main program does not preserve the changes to the static main function.\n\nFor models configured for multitasking (Treat each discrete rate as a separate task is selected) or concurrency (Allow task to execute concurrently on target is selected), the code generator uses a rate grouping scheme, producing a step entry-point function for each rate (model_stepN, where N identifies the rate). The Code Interface Report lists the individual entry-point functions that a main program can call.\n\nTo specify that only the rate-based step functions are generated without the wrapper function, use the TLC variable RateBasedStepFcn. If your target calls the rate grouping compatible function directly, set RateBasedStepFcn to 1. In this case, the wrapper function is not generated.\n\nIn your system target file, prior to the %include \"codegenentry.tlc\" statement, set the TLC variable RateBasedStepFcn to 1. Alternatively, set RateBasedStepFcn to 1 in your target_settings.tlc file."
            },
            {
                "heading": "Modify the Static Main Function",
                "content": "Make few modifications to the main loop and the rt_OneStep function. See Guidelines for Modifying Main Program and Guidelines for Modifying rt_OneStep.\n\nReplace the rt_OneStep call in the main loop with a background task call or null statement.\n\nOther modifications you might need to make are:\n\nIf applicable, follow comments in the code regarding where to add code for reading and writing model I/O and saving and restoring FPU context.If you modify rt_main.c, rt_malloc_main.c, or rt_cppclass_main.cpp to read a value from a continuous output port after each base-rate model step, see the relevant guideline in Guidelines for Modifying rt_OneStep.When you clear the model configuration parameter Generate an example main program, the code generator produces rtmodel.h to provide an interface between the main program module and generated model code. If you create your own static main function module, include rtmodel.h. Alternatively, you can suppress generation of rtmodel.h and include model.h directly in your main program module. To suppress generation of rtmodel.h, add this statement to your system target file:%assign AutoBuildProcedure = 0If you cleared model configuration parameter Terminate function required, remove or comment out these items in your production version of rt_main.c, rt_malloc_main.c, or rt_cppclass_main.cpp:The #if TERMFCN... compile-time error checkThe call to MODEL_TERMINATEFor only rt_main.c: If you do not want to combine output and update functions, clear model configuration parameter Single output/update function and make these changes in your production version of rt_main.c:Replace calls to MODEL_STEP with calls to MODEL_OUTPUT and MODEL_UPDATE.Remove the #if ONESTEPFCN... error check.The static program module rt_main.c does not support Reusable function code interface packaging. If you try to use it, a compile-time error occurs.#if MULTI_INSTANCE_CODE==1"
            },
            {
                "heading": "Modify Static Main to Allocate and Access Model Instance Data",
                "content": "If you are using a static main function module and your model is configured for Reusable function code interface packaging, but the model configuration parameter Use dynamic memory allocation for model initialization is cleared, allocate model instance data statically or dynamically by the calling main code. Pointers to the individual model data structures, such as Block IO, DWork, and Parameters, must be set up in the top-level real-time model data structure.\n\nTo support main modifications, the build process generates a subset of these real-time model (RTM) macros, based on the data requirements of your model, into model.h.\n\nRTM Macro SyntaxDescriptionrtmGetBlockIO(rtm)Get the block I/O data structurertmSetBlockIO(rtm,val)Set the block I/O data structurertmGetContStates(rtm)Get the continuous states data structurertmSetContStates(rtm,val)Set the continuous states data structurertmGetDefaultParam(rtm)Get the default parameters data structurertmSetDefaultParam(rtm,val)Set the default parameters data structurertmGetPrevZCSigState(rtm)Get the previous zero-crossing signal state data structurertmSetPrevZCSigState(rtm,val)Set the previous zero-crossing signal state data structurertmGetRootDWork(rtm)Get the DWork data structurertmSetRootDWork(rtm,val)Set the DWork data structurertmGetU(rtm)Get the root inputs data structure (when root inputs are passed as part of the model data structure)rtmSetU(rtm,val)Set the root inputs data structure (when root inputs are passed as part of the model data structure)rtmGetY(rtm)Get the root outputs data structure (when root outputs are passed as part of the model data structure)rtmSetY(rtm,val)Set the root outputs data structure (when root outputs are passed as part of the model data structure)\n\nTo access individual model data structures within the RTM data structure, use these macros in your static main function. For example, consider the example model Reusable.\n\nopenExample('ecoder/ReusableCodeInterfaceExample', 'supportingFile', 'Reusable');\n\nSuppose the model is configured with Reusable function code interface packaging, Use dynamic memory allocation for model initialization cleared, Pass root-level I/O as set to Individual arguments, and Optimization pane option Remove root level I/O zero initialization is cleared. Building the model generates these model data structures and model entry-points into Reusable.h:\n\n/* Block states (auto storage) for system '<Root>' */ typedef struct { real_T Delay_DSTATE; /* '<Root>/Delay' */ } D_Work; /* Parameters (auto storage) */ struct Parameters_ { real_T k1; /* Variable: k1 * Referenced by: '<Root>/Gain' */ }; /* Model entry point functions */ extern void Reusable_initialize(RT_MODEL *const rtM, real_T *rtU_In1, real_T *rtU_In2, real_T *rtY_Out1); extern void Reusable_step(RT_MODEL *const rtM, real_T rtU_In1, real_T rtU_In2, real_T *rtY_Out1);\n\nIf you do not select the model configuration parameter Generate an example main program for the model, Reusable.h contains definitions for the RTM macros rtmGetDefaultParam, rtmsetDefaultParam, rtmGetRootDWork, and rtmSetRootDWork.\n\nFor reference, the generated rtmodel.h file contains an example parameter definition that has initial values (nonexecuting code):\n\n#if 0 /* Example parameter data definition with initial values */ static Parameters rtP = { 2.0 /* Variable: k1 * Referenced by: '<Root>/Gain' */ }; /* Modifiable parameters */ #endif\n\nIn the definitions section of your static main file, you can use this code to statically allocate the real-time model data structures and arguments for the Reusable model:\n\nstatic RT_MODEL rtM_; static RT_MODEL *const rtM = &rtM_; /* Real-time model */ static Parameters rtP = { 2.0 /* Variable: k1 * Referenced by: '<Root>/Gain' */ }; /* Modifiable parameters */ static D_Work rtDWork; /* Observable states */ /* '<Root>/In1' */ static real_T rtU_In1; /* '<Root>/In2' */ static real_T rtU_In2; /* '<Root>/Out1' */ static real_T rtY_Out1;\n\nIn the body of your main function, you can use these RTM macro calls to set up the model parameters and DWork data in the real-time model data structure:\n\nint_T main(int_T argc, const char *argv[]) { ... /* Pack model data into RTM */ rtmSetDefaultParam(rtM, &rtP); rtmSetRootDWork(rtM, &rtDWork); /* Initialize model */ Reusable_initialize(rtM, &rtU_In1, &rtU_In2, &rtY_Out1); ... }\n\nFollow a similar approach to set up multiple instances of model data, where the real-time model data structure for each instance has its own data. You must initialize the parameter structure (rtP) for each instance, to the values that you want, statically as part of the rtP data definition or at run time."
            },
            {
                "heading": "Rate Grouping Compliance and Compatibility Issues",
                "content": "\u2022 Main Program Compatibility\n\u2022 Make Your S-Functions Rate Grouping Compliant"
            },
            {
                "heading": "Main Program Compatibility",
                "content": "When you clear model configuration parameter Generate an example main program, the code generator produces slightly different rate grouping code, for compatibility with the older static ert_main.c module. See Rate Grouping and Static Main Function for details."
            },
            {
                "heading": "Make Your S-Functions Rate Grouping Compliant",
                "content": "Built-in Simulink\u00c2\u00ae blocks and DSP System Toolbox\u00e2\u0084\u00a2 blocks are compliant with the requirements for generating rate grouping code. However, user-written multirate inlined S-functions might not be rate grouping compliant. Noncompliant blocks generate less efficient code, but are otherwise compatible with rate grouping. To take full advantage of the efficiency of rate grouping, upgrade multirate inlined S-functions to be fully rate grouping compliant. You should upgrade your TLC S-function implementations, as described in this section.\n\nUse of noncompliant multirate blocks to generate rate-grouping code generates dead code. This can cause two problems:\n\nReduced code efficiency.Warning messages issued at compile time. Such warnings are caused when dead code references temporary variables before initialization. Since the dead code does not run there is no impact to ,the run-time behavior of the generated code.\n\nTo make your S-functions rate grouping compliant, use these TLC functions to generate ModelOutputs and ModelUpdate code, respectively:\n\nOutputsForTID(block, system, tid) UpdateForTID(block, system, tid)\n\nThese code listings illustrate generation of output computations without rate grouping (Listing 1) and with rate grouping (Listing 2).\n\nThe tid argument is a task identifier (0..NumTasks-1).Only code guarded by the tid passed into OutputsForTID is generated. The if (%<LibIsSFcnSampleHit(portName)>) test is not used in OutputsForTID. When generating rate grouping code, OutputsForTID and/or UpdateForTID is called during code generation. When generating non-rate-grouping code, Outputs and/or Update is called.In rate grouping compliant code, the top-level Outputs and/or Update functions call OutputsForTID and/or UpdateForTID functions for each rate (tid) involved in the block. The code returned by OutputsForTID and UpdateForTID must be guarded by the corresponding tid guard as in lListing 2:if (%<LibIsSFcnSampleHit(portName)>)\n\nListing 1: Outputs Code Generation Without Rate Grouping\n\n%% multirate_blk.tlc %implements \"multirate_blk\" \"C\" %% Function: mdlOutputs ===================================================== %% Abstract: %% %% Compute the two outputs (input signal decimated by the %% specified parameter). The decimation is handled by sample times. %% The decimation is only performed if the block is enabled. %% Each port has a different rate. %% %% Note, the usage of the enable should really be protected such that %% each task has its own enable state. In this example, the enable %% occurs immediately which may or may not be the expected behavior. %% %function Outputs(block, system) Output /* %<Type> Block: %<Name> */ %assign enable = LibBlockInputSignal(0, \"\", \"\", 0) { int_T *enabled = &%<LibBlockIWork(0, \"\", \"\", 0)>; %if LibGetSFcnTIDType(\"InputPortIdx0\") == \"continuous\" %% Only check the enable signal on a major time step. if (%<LibIsMajorTimeStep()> && ... %<LibIsSFcnSampleHit(\"InputPortIdx0\")>) { *enabled = (%<enable> > 0.0); } %else if (%<LibIsSFcnSampleHit(\"InputPortIdx0\")>) { *enabled = (%<enable> > 0.0); } %endif if (*enabled) { %assign signal = LibBlockInputSignal(1, \"\", \"\", 0) if (%<LibIsSFcnSampleHit(\"OutputPortIdx0\")>) { %assign y = LibBlockOutputSignal(0, \"\", \"\", 0) %<y> = %<signal>; } if (%<LibIsSFcnSampleHit(\"OutputPortIdx1\")>) { %assign y = LibBlockOutputSignal(1, \"\", \"\", 0) %<y> = %<signal>; } } } %endfunction %% [EOF] sfun_multirate.tlc\n\nListing 2: Outputs Code Generation With Rate Grouping\n\n%% example_multirateblk.tlc %implements \"example_multirateblk\" \"C\" %% Function: mdlOutputs ===================================================== %% Abstract: %% %% Compute the two outputs (the input signal decimated by the %% specified parameter). The decimation is handled by sample times. %% The decimation is only performed if the block is enabled. %% All ports have different sample rate. %% %% Note: the usage of the enable should really be protected such that %% each task has its own enable state. In this example, the enable %% occurs immediately which may or may not be the expected behavior. %% %function Outputs(block, system) Output %assign portIdxName = [\"InputPortIdx0\",\"OutputPortIdx0\",\"OutputPortIdx1\"] %assign portTID = [%<LibGetGlobalTIDFromLocalSFcnTID(\"InputPortIdx0\")>, ... %<LibGetGlobalTIDFromLocalSFcnTID(\"OutputPortIdx0\")>, ... %<LibGetGlobalTIDFromLocalSFcnTID(\"OutputPortIdx1\")>] %foreach i = 3 %assign portName = portIdxName[i] %assign tid = portTID[i] if (%<LibIsSFcnSampleHit(portName)>) { %<OutputsForTID(block,system,tid)> } %endforeach %endfunction %function OutputsForTID(block, system, tid) Output /* %<Type> Block: %<Name> */ %assign enable = LibBlockInputSignal(0, \"\", \"\", 0) %assign enabled = LibBlockIWork(0, \"\", \"\", 0) %assign signal = LibBlockInputSignal(1, \"\", \"\", 0) %switch(tid) %case LibGetGlobalTIDFromLocalSFcnTID(\"InputPortIdx0\") %if LibGetSFcnTIDType(\"InputPortIdx0\") == \"continuous\" %% Only check the enable signal on a major time step. if (%<LibIsMajorTimeStep()>) { %<enabled> = (%<enable> > 0.0); } %else %<enabled> = (%<enable> > 0.0); %endif %break %case LibGetGlobalTIDFromLocalSFcnTID(\"OutputPortIdx0\") if (%<enabled>) { %assign y = LibBlockOutputSignal(0, \"\", \"\", 0) %<y> = %<signal>; } %break %case LibGetGlobalTIDFromLocalSFcnTID(\"OutputPortIdx1\") if (%<enabled>) { %assign y = LibBlockOutputSignal(1, \"\", \"\", 0) %<y> = %<signal>; } %break %default %% error it out %endswitch %endfunction %% [EOF] sfun_multirate.tlc"
            },
            {
                "heading": "Generate Code That Dereferences Data from a Literal Memory Address",
                "content": "This example shows how to generate code that reads the value of a signal by dereferencing a memory address that you specify. With this technique, you can generate a control algorithm that interacts with memory that your hardware populates (for example, memory that stores the output of an analog-to-digital converter in a microcontroller).\n\nIn this example, you generate an algorithm that acquires input data from a 16-bit block of memory at address 0x8675309. Assume that a hardware device asynchronously populates only the lower 10 bits of the address. The algorithm must treat the address as read-only (const), volatile (volatile) data, and ignore the upper 6 bits of the address.\n\nThe generated code can access the data by defining a macro that dereferences 0x8675309 and masks the unnecessary bits:\n\n#define A2D_INPUT ((*(volatile const uint16_T *)0x8675309)&0x03FF)\n\nTo configure a model to generate code that defines and uses this macro:\n\nCreate the example model.Create package to contain definitions of data class and storage class.Use Custom Storage Class Designer to create a storage class.Define a class to store property settings for the storage class.Write Target Language Compiler (TLC) code that emits the correct C code for the storage class.Define a class for the inport data.Load the package into the Embedded Coder\u00c2\u00ae Dictionary.Configure the model root-level inport to use the storage class.Generate and inspect the code.\n\nFor an example that shows how to use the Custom Storage Class Designer without writing TLC code, see Create and Apply Storage Class Defined in User-Defined Package.\n\nAs an alternative to writing TLC code, you can use memory sections to generate code that includes pragmas. Depending on your build toolchain, you can use pragmas to specify a literal memory address for storing a global variable. For more information about memory sections, see Control Data and Function Placement in Memory by Inserting Pragmas.\n\nDerivation of Macro SyntaxIn this example, you configure the generated code to define and use the dereferencing macro. To determine the correct syntax for the macro, start by recording the target address. 0x8675309 Cast the address as a pointer to a 16-bit integer. Use the Simulink\u00c2\u00ae Coder\u00e2\u0084\u00a2 data type name uint16_T. (uint16_T *)0x8675309 Add the storage type qualifier const because the generated code must not write to the address. Add volatile because the hardware can populate the address at an arbitrary time. (volatile const uint16_T *)0x8675309 Dereference the address. *(volatile const uint16_T *)0x8675309 After the dereference operation, apply a mask to retain only the 10 bits that the hardware populates. Use explicit parentheses to control the order of operations. (*(volatile const uint16_T *)0x8675309)&0x03FF As a safe coding practice, wrap the entire construct in another layer of parentheses. ((*(volatile const uint16_T *)0x8675309)&0x03FF) Create Example ModelCreate the example model ex_memmap_simple.For the Inport block, set the output data type to uint16. Name the signal as A2D_INPUT. The Inport block and the signal line represent the data that the hardware populates.For the Gain block, set the output data type to double.Create Package to Contain Definitions of Data Class and Storage ClassIn your current folder, create MATLAB\u00c2\u00ae namespace folder +MemoryMap. The folder contains files that define a package named MemoryMap.To make the package available for use outside of your current folder, you can add the folder that contains the namespace folder +MemoryMap to the MATLAB\u00c2\u00ae search path.Create Storage ClassTo generate code that defines and reads A2D_INPUT as a macro, you must create a storage class that you can apply to the model root-level inport. Later, you write TLC code that complements the storage class.Open the Custom Storage Class designer in advanced mode. To design a storage class that operates through custom TLC code, you must use the advanced mode.cscdesigner('MemoryMap','-advanced'); In the Custom Storage Class Designer, click New. A new custom storage class, NewCSC_1, appears in the list of storage class definitions.Rename the storage class to MemoryMappedAddress.For MemoryMappedAddress, on the General tab, set: Type to Other. The storage class can operate through custom TLC code that you write later. Data scope to Exported. For data items that use this custom storage class, Simulink Coder generates the definition (for example, the #define statement that defines a macro). Data initialization to None. Simulink Coder does not generate code that initializes the data item. Use this setting because this custom storage class represents read-only data. You do not select Macro because the Custom Storage Class Designer does not allow you to use Macro for signal data. Definition file to Specify (leave the text box empty). For data items that consume memory in the generated code, Definition file specifies the .c source file that allocates the memory. This storage class yields a macro, which does not require memory. Typically, header files (.h), not .c files, define macros. Setting Definition file to Specify instead of Instance specific prevents users of the storage class from unnecessarily specifying a definition file. Header file to Instance specific. To control the file placement of the macro definition, the user of the storage class must specify a header file for each data item that uses this storage class. Owner to Specify (leave the text box empty). Owner applies only to data items that consume memory.After you finish selecting the settings, click Apply and Save.Now, when you apply the storage class to a data item, such as inport In1, you can specify a header file to contain the generated macro definition. You cannot yet specify a memory address for the data item. To enable specification of a memory address, create a custom attributes class that you can associate with the MemoryMappedAddress storage class.Define Class to Store Property Settings for Storage ClassDefine a MATLAB class to store additional information for data items that use the storage class. In this case, the additional information is the memory address.In the namespace folder +MemoryMap, create a folder named @MemoryMapAttribs.In the @MemoryMapAttribs folder, create a file named MemoryMapAttribs. The file defines a class that derives from the built-in class Simulink.CustomStorageClassAttributes.classdef MemoryMapAttribs < Simulink.CustomStorageClassAttributes properties( PropertyType = 'char' ) MemoryAddress = ''; end end Later, you associate this MATLAB class with the MemoryMappedAddress storage class. Then, when you apply the storage class to a data item, you can specify a memory address.Write TLC Code That Emits Correct C CodeWrite TLC code that uses the attributes of the storage class, such as HeaderFile and MemoryAddress, to generate correct C code for each data item.In the namespace folder +MemoryMap, create a folder named tlc.Navigate to the new folder.Inspect the built-in template TLC file, TEMPLATE_v1.tlc.edit(fullfile(matlabroot,... 'toolbox','rtw','targets','ecoder','csc_templates','TEMPLATE_v1.tlc')) Save a copy of TEMPLATE_v1.tlc in the tlc folder. Rename the copy memory_map_csc.tlc.In memory_map_csc.tlc, find the portion that controls the generation of C-code data declarations. %case \"declare\" %% LibDefaultCustomStorageDeclare is the default declare function to %% declares a global variable whose identifier is the name of the data. %return \"extern %<LibDefaultCustomStorageDeclare(record)>\" %%break %% ========================================================================== The declare case (%case) constructs a return value (%return), which the code generator emits into the header file that you specify for each data item. To control the C code that declares each data item, adjust the return value in the declare case.Replace the existing %case content with this code, which specifies a different return value:%case \"declare\" %% In TLC code, a 'record' is a data item (for example, a signal line). %% 'LibGetRecordIdentifier' returns the name of the data item. %assign id = LibGetRecordIdentifier(record) %assign dt = LibGetRecordCompositeDataTypeName(record) %% The 'CoderInfo' property of a data item stores a %% 'Simulink.CoderInfo' object, which stores code generation settings %% such as the storage class or custom storage class that you specify %% for the item. %assign ci = record.Object.ObjectProperties.CoderInfo %% The 'ci' variable now stores the 'Simulink.CoderInfo' object. %% By default, the 'CustomAttributes' property of a 'Simulink.CoderInfo' %% object stores a 'Simulink.CustomStorageClassAttributes' object. %% This nested object stores specialized code generation settings %% such as the header file and definition file that you specify for %% the data item. %% %% The 'MemoryMap' package derives a new class, %% 'MemoryMapAttribs', from 'Simulink.CustomStorageClassAttributes'. %% The new class adds a property named 'MemoryAddress'. %% This TLC code determines the memory address of the data item by %% acquiring the value of the 'MemoryAddress' property. %assign ca = ci.Object.ObjectProperties.CustomAttributes %assign address = ca.Object.ObjectProperties.MemoryAddress %assign width = LibGetDataWidth(record) %% This TLC code constructs the full macro, with correct C syntax, %% based on the values of TLC variables such as 'address' and 'dt'. %% This TLC code also asserts that the data item must be a scalar. %if width == 1 %assign macro = ... \"#define %<id> ((*(volatile const %<dt>*)%<address>) & 0x03FF)\" %else %error( \"Non scalars are not supported yet.\" ) %endif %return \"%<macro>\" %%break %% ========================================================================== The new TLC code uses built-in, documented TLC functions, such as LibGetRecordIdentifier, and other TLC commands and operations to access information about the data item. Temporary variables such as dt and address store that information. The TLC code constructs the full macro, with the correct C syntax, by expanding the variables, and stores the macro in the variable macro.In the same file, find the portion that controls the generation of data definitions. %case \"define\" %% LibDefaultCustomStorageDefine is the default define function to define %% a global variable whose identifier is the name of the data. If the %% data is a parameter, the definition is also statically initialized to %% its nominal value (as set in MATLAB). %return \"%<LibDefaultCustomStorageDefine(record)>\" %%break %% ========================================================================== The define case derives a return value that the code generator emits into a .c file, which defines data items that consume memory.Replace the existing %case content with this new content: %case \"define\" %return \"\" %%break %% ========================================================================== MemoryMappedAddress yields a macro in the generated code, so you use the declare case instead of the define case to construct and emit the macro. To prevent the define case from emitting a duplicate macro definition, the new TLC code returns an empty string.Find the portion that controls the generation of code that initializes data. %case \"initialize\" %% LibDefaultCustomStorageInitialize is the default initialization %% function that initializes a scalar element of a global variable to 0. %return LibDefaultCustomStorageInitialize(record, idx, reim) %%break %% ========================================================================== The initialize case generates code that initializes data items (for example, in the model_initialize function).Replace the existing %case content with this new content: %case \"initialize\" %return \"\" %%break %% ========================================================================== MemoryMappedAddress yields a macro, so the generated code must not attempt to initialize the value of the macro. The new TLC code returns an empty string.Complete the Definition of the Storage ClassYour MATLAB class, MemoryMapAttribs, can enable users of your storage class, MemoryMappedAddress, to specify a memory address for each data item. To allow this specification, associate MemoryMapAttribs with MemoryMappedAddress. To generate correct C code based on the information that you specify for each data item, associate the customized TLC file, memory_map_csc.tlc, with MemoryMappedAddress.Navigate to the folder that contains the namespace folder +MemoryMap.Open the Custom Storage Class Designer again.cscdesigner('MemoryMap','-advanced'); For MemoryMappedAddress, on the Other Attributes tab, set: TLC file name to memory_map_csc.tlc. CSC attributes class to MemoryMap.MemoryMapAttribs.Click Apply and Save.Define Signal Data ClassTo apply the storage class to a data element in a model, in the package namespace folder +MemoryMap, you must create a MATLAB class that derives from Simulink.Signal. When you configure the signal in the model, you select this new data class instead of the default class, Simulink.Signal.In the package namespace folder +MemoryMap, create a folder named @Signal.In the @Signal folder, create a file named Signal.m.classdef Signal < Simulink.Signal methods function setupCoderInfo( this ) useLocalCustomStorageClasses( this, 'MemoryMap' ); return; end end end The file defines a class named MemoryMap.Signal. The class definition overrides the setupCoderInfo method, which the Simulink.Signal class already implements. The new implementation specifies that objects of the MemoryMap.Signal class use custom storage classes from the MemoryMap package (instead of storage classes from the Simulink package). When you configure a signal in a model by selecting the MemoryMap.Signal class, you can select the new custom storage class, MemoryMappedAddress.Load Package into Embedded Coder DictionaryOpen the example model.Open the Embedded Coder app.Open the Embedded Coder Dictionary. On the C Code tab, select Code Interface > Embedded Coder Dictionary.In the Embedded Coder Dictionary, click Manage Packages.In the Manage Package dialog box, click Refresh. When the refresh is complete, select the package MemoryMap. Click Load.Close the Embedded Coder Dictionary.Configure Root-Level Inport to Use Storage ClassIn the Embedded Coder app, use the Code Mappings editor and Property Inspector to configure Inport In1 to use the storage class that you defined.Open the Code Mappings editor. On the C Code tab, select Code Interface > Individual Element Code Mappings.In the Code Mappings Editor, on the Inports tab, select inport In1. Set the storage class for In1 to MemoryMappedAddress.In the Property Inspector, under Code, set the HeaderFile property to memory_mapped_addresses.h and the MemoryAddress property to 0x8675309.Save the model.Generate and Inspect CodeGenerate code from the model.### Starting build procedure for: ex_memmap_simple ### Successful completion of build procedure for: ex_memmap_simple Build Summary Top model targets: Model Build Reason Status Build Duration =================================================================================================================== ex_memmap_simple Information cache folder or artifacts were missing. Code generated and compiled. 0h 0m 14.902s 1 of 1 models built (0 models already up to date) Build duration: 0h 0m 15.798s Inspect the generated header file memory_mapped_addresses.h. The file defines the macro A2D_INPUT, which corresponds to the signal line in the model./* Declaration of data with custom storage class MemoryMappedAddress */ #define A2D_INPUT ((*(volatile const uint16_T*)0x8675309) & 0x03FF) Inspect the generated file ex_memmap_simple.c. The generated algorithmic code (which corresponds to the Gain block) calculates the model output, rtY.Out1, by operating on A2D_INPUT./* Model step function */ void step(void) { /* Outport: '<Root>/Out1' incorporates: * Gain: '<Root>/Gain' * Inport: '<Root>/In1' */ rtY.Out1 = 42.0 * (real_T)A2D_INPUT; }"
            }
        ],
        "link": "https://in.mathworks.com/help/ecoder/ug/standalone-programs-no-operating-system.html",
        "images": [
            "https://in.mathworks.com/help/examples/ecoder/win64/MemoryMappingEcoderExample_01.png"
        ]
    },
    {
        "title": "Troubleshoot Model Links to Static Libraries or Shared Objects",
        "introduction": "Some model build and runtime issues occur when linking a real-time application to static libraries (.a) or shared objects (.so). FMU",
        "chunks": [
            {
                "heading": "What This Issue Means",
                "content": "When building or running real-time an application that links to static link libraries (.a) or shared object libraries (.so), there are some considerations that help you use libraries that are compatible with the QNX\u00c2\u00ae Neutrino\u00c2\u00ae RTOS on the Speedgoat\u00c2\u00ae target computer. These recommendations are helpful when troubleshooting library usage, including:\n\nA link to a library from QNX Neutrino RTOS that is available in the Simulink Real-Time target support packageA shared object that is included in the model through an FMU blockA custom static library or shared object that is linked to the real-time application"
            },
            {
                "heading": "Try This Workaround",
                "content": "These workarounds explore the possible issues."
            },
            {
                "heading": "Link to Accessible Libraries or Objects",
                "content": "When you link to a static library or shared object, the library or object must be:\n\nCompatible with the QNX Neutrino RTOSAccessible to the toolchain at build time\n\nCheck to ensure that you have followed the guidelines for library compatibility. See External Code Integration of Libraries and C/C++ Code with Simulink Real-Time Models. Check that the toolchain can access the library at build time. Remember that the QNX Neutrino cannot process spaces in the path to files."
            },
            {
                "heading": "Install Shared Objects on Target Computer",
                "content": "After you build the real-time application that links to a shared object, install both the real-time application and the shared object on the target computer. Copy the shared objects to a location on the target computer where they can be found and loaded at runtime. The recommended locations are /lib, /usr/lib, or /usr/local/lib. Root access is required to copy files to these locations."
            },
            {
                "heading": "Rebuild Real-Time Application When Rebuilding Static Libraries",
                "content": "Because linked static libraries are included in the real-time application, when you modify and rebuild a static library, you rebuild any real-time applications that include that library. After rebuilding the static library and the real-time application, reinstall the real-time application on the target computer."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ug/troubleshoot-model-links-to-static-libraries-or-shared-objects.html",
        "images": []
    },
    {
        "title": "Write Fully Inlined S-Functions",
        "introduction": "A fully inlined S-function builds your algorithm (block) into generated code that you cannot distinguish from a built-in block. Typically, a fully inlined S-function requires you to implement your algorithm twice: once for the Simulink model (C/C++ MEX S-function) and once for code generation (TLC file). Using the example in Write Wrapper S-Function and TLC Files, you can eliminate the call to my_alg entirely by specifying the explicit code (that is, 2.0 * u) in wrapsfcn.tlc. While this can improve performance, if you are working with a large amount of C/C++ code, the task can be lengthy. You also have to maintain your algorithm in two places, the C/C++ S-function itself and the corresponding TLC file. Consider whether the performance gains might outweigh the disadvantages. To inline the algorithm used in this example, in the Outputs section of your wrapsfcn.tlc file, instead of writing: Use: This code is the code produced in mdlOutputs: The Target Language Compiler replaces the call to my_alg with the algorithm itself.",
        "chunks": [
            {
                "heading": "Multiport S-Function",
                "content": "A more advanced multiport inlined S-function example is sfun_multiport.c and sfun_multiport.tlc. This S-function illustrates how to create a fully inlined TLC file for an S-function that contains multiple ports."
            },
            {
                "heading": "Guidelines for Writing Inlined S-Functions",
                "content": "Consider using the block property RTWdata (see S-Function RTWdata). This property is a structure of character vectors that you can associate with a block. The code generator saves the structure with the model in the model.rtw file and makes the .rtw file more readable. For example in the MATLAB Command Window, suppose you enter these commands:mydata.field1 = 'information for field1'; mydata.field2 = 'information for field2'; set_param(sfun_block, 'RTWdata', mydata);The .rtw file that the code generator produces for the block includes the comments specified in the structure mydata.Consider using the mdlRTW function to inline your C MEX S-function in the generated code for:Renaming tunable parameters in the generated code.Introducing non-tunable parameters into a TLC file."
            }
        ],
        "link": "https://in.mathworks.com/help/rtw/ug/write-fully-inlined-s-functions.html",
        "images": []
    },
    {
        "title": "Simulink External Mode Interface",
        "introduction": "To connect your Simulink\u00c2\u00ae model to your real-time application, use the procedure in Execute Real-Time Application in Simulink External Mode by Using Step-by-Step Commands. The model becomes a user interface to the real-time application. By changing parameters in the Simulink blocks, you also change parameters in the real-time application. The Simulink external mode interface includes:",
        "chunks": [],
        "link": "https://in.mathworks.com/help/slrealtime/gs/simulink-external-mode-interface.html",
        "images": []
    },
    {
        "title": "Comparing Performance",
        "introduction": "When simulation execution time exceeds the time required for code generation, accelerator and rapid accelerator simulation modes give speed improvement compared to normal mode. Accelerator and rapid accelerator modes generally perform better than normal mode when simulation execution times are several minutes or more. However, models with a significant number of Stateflow\u00c2\u00ae or MATLAB Function blocks might show only a small speed improvement over normal mode because these blocks also simulate through code generation in normal mode. Including tunable parameters in your model can also increase the simulation time. The figure shows the relative performance of normal mode, accelerator mode, and rapid accelerator mode simulations in general terms for a hypothetical model. Simulink.SimulationInput | Simulink.SimulationOutput",
        "chunks": [
            {
                "heading": "Performance When Target Must Be Rebuilt",
                "content": "The solid lines, labeled all targets out of date, in the figure show performance when the target code must be rebuilt. For this hypothetical model, the time scale is on the order of minutes. However, the time scale could be longer for more complex models.\n\nCompiling a model in normal mode generally requires less time than building the accelerator target or the rapid accelerator executable. For small simulation stop times, normal mode results in quicker overall simulations compared to the accelerator and rapid accelerator modes.\n\nThe crossover point where accelerator mode or rapid accelerator mode results in faster overall simulation depends on the complexity and content of your model. For example, models that contain large numbers of blocks that use interpreted code might not run much faster in accelerator mode than they would in normal mode unless the simulation stop time is very large. For more information, see Select Blocks for Accelerator Mode. Similarly, models with a large number of Stateflow charts or MATLAB Function blocks might not show much speed improvement over normal mode unless the simulation stop time is large. You can speed up the simulation of models with Stateflow or MATLAB Function blocks through code generation.\n\nThe figure represents a model with a large number of Stateflow charts or MATLAB Function blocks. The curve labeled Normal would have a much smaller initial elapsed time than shown if the model did not contain these blocks."
            },
            {
                "heading": "Performance When Targets Are Up to Date",
                "content": "The dashed lines, labeled all targets up to date, in the figure show that the time to determine whether the accelerator target or the rapid accelerator executable is up to date is significantly smaller than the time required to generate code, which is represented by the solid lines, labeled all targets out of date. You can take advantage of this characteristic when you wish to test various design tradeoffs.\n\nFor instance, you can generate the accelerator mode target once and use it to simulate your model with a series of gain settings. This method is especially efficient for the accelerator or rapid accelerator modes because this type of change does not result in the target code being regenerated. The target code is generated the first time the model runs, but on subsequent runs, the software spends only the time necessary to verify that the target is up to date. This process is much faster than generating code, so subsequent runs can be significantly faster than the initial run.\n\nBecause checking the targets is quicker than code generation, the crossover point is smaller when the target is up to date than when code must be generated. Subsequent runs of your model might simulate faster in accelerator or rapid accelerator mode when compared to normal mode, even for small stop times."
            },
            {
                "heading": "Analyze Performance of Simulation Modes",
                "content": "Open Live Script\n\nTo see the effect of using accelerator or rapid accelerator mode for simulations of your model, you can run equivalent simulations using different simulation modes. Simulate the model in a way that returns the results as a single Simulink.SimulationOutput object that includes simulation metadata. That way, you can inspect the timing information captured in the simulation metadata for each simulation to analyze the performance of each simulation mode.\n\nThis example uses Simulink.SimulationInput objects to configure model parameter values to use for three simulations of the model sldemo_fuelsys. For more information about the model, see Model Fault-Tolerant Fuel Control System.\n\nmodel = \"sldemo_fuelsys\";\n\nTo configure the baseline simulation, create a Simulink.SimulationInput object.\n\nsimIn = Simulink.SimulationInput(model);\n\nThe SimulationInput object stores parameter values to use in the simulation. The parameter values on the object are applied for the simulation and reverted at the end of simulation so that the model remains unchanged.\n\nSet the stop time to 10000. Set the simulation mode to Normal.\n\nsimIn = setModelParameter(simIn,\"StopTime\",\"10000\"); simIn = setModelParameter(simIn,\"SimulationMode\",\"normal\");\n\nTo capture baseline timing information, simulate the model.\n\nsimOut = sim(simIn);\n\nThe simulation returns results as a single Simulink.SimulationOutput object that contains all logged data and simulation metadata. The metadata is stored as a Simulink.SimulationMetadata object that contains information about the simulation, including a structure, TimingInfo, that contains timing information.\n\nnormalMode = simOut.SimulationMetadata.TimingInfo;\n\nFrom the timing information, extract the initialization time, execution time, and total elapsed time for the simulation.\n\nnormalInit = normalMode.InitializationElapsedWallTime; normalExec = normalMode.ExecutionElapsedWallTime; normalTotal = normalMode.TotalElapsedWallTime;\n\nSimulate the model again using rapid accelerator mode. The first time you simulate a model in rapid accelerator mode, the rapid accelerator target builds during the initialization phase.\n\nsimIn = setModelParameter(simIn,\"SimulationMode\",\"rapid\"); simOut = sim(simIn);\n\n### Building the rapid accelerator target for model: sldemo_fuelsys ### Successfully built the rapid accelerator target for model: sldemo_fuelsys Build Summary Top model rapid accelerator targets built: Model Action Rebuild Reason ================================================================================================ sldemo_fuelsys Code generated and compiled. Code generation information file does not exist. 1 of 1 models built (0 models already up to date) Build duration: 0h 0m 38.279s\n\nAccess the timing information for the first rapid accelerator simulation. Then, extract the initialization time, execution time, and total elapsed time for the simulation.\n\nrapidAccel = simOut.SimulationMetadata.TimingInfo; rapidBuildInit = rapidAccel.InitializationElapsedWallTime; rapidBuildExec = rapidAccel.ExecutionElapsedWallTime; rapidBuildTotal = rapidAccel.TotalElapsedWallTime;\n\nSimulate again to see the benefit of rapid accelerator mode for a simulation that does not build the rapid accelerator target.\n\nsimOut = sim(simIn);\n\nBuild Summary 0 of 1 models built (1 models already up to date) Build duration: 0h 0m 2.684s\n\nAccess the timing information for the rapid accelerator simulation that ran without building the target. Then, extract the initialization time, the execution time, and the total elapsed time for the simulation.\n\nrapidAccelNoRebuild = simOut.SimulationMetadata.TimingInfo; rapidInit = rapidAccelNoRebuild.InitializationElapsedWallTime; rapidExec = rapidAccelNoRebuild.ExecutionElapsedWallTime; rapidTotal = rapidAccelNoRebuild.TotalElapsedWallTime;\n\nBuild a table to compare the timing for each simulation.\n\nInitializationTime = [normalInit;rapidBuildInit;rapidInit]; ExecutionTime = [normalExec;rapidBuildExec;rapidExec]; TotalSimulationTime = [normalTotal;rapidBuildTotal;rapidTotal]; simNames = [\"Normal Mode\";\"Rapid Accelerator\";\"Rapid Accelerator No Rebuild\"]; timingTable = table(TotalSimulationTime,InitializationTime, ... ExecutionTime,RowNames=simNames);\n\nIn the first rapid accelerator simulation, the initialization time increases because the rapid accelerator target builds during the initialization phase. For this model and simulation duration, using rapid accelerator mode reduces the execution time so much that the first rapid accelerator simulation is still faster than using normal mode.\n\ntimingTable\n\ntimingTable=3\u00c3\u00973 table TotalSimulationTime InitializationTime ExecutionTime ___________________ __________________ _____________ Normal Mode 108.91 12.411 96.437 Rapid Accelerator 68.44 40.962 26.152 Rapid Accelerator No Rebuild 17.403 3.387 13.886"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/ug/comparing-performance.html",
        "images": [
            "https://in.mathworks.com/help/simulink/ug/rapid_accel_4b.png"
        ]
    },
    {
        "title": "Programmatically Create Bus Element Ports - MATLAB &amp; Simulink\n",
        "introduction": "",
        "chunks": [
            {
                "heading": "Open Model",
                "content": "Create and open a model named BusElementPortCreation.\n\nmodel = \"BusElementPortCreation\"; new_system(model); open_system(model);"
            },
            {
                "heading": "Add Bus Element Ports",
                "content": "Bus element ports correspond with In Bus Element and Out Bus Element blocks in a subsystem or model.\n\nWhen you add an In Bus Element or Out Bus Element block programmatically, specify properties such as the corresponding port name and the element to associate with the block. When you expect a subsystem or model to have more than one input or output bus element port, specifying unique and meaningful port names upfront can help capture your design intent.\n\nFor example, add an In Bus Element block that selects a signal named F1 from a port named Control.\n\nadd_block(\"simulink/Ports & Subsystems/In Bus Element\", ... \"BusElementPortCreation/InBusElement\", ... PortName=\"Control\", ... Element=\"F1\")\n\nAdd another In Bus Element block that selects the entire signal from a port named Disturbance. Set MakeNameUnique to \"on\" or specify a unique name for the new block. Optionally, specify a position for the new block so that it does not overlap the existing block.\n\nadd_block(\"simulink/Ports & Subsystems/In Bus Element\", ... \"BusElementPortCreation/InBusElement1\", ... Position=[230 65 240 75], ... PortName=\"Disturbance\", ... Element=\"\")\n\nThe block label does not include an element name because the block corresponds with the top-level element, which can be a bus, signal, or message.\n\nAdd an Out Bus Element block that provides output to an element named x1 for a port named Sensor.\n\nadd_block(\"simulink/Ports & Subsystems/Out Bus Element\", ... \"BusElementPortCreation/OutBusElement\", ... Position=[230 95 240 105], ... PortName=\"Sensor\", ... Element=\"x1\");\n\nAs you create bus element ports and the corresponding blocks, consider these details:\n\nMultiple In Bus Element blocks can select the same element from a port.Each Out Bus Element block must correspond with a unique element to avoid conflicts.When you rename a port after creation, the change applies to all blocks that correspond with the port."
            },
            {
                "heading": "Add Block for Existing Port",
                "content": "To add an In Bus Element or Out Bus Element block for an existing port, copy a block that corresponds with the port.\n\nFor example, copy the block that corresponds with the Control port and specify that the new block selects the element named F2 from the port.\n\nadd_block(\"BusElementPortCreation/InBusElement\", ... \"BusElementPortCreation/InBusElement\", ... MakeNameUnique=\"on\", ... Position=[230 35 240 45], ... PortName=\"Control\", ... Element=\"F2\")\n\nOptionally, get the full block path of the new block in the current model.\n\nControlF2Path = gcb\n\nControlF2Path = 'BusElementPortCreation/InBusElement2'"
            },
            {
                "heading": "Edit Block Parameters",
                "content": "Each In Bus Element and Out Bus Element block lets you change parameters such as the port name (PortName), the element associated with the block (Element), and the block color (BackgroundColor).\n\nFor example, change the background colors of the In Bus Element blocks for the Control port.\n\nset_param(\"BusElementPortCreation/InBusElement\", ... BackgroundColor=\"cyan\"); set_param(ControlF2Path, ... BackgroundColor=\"magenta\");\n\nFor another example, suppose the Disturbance port expects a bus that contains two elements:\n\nA signal named NoiseA nested bus named ExternalForce that contains signals named F1 and F2\n\nInstead of selecting the entire input from the Disturbance port, select only the signal named F1. When you specify the element, use dots to represent hierarchy within the bus.\n\nset_param(\"BusElementPortCreation/InBusElement1\", ... Element=\"ExternalForce.F1\");"
            },
            {
                "heading": "Specify Attributes of Top-Level Bus, Signal, or Message",
                "content": "To specify the attributes of the top-level bus, signal, or message at a bus element port, use the set_param function. For the first argument of this function, specify the port using:\n\nThe model name for a root port or the subsystem block path for a subsystem portThe port name\n\nFor example, suppose the Sensor port must provide a bus hierarchy defined by this Simulink.Bus object:\n\nelems(1) = Simulink.BusElement; elems(1).Name = 'x1'; elems(1).DataType = 'double'; elems(1).Min = 0.01; elems(1).Max = 4; elems(2) = Simulink.BusElement; elems(2).Name = 'x2'; elems(2).DataType = 'double'; elems(2).Min = 0.01; elems(2).Max = 4; Sensor = Simulink.Bus; Sensor.Elements = elems;\n\nSet the output data type of the port to the bus object named Sensor. For the first argument, combine the model name (BusElementPortCreation) and the port name (Sensor).\n\nset_param(\"BusElementPortCreation/Sensor\", ... OutDataTypeStr=\"Bus: Sensor\");\n\nTo view the interface definition, double-click the Out Bus Element block or use the Property Inspector.\n\nTo inspect the attribute values for an element programmatically, use the get_param function.\n\nget_param(\"BusElementPortCreation/Sensor.x2\",\"OutMin\")\n\nans = '0.01'"
            },
            {
                "heading": "Specify Bus Elements and Their Attributes",
                "content": "When a bus is not defined by a Simulink.Bus object, specify bus elements at the interface with or without adding blocks to the block diagram.\n\nTo specify element attributes for existing elements at the port, use the set_param function. For the first argument of this function, specify the element using:\n\nThe model name for a root port or the subsystem block path for a subsystem portThe port nameThe element path within the port\n\nFor example, specify attributes of the element named F1 at the Disturbance port. For the first argument, combine the model name (BusElementPortCreation), the port name (Disturbance), and the element path (ExternalForce.F1).\n\nset_param(\"BusElementPortCreation/Disturbance.ExternalForce.F1\", ... OutMin=\"-400\", ... OutMax=\"800\")\n\nTo define a new element at the port, add a block or add the element with the Simulink.Bus.addElementToPort function. To specify the new element, use the first three arguments to provide these values, respectively:\n\nThe model name for a root port or the subsystem block path for a subsystem portThe port nameThe element path within the port\n\nFor example, define these additional elements expected at the Disturbance port:\n\nA signal named NoiseA signal named F2 in the nested bus named ExternalForce\n\nFor the first argument, provide the model name (BusElementPortCreation). For the second argument, provide the port name (Disturbance). For the third argument, provide the element path (ExternalForce.F2 or Noise).\n\nSimulink.Bus.addElementToPort(\"BusElementPortCreation\", ... \"Disturbance\",\"ExternalForce.F2\"); Simulink.Bus.addElementToPort(\"BusElementPortCreation\", ... \"Disturbance\",\"Noise\");\n\nAfter you define a new element at the port, specify the element attributes with the set_param function.\n\nset_param(\"BusElementPortCreation/Disturbance.ExternalForce.F2\", ... OutMin=\"-400\", ... OutMax=\"800\") set_param(\"BusElementPortCreation/Disturbance.Noise\", ... OutMin=\"-10\", ... OutMax=\"10\")\n\nTo view the interface definition, double-click the related In Bus Element block or use the Property Inspector.\n\nTo inspect the attribute values for an element programmatically, use the get_param function.\n\nget_param(\"BusElementPortCreation/Disturbance.Noise\",\"OutMin\")\n\nans = '-10'"
            },
            {
                "heading": "Examine Results",
                "content": "This example creates three ports, named Control, Disturbance, and Sensor. While blocks provide access to some of the elements of the ports, other elements are not accessed by blocks. The ports let you specify the attributes of elements regardless of whether blocks access the elements."
            },
            {
                "heading": "Blocks",
                "content": "\u2022 In Bus Element | Out Bus Element"
            },
            {
                "heading": "Functions",
                "content": "\u2022 add_block | set_param | get_param | Simulink.Bus.addElementToPort | add_line\n\n\u2022 Simplify Bus Interfaces in Subsystems and Models\n\n\u2022 Reduced Bus Wiring: Bus Element Ports (2 min, 7 sec)"
            }
        ],
        "link": "https://in.mathworks.com/help/simulink/slref/programmatically-create-in-bus-element-blocks.html",
        "images": [
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_01.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_02.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_03.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_04.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_05.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_06.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_07.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_08.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_09.png",
            "https://in.mathworks.com/help/examples/simulink/win64/ProgrammaticallyCreateBusElementPortsExample_10.png"
        ]
    },
    {
        "title": "Target Computer Status Monitor",
        "introduction": "The status monitor application on the Speedgoat\u00c2\u00ae target computer displays the status of the real-time application, disk usage, and other target computer status information. The target computer display supports multiple sessions. You can choose to display the status monitor (default, session 1) or display the target computer command-line interface (session 2).",
        "chunks": [
            {
                "heading": "Display Status Monitor",
                "content": "Start the target computer.\n\nThe target computer displays session 1 (default) and the target computer status monitor."
            },
            {
                "heading": "Display Status Monitor by Using PuTTY",
                "content": "To view the status monitor from the development computer, use PuTTY to open an SSH client and start the status monitor application statusmonitor on the target computer. Keyboard commands for the status monitor include:\n\nQ (quit)Up arrow (scroll up in the log)Down arrow (scroll down in the log)\n\nFor more information about PuTTY, see Execute Target Computer RTOS Commands at Target Computer Command Line.\n\nTo display the target computer command-line interface, switch to display session 2:\n\nStart the target computer. The target computer displays session 1 and the target computer status monitor.To switch to session 2 and use the target computer command-line interface, on the target computer keyboard (console), press Ctrl+Alt+2.To switch back to session 1 (status monitor), on the target computer keyboard (console), press Ctrl+Alt+1."
            }
        ],
        "link": "https://in.mathworks.com/help/slrealtime/ref/target-computer-status-monitor.html",
        "images": [
            "https://in.mathworks.com/help/slrealtime/ref/window-simulink-real-time-target-computer-monitor-console.jpg"
        ]
    }
]